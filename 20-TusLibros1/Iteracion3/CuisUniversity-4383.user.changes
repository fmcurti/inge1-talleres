

----STARTUP---- (29 October 2020 16:57:49) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!classRemoval: #GameOfLife stamp: 'FC 10/29/2020 17:26:50'!
Object subclass: #GameOfLife
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classRemoval: #GameOfLifeTest stamp: 'FC 10/29/2020 17:26:50'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliTest category: 'TerniLapilli' stamp: 'FC 10/29/2020 17:33:18'!
TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/29/2020 17:35:04'!
Object subclass: #TerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliTest methodsFor: 'no messages' stamp: 'FC 10/29/2020 17:34:55'!
test01
	| game |
	game := TerniLapilli new.
	
	self assert: game isPlayingX.
	! !

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:35:18'!
ERROR!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:35:18'!
ERROR!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:35:31'!
ERROR!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:35:31'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:35:43'!
isPlayingX
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:35:48' prior: 50901838!
isPlayingX
	^true.! !

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:35:50'!
PASSED!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:35:52'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:37:05'!
test02
	| game |
	game := TerniLapilli new.
	
	game putXAt: 2@2.
	
	self assert: game isPlayingO.
	! !

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:37:17'!
ERROR!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:37:17'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:37:34'!
putXAt: aPoint 
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:37:40' prior: 50901862!
putXAt: aPoint 
	! !

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:37:41'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:37:48'!
isPlayingO
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:37:53' prior: 50901873!
isPlayingO
	^true.! !

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:37:55'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:37:57'!
PASSED!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:37:57'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:37:57'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:38:49' prior: 50901851!
test02
	| game |
	game := TerniLapilli new.
	
	game putXAt: 2@2.
	
	self assert: game isPlayingO.
	self deny: game isPlayingX.! !

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:38:50'!
FAILURE!

Object subclass: #TerniLapilli
	instanceVariableNames: 'currentTurn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/29/2020 17:38:59'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'currentTurn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:39:12' prior: 50901867!
putXAt: aPoint 
	currentTurn := #O! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:39:30' overrides: 16896425!
initialize 
	currentTurn := #X.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:39:50' prior: 50901877!
isPlayingO
	^currentTurn = #O.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:40:00' prior: 50901842!
isPlayingX
	^currentTurn = #X.! !

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:40:02'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:40:02'!
PASSED!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:40:05'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:40:05'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:41:51'!
test03
	| game |
	game := TerniLapilli new.
	
	game putOAt: 2@2.
	
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:42:17' prior: 50901938!
test03
	| game |
	game := TerniLapilli new.
	
	self should: [game putOAt: 2@2] raise: Error.
	
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:43:06' prior: 50901944!
test03
	| game |
	game := TerniLapilli new.
	
	self should: [game putOAt: 2@2] raise: Error description: TerniLapilli invalidMoveMessage.
	
	! !

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:43:11'!
ERROR!
!TerniLapilli class methodsFor: 'error' stamp: 'FC 10/29/2020 17:43:20'!
invalidMoveMessage
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error' stamp: 'FC 10/29/2020 17:43:27' prior: 50901961!
invalidMoveMessage
	^'Movete bien gato'.! !

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:43:30'!
PASSED!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:43:30'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:43:30'!
PASSED!

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:43:30'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:43:44' prior: 50901951!
test03
	| game |
	game := TerniLapilli new.
	
	self should: [game putOAt: 2@2] raise: Error description: TerniLapilli invalidMoveMessage.
	
	! !

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:43:44'!
PASSED!

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:43:44'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:43:44'!
PASSED!

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:43:44'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:44:17' prior: 50901981!
test03
	| game |
	game := TerniLapilli new.
	
	self should: [game putOAt: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	
! !

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:44:18'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 17:45:11'!
putOAt: aPoint 
	

	self error: self class invalidMoveMessage.! !

!testRun: #TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:45:13'!
PASSED!

!testRun: #TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:45:13'!
PASSED!

!testRun: #TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:45:13'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:45:59'!
test01PlayerXShouldStart
	| game |
	game := TerniLapilli new.
	
	self assert: game isPlayingX.
	! !

!methodRemoval: TerniLapilliTest #test01 stamp: 'FC 10/29/2020 17:45:59'!
test01
	| game |
	game := TerniLapilli new.
	
	self assert: game isPlayingX.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:46:22'!
test02PlayerXShouldEndTurnAfterPlaying
	| game |
	game := TerniLapilli new.
	
	game putXAt: 2@2.
	
	self assert: game isPlayingO.
	self deny: game isPlayingX.! !

!methodRemoval: TerniLapilliTest #test02 stamp: 'FC 10/29/2020 17:46:22'!
test02
	| game |
	game := TerniLapilli new.
	
	game putXAt: 2@2.
	
	self assert: game isPlayingO.
	self deny: game isPlayingX.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 17:46:42'!
test03PlayerOShouldNotBeAbleToPlayAtGameStart
	| game |
	game := TerniLapilli new.
	
	self should: [game putOAt: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	
! !

!methodRemoval: TerniLapilliTest #test03 stamp: 'FC 10/29/2020 17:46:42'!
test03
	| game |
	game := TerniLapilli new.
	
	self should: [game putOAt: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	
!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 17:50:36'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 17:50:36'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 17:50:36'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 17:50:37'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 17:50:37'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 17:50:37'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 17:50:46'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 17:50:46'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 17:50:46'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 17:50:47'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 17:50:47'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 17:50:48'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:13:29'!
test04PlayerXShouldGoAfterO
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	
	self assert: game isPlayingX.! !

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:13:36'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:14:34' prior: 50902009!
putOAt: aPoint 
	
	self isPlayingO ifTrue: [
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:14:36'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:14:36'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:14:36'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:14:36'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:15:23'!
test04PlayerXShouldNotBeAbleToPlayWhenIsOsTurn
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putXAt: 2@2.
	
	self assert: game isPlayingX.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:15:37' prior: 50902135!
test04PlayerXShouldNotBeAbleToPlayWhenIsOsTurn
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putXAt: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!testRun: #TerniLapilliTest #test04PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:15:38'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:16:04' prior: 50901912!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:16:06'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:16:06'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:16:06'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:16:06'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:16:06'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:16:29'!
test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putXAt: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test04PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:16:29'!
test04PlayerXShouldNotBeAbleToPlayWhenIsOsTurn
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putXAt: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:20:01'!
test06
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self assert: (game isXAt: 1@1).
	! !

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:20:03'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:20:20'!
isXAt: aPoint 
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:20:31' prior: 50902210!
isXAt: aPoint 
	^true.! !

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:20:33'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:20:34'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:20:34'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:20:34'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:20:34'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:20:34'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:20:34'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:20:34'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:22:02'!
test07
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1
	
	self assert: (game isOAt: 2@1).
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:22:10' prior: 50902262!
test07
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	
	self assert: (game isOAt: 2@1).
	! !

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:22:11'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:22:18'!
isOAt: aPoint 
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:22:23' prior: 50902278!
isOAt: aPoint 
	^true.! !

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:22:26'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:22:26'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:22:57'!
test08
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1..
	
	self deny: (game isXAt: 2@1).
	! !

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:22:58'!
FAILURE!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:24:22'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:24:22'!
FAILURE!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:24:22'!
FAILURE!

Object subclass: #TerniLapilli
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/29/2020 18:25:52'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

x _ Set new.			!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!

x add: 1.!
!TerniLapilli methodsFor: 'initialization' stamp: 'FC 10/29/2020 18:27:55' prior: 50901916 overrides: 16896425!
initialize 
	currentTurn := #X.
	xTokens := OrderedCollection new.
	oTokens := OrderedCollection new.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:28:25' prior: 50902157!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:28:55' prior: 50902215!
isXAt: aPoint 
	^xTokens includes: aPoint.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:28:58'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:28:58'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:29:04' prior: 50902311!
test08
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: (game isXAt: 2@1).
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:30:03'!
test09
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	
	self deny: (game isOAt: 1@1).
	! !

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:30:04'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:30:33' prior: 50902115!
putOAt: aPoint 
	
	self isPlayingO ifTrue: [
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:30:42' prior: 50902283!
isOAt: aPoint 
	^oTokens includes: aPoint.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:30:44'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:30:44'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:32:13'!
test10
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putOAt: 1@1.] raise: Error withMessageError: TerniLapilli invalidMoveMessage. 
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:32:25' prior: 50902466!
test10
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putOAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	! !

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:32:26'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:33:11' prior: 50902375!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		self cellIsOccupied: aPoint ifTrue: [ 		self error: self class invalidMoveMessage. ]
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:33:13'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:33:13'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:33:13'!
ERROR!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:33:13'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:33:18' prior: 50902486!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		self cellIsOccupied: aPoint ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:33:18'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:33:18'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:33:18'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:33:26'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:33:26'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:33:26'!
ERROR!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:33:26'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:33:41' prior: 50902525!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:34:37'!
cellIsOccupied: aPoint
	^(self isXAt: aPoint) or: [self isOAt: aPoint ]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:34:38'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:34:38'!
FAILURE!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:34:38'!
FAILURE!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:34:48'!
FAILURE!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:34:48'!
FAILURE!

	game putXAt: 1@1.!

	game putXAt: 1@1.!

game putOAt: 1@1.!

game putOAt: 1@1.!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:35:46' prior: 50902593!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:35:55' prior: 50902427!
putOAt: aPoint 
	
	self isPlayingO ifTrue: [
	(	self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:35:55'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:35:55'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:35:55'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:35:55'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:35:55'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:35:55'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:35:56'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:35:56'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:35:56'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:35:56'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:36:03' prior: 50902659!
putOAt: aPoint 
	self isPlayingO ifTrue: [
	(	self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:36:13' prior: 50902699!
putOAt: aPoint 
	self isPlayingO ifTrue: [
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:40:30'!
test11
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	self should: [game putXAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	! !

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:40:31'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:43:52'!
test12
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: game isOver.
	! !

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:43:53'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:44:02'!
isOver
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:44:07' prior: 50902772!
isOver
	^false.! !

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:44:10'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:44:54'!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	
	self deny: game isOver.
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:45:13' prior: 50902816!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:45:16'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:45:51' prior: 50902776!
isOver
	^self hasPlayerXWon.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:46:39'!
hasPlayerXWon
	^self xTokens size = 3.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:46:41'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:46:41'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:46:41'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:46:41'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:46:41'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:46:41'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:46:42'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:46:42'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:46:42'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:46:42'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:46:42'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:46:42'!
ERROR!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:46:42'!
ERROR!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:46:50'!
ERROR!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:46:50'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:47:01' prior: 50902841!
hasPlayerXWon
	^xTokens size = 3.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:47:03'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:47:07'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:47:08'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:47:08'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:47:08'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:47:08'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:47:08'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:47:08'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:48:20' prior: 50902825!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:48:26' prior: 50902965!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.! !

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:48:28'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:48:40'!
hasPlayerOWon
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:49:04' prior: 50902988!
hasPlayerOWon
	^ oTokens size = 3.! !

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:49:05'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:49:05'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:49:05'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:49:05'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:49:06'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:49:08'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:49:09'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:49:09'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:49:42' prior: 50902976!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:49:43'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:50:12' prior: 50902887!
hasPlayerXWon
	^self hasXWinningRow.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:55:25'!
hasXWinningRow

	^(1 to: 3) do: [ :rowNumber | (self isXAt: rowNumber@1) and: [ (self isXAt: rowNumber@2) and: [ self isXAt: rowNumber@3 ] ] ].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:55:35' prior: 50903093!
hasXWinningRow

	^(1 to: 3) anySatisfy: [ :rowNumber | (self isXAt: rowNumber@1) and: [ (self isXAt: rowNumber@2) and: [ self isXAt: rowNumber@3 ] ] ].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:55:36'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:55:36'!
FAILURE!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:55:36'!
FAILURE!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:56:26'!
FAILURE!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:56:26'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:56:53'!
test14
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:48:26' prior: 50903075!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.! !

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:57:06'!
FAILURE!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:57:06'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:48:26' prior: 50903165!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 18:45:13' prior: 50903181!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:58:10'!
PASSED!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:58:10'!
FAILURE!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:58:10'!
FAILURE!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:58:15'!
PASSED!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:58:22'!
FAILURE!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:58:22'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:58:48' prior: 50902837!
isOver
	^self hasPlayerXWon or: [self hasPlayerOWon].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:58:49'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:59:27'!
hasOWinningRow

	^(1 to: 3) anySatisfy: [ :rowNumber | (self isOAt: rowNumber@1) and: [ (self isOAt: rowNumber@2) and: [ self isOAt: rowNumber@3 ] ] ].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:59:29'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:59:50' prior: 50902993!
hasPlayerOWon
	^ self hasOWinningRow .! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 18:59:51' prior: 50903343!
hasPlayerOWon
	^ self hasOWinningRow.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test06 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test07 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test10 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test11 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test12 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test13 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!

!testRun: #TerniLapilliTest #test14 stamp: 'FC 10/29/2020 18:59:52'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:37:44'!
test06TokenShouldBePlacedOnBoard
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self assert: (game isXAt: 1@1).
	! !

!methodRemoval: TerniLapilliTest #test06 stamp: 'FC 10/29/2020 19:37:44'!
test06
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self assert: (game isXAt: 1@1).
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:37:54'!
test06XTokenShouldBePlacedOnBoard
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self assert: (game isXAt: 1@1).
	! !

!methodRemoval: TerniLapilliTest #test06TokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:37:54'!
test06TokenShouldBePlacedOnBoard
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self assert: (game isXAt: 1@1).
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:38:07'!
test07OTokenShouldBePlacedOnBoard
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	
	self assert: (game isOAt: 2@1).
	! !

!methodRemoval: TerniLapilliTest #test07 stamp: 'FC 10/29/2020 19:38:07'!
test07
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	
	self assert: (game isOAt: 2@1).
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:40:10'!
test10OPlayerShouldNotBeAbleToPlaceOnOccupiedCell
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putOAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	! !

!methodRemoval: TerniLapilliTest #test10 stamp: 'FC 10/29/2020 19:40:10'!
test10
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putOAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:40:25'!
test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putOAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	! !

!methodRemoval: TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlaceOnOccupiedCell stamp: 'FC 10/29/2020 19:40:25'!
test10OPlayerShouldNotBeAbleToPlaceOnOccupiedCell
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	self should: [game putOAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:41:02'!
test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	self should: [game putXAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	! !

!methodRemoval: TerniLapilliTest #test11 stamp: 'FC 10/29/2020 19:41:02'!
test11
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	self should: [game putXAt: 1@1.] raise: Error withMessageText: TerniLapilli invalidMoveMessage. 
	!

----SNAPSHOT----(29 October 2020 19:41:08) CuisUniversity-4383.image priorSource: 18244304!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:41:43'!
test12GameShouldNotBeOverAtStart
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: game isOver.
	! !

!methodRemoval: TerniLapilliTest #test12 stamp: 'FC 10/29/2020 19:41:43'!
test12
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: game isOver.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:42:07'!
test13XPlayerShouldWinWhenCompletingARow
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test13 stamp: 'FC 10/29/2020 19:42:07'!
test13
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 19:42:27'!
test14OPlayerShouldWinWhenCompletingARow
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test14 stamp: 'FC 10/29/2020 19:42:27'!
test14
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 1@2.
	game putXAt: 3@3.
	game putOAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test12GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test13XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:30'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 19:42:33'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 19:42:33'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test12GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test13XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:34'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:35'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test12GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test13XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:36'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test12GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test13XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 19:42:37'!
PASSED!

----SNAPSHOT----(29 October 2020 19:43:04) CuisUniversity-4383.image priorSource: 18298728!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:17:21'!
test13GameShouldNotBeOverAtStart
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: game isOver.
	! !

!methodRemoval: TerniLapilliTest #test12GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:17:21'!
test12GameShouldNotBeOverAtStart
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: game isOver.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:17:28'!
test14XPlayerShouldWinWhenCompletingARow
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test13XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:17:28'!
test13XPlayerShouldWinWhenCompletingARow
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:17:33'!
test15XPlayerShouldWinWhenCompletingARow
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test14XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:17:33'!
test14XPlayerShouldWinWhenCompletingARow
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 1@2.
	game putOAt: 3@3.
	game putXAt: 1@3.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:18:39'!
test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell
	| game |
	game := TerniLapilli new.
	
	self should: [game putXAt: 4@1.] raise: Error withMessageText: TerniLapilli outOfBoundsMoveMessage. 
	! !
!TerniLapilli class methodsFor: 'error' stamp: 'FC 10/29/2020 20:19:00'!
outOfBoundsMoveMessage
	^'Movete bien gato'.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:19:42' prior: 50902710!
putOAt: aPoint 
	self isPlayingO ifTrue: [
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:20:38'!
isValidPosition: aPoint 
	^ (aPoint x between: 1 and: 3) and: [ aPoint y between: 1 and: 3 ]. ! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:20:49' prior: 50902648!
putXAt: aPoint 
	self isPlayingX ifTrue: [
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:20:50'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:20:50'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:23:08'!
test16
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	game putXAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:23:11'!
FAILURE!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:23:11'!
FAILURE!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:23:43'!
FAILURE!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:23:43'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:24:09' prior: 50903089!
hasPlayerXWon
	^self hasXWinningRow or: [self hasXWinningColumn].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:24:30'!
hasXWinningColumn

	^(1 to: 3) anySatisfy: [ :rowNumber | (self isXAt: rowNumber@1) and: [ (self isXAt: rowNumber@2) and: [ self isXAt: rowNumber@3 ] ] ].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:24:38' prior: 50903920!
hasXWinningColumn

	^(1 to: 3) anySatisfy: [ :colNumber | (self isXAt: colNumber@1) and: [ (self isXAt: colNumber@2) and: [ self isXAt: colNumber@3 ] ] ].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:24:54' prior: 50903928!
hasXWinningColumn

	^(1 to: 3) anySatisfy: [ :colNumber | (self isXAt: 1@colNumber) and: [ (self isXAt: 2@colNumber) and: [ self isXAt: 3@colNumber ] ] ].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:24:57'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:24:57'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:26:11' prior: 50903896!
test16
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:26:36' prior: 50903997!
test16
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:26:44'!
test17
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:23:08' prior: 50904008!
test16
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	game putXAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:26:54'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:26:55'!
FAILURE!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:26:55'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:27:47'!
hasOWinningColumn

	^(1 to: 3) anySatisfy: [ :colNumber | (self isOAt: 1@colNumber) and: [ (self isOAt: 2@colNumber) and: [ self isOAt: 3@colNumber ] ] ].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:28:02' prior: 50903347!
hasPlayerOWon
	^ self hasOWinningRow or: [self hasOWinningColumn ].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:28:04'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:28:04'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:28:44'!
test18
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@2.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:28:49' prior: 50904115!
test18
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@2.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerXWon.
	self deny:   game hasPlayerOWon.! !

!testRun: #TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:28:52'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:30:53'!
hasXWinningDiagonal

	^(1 to: 3) allSatisfy: [ :n | self isXAt: n@n  ].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:31:21' prior: 50903915!
hasPlayerXWon
	^self hasXWinningRow or: [self hasXWinningColumn or: [ self hasXWinningDiagonal ]].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:31:26'!
PASSED!

!testRun: #TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:31:26'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:33:18' prior: 50904139!
hasXWinningDiagonal

	^(1 to: 3) allSatisfy: [ :n | self isXAt: n@n  ] or: [ 
		(self isXAt: 1@3) and: [(self isXAt: 2@2) and: [self isXAt: 3@1] ].
		].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:34:45' prior: 50904208!
hasXWinningDiagonal

	^(1 to: 3) allSatisfy: [ :n | self isXAt: n@n  ] or: [ 
		(1 to: 3) allSatisfy:  [ :n | self isXAt: n@(4-n)]
		].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:34:47'!
ERROR!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:34:47'!
ERROR!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:34:47'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:34:47'!
ERROR!

!testRun: #TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:34:47'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:35:03' prior: 50904216!
hasXWinningDiagonal

	^((1 to: 3) allSatisfy: [ :n | self isXAt: n@n  ]) or: [ 
		(1 to: 3) allSatisfy:  [ :n | self isXAt: n@(4-n)]
		].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:35:03'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:35:04'!
PASSED!

!testRun: #TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:35:04'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:35:23'!
hasOWinningDiagonal

	^((1 to: 3) allSatisfy: [ :n | self isOAt: n@n  ]) or: [ 
		(1 to: 3) allSatisfy:  [ :n | self isOAt: n@(4-n)]
		].! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:36:02' prior: 50904055!
hasPlayerOWon
	^ self hasOWinningRow or: [self hasOWinningColumn  or: [ self hasOWinningDiagonal ]].! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:36:05'!
PASSED!

!testRun: #TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:36:05'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:36:48'!
test19
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerXWon.
	self deny:   game hasPlayerOWon.! !

!testRun: #TerniLapilliTest #test19 stamp: 'FC 10/29/2020 20:36:49'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:37:00' prior: 50904417!
test19
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !

!testRun: #TerniLapilliTest #test19 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!

!testRun: #TerniLapilliTest #test19 stamp: 'FC 10/29/2020 20:37:01'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:37:33'!
test16XPlayerShouldWinWhenCompletingAColumn
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	game putXAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test16 stamp: 'FC 10/29/2020 20:37:33'!
test16
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	game putXAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerXWon.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:37:47'!
test17OPlayerShouldWinWhenCompletingAColumn
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test17 stamp: 'FC 10/29/2020 20:37:47'!
test17
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:38:05'!
test18XPlayerShouldWinWhenCompletingADiagonal
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@2.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerXWon.
	self deny:   game hasPlayerOWon.! !

!methodRemoval: TerniLapilliTest #test18 stamp: 'FC 10/29/2020 20:38:05'!
test18
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@2.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerXWon.
	self deny:   game hasPlayerOWon.!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:38:13'!
test19OPlayerShouldWinWhenCompletingADiagonal
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.! !

!methodRemoval: TerniLapilliTest #test19 stamp: 'FC 10/29/2020 20:38:13'!
test19
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.

	
	self assert: game isOver.
	self assert: game hasPlayerOWon.
	self deny:   game hasPlayerXWon.!

!methodRemoval: TerniLapilliTest #test08 stamp: 'FC 10/29/2020 20:38:44'!
test08
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	
	self deny: (game isXAt: 2@1).
	!

!methodRemoval: TerniLapilliTest #test09 stamp: 'FC 10/29/2020 20:38:46'!
test09
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 2@1.
	
	self deny: (game isOAt: 1@1).
	!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:38:48'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:39:01'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:42:07'!
test20
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	
	self should: [game putXAt:  2@3] raise: Error withMessageText: TerniLapilli gameOverMessage .
	! !
!TerniLapilli class methodsFor: 'error' stamp: 'FC 10/29/2020 20:42:29'!
gameOverMessage
	^'Game is over'.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:43:12' prior: 50903832!
putXAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifTrue: [
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:43:17' prior: 50903813!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifTrue: [
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/29/2020 20:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test20 stamp: 'FC 10/29/2020 20:43:42'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:45:32'!
test20XPlayerShouldNotBeAbleToPlayOnGameOver
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	
	self should: [game putXAt:  2@3] raise: Error withMessageText: TerniLapilli gameOverMessage .
	! !

!methodRemoval: TerniLapilliTest #test20 stamp: 'FC 10/29/2020 20:45:32'!
test20
	| game |
	game := TerniLapilli new.
	
	game putXAt: 3@1.
	game putOAt: 1@1.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 2@1.
	game putOAt: 3@3.
	
	self should: [game putXAt:  2@3] raise: Error withMessageText: TerniLapilli gameOverMessage .
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:48:07'!
test21
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game putXAt:  1@1] raise: Error withMessageText: TerniLapilli tokenLimitExceededMessage .
	
	self deny: game isOver.
	! !

!testRun: #TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:48:12'!
ERROR!

!testRun: #TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:48:15'!
ERROR!
!TerniLapilli class methodsFor: 'error' stamp: 'FC 10/29/2020 20:48:22'!
tokenLimitExceededMessage
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error' stamp: 'FC 10/29/2020 20:48:38' prior: 50904760!
tokenLimitExceededMessage
	^'Ya hay 3 piezas'! !

!testRun: #TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:48:41'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:50:05' prior: 50904626!
putXAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifTrue: [
		xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/29/2020 20:51:09' prior: 50904642!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifTrue: [
		oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self cellIsOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!testRun: #TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:51:13'!
PASSED!

!testRun: #TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/29/2020 20:51:15'!
PASSED!

!testRun: #TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:51:15'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:51:34'!
test21XPlayerShouldNotHaveMoreThanThreeTokens
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game putXAt:  1@1] raise: Error withMessageText: TerniLapilli tokenLimitExceededMessage .
	
	self deny: game isOver.
	! !

!methodRemoval: TerniLapilliTest #test21 stamp: 'FC 10/29/2020 20:51:34'!
test21
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game putXAt:  1@1] raise: Error withMessageText: TerniLapilli tokenLimitExceededMessage .
	
	self deny: game isOver.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:53:42'!
test22
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert isXAt: 1@1.
	! !

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/29/2020 20:53:44'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:53:50'!
moveXFrom: aPoint to: aPoint2 
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:54:30' prior: 50904916!
moveXFrom: aPoint to: aPoint2 
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/29/2020 20:54:32'!
ERROR!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/29/2020 20:54:36'!
ERROR!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:54:41' prior: 50904904!
test22
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert: game isXAt: 1@1.
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/29/2020 20:54:47' prior: 50904932!
test22
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert: (game isXAt: 1@1).
	! !

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/29/2020 20:54:48'!
PASSED!

----SNAPSHOT----(29 October 2020 22:43:13) CuisUniversity-4383.image priorSource: 18306786!

----SNAPSHOT----(29 October 2020 22:43:24) CuisUniversity-4383.image priorSource: 18347965!

----STARTUP---- (31 October 2020 16:32:14) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!

!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:34:45'!
test23
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:34:47'!
FAILURE!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:34:58'!
FAILURE!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:35:05'!
FAILURE!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:36:13' prior: 50904921!
moveXFrom: aPoint to: aPoint2 

	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:36:14'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:36:14'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:36:39'!
test24
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:36:42'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:37:33'!
isOccupied: aPoint
	^(self isXAt: aPoint) or: [self isOAt: aPoint ]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:37:34' prior: 50904772!
putXAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifTrue: [
		xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:37:34' prior: 50904790!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifTrue: [
		oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!methodRemoval: TerniLapilli #cellIsOccupied: stamp: 'FC 10/31/2020 16:37:34'!
cellIsOccupied: aPoint
	^(self isXAt: aPoint) or: [self isOAt: aPoint ]!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:37:36'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:37:36'!
FAILURE!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:37:36'!
FAILURE!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:38:05' prior: 50905055!
moveXFrom: aPoint to: aPoint2 
	(self isOccupied: aPoint2) ifTrue: [self error self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:38:08' prior: 50905273!
moveXFrom: aPoint to: aPoint2 
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:38:08'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:38:09'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:38:09'!
PASSED!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:39:48' prior: 50905284!
moveXFrom: aPoint to: aPoint2 
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	currentTurn := #O.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:39:51' prior: 50905369!
moveXFrom: aPoint to: aPoint2 
	
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	currentTurn := #O.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:41:28'!
test25
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
! !

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:41:29'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:41:30'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:41:30'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:41:30'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:41:30'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 16:41:30'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:41:56' prior: 50905393!
test25
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
! !

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 16:41:57'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:42:54' prior: 50905155!
putXAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifFalse: [
		self error: self class invalidMoveMessage.
	].
	
	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	currentTurn  := #O.
! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:43:18' prior: 50905173!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifFalse: [
		self error: self class invalidMoveMessage.
	]
	
	oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	oTokens add: aPoint.
	currentTurn  := #X.
! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:43:39' prior: 50905381!
moveXFrom: aPoint to: aPoint2 
	
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	
	self isPlayingX ifFalse: [
		self error: self class invalidMoveMessage.
	].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	currentTurn := #O.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:43:39'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:43:39'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:43:39'!
FAILURE!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:43:39'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:43:39'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:43:39'!
FAILURE!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:43:39'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:43:39'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:43:39'!
ERROR!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:43:40'!
ERROR!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:43:40'!
ERROR!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:43:40'!
ERROR!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:43:40'!
ERROR!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 16:43:40'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:43:47'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:43:47'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:43:47'!
FAILURE!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:43:47'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:43:47'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:43:47'!
FAILURE!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:43:47'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:43:47'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:43:47'!
ERROR!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 16:43:47'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:43:54' prior: 50905518!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifFalse: [
		self error: self class invalidMoveMessage.
	].
	
	oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	oTokens add: aPoint.
	currentTurn  := #X.
! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 16:43:55'!
PASSED!

Object subclass: #TerniLapilliState
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliState category: 'TerniLapilli' stamp: 'FC 10/31/2020 16:45:41'!
Object subclass: #TerniLapilliState
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliState subclass: #XTurnState
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliState subclass: #XTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XTurnState category: 'TerniLapilli' stamp: 'FC 10/31/2020 16:46:08'!
TerniLapilliState subclass: #XTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliState subclass: #OTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OTurnState category: 'TerniLapilli' stamp: 'FC 10/31/2020 16:46:12'!
TerniLapilliState subclass: #OTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

Object subclass: #TerniLapilliState
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliState category: 'TerniLapilli' stamp: 'FC 10/31/2020 16:46:20'!
Object subclass: #TerniLapilliState
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliState class methodsFor: 'nil' stamp: 'FC 10/31/2020 16:46:50'!
for: aTerniLapilli
	self initializeFor: aTerniLapilli! !
!TerniLapilliState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:47:27'!
initializeFor: aTerniLapilli
	game := aTerniLapilli.! !

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/31/2020 16:48:20'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'currentTurn xTokens oTokens state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:48:12' prior: 50905500!
putXAt: aPoint 
	state putXAt: aPoint.
"
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifFalse: [
		self error: self class invalidMoveMessage.
	].
	
	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	currentTurn  := #O.
"! !
!TerniLapilli methodsFor: 'initialization' stamp: 'FC 10/31/2020 16:48:54' prior: 50902369 overrides: 16896425!
initialize 
	currentTurn := #X.
	xTokens := OrderedCollection new.
	oTokens := OrderedCollection new.
	state := XTurnState for: self.! !
!OTurnState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:49:33'!
putXAt: aPoint
	self error: TerniLapilli invalidMoveMessage.! !
!XTurnState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:49:45'!
putXAt: aPoint
	! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:51:06' prior: 50905898!
putXAt: aPoint
	game putXAtWhenValid: aPoint.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:51:48'!
putXAtWhenValid: aPoint 

	self isOver ifTrue: [ self error: self class gameOverMessage ].

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	state := OTurnState for: self.! !

TerniLapilliState subclass: #GameOverState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #GameOverState category: 'TerniLapilli' stamp: 'FC 10/31/2020 16:52:36'!
TerniLapilliState subclass: #GameOverState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:57:56' prior: 50905906!
putXAtWhenValid: aPoint 
	"
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	"
	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:58:18' prior: 50905934!
putXAtWhenValid: aPoint 

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!GameOverState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:58:34'!
putXAt: aPoint
	self error: self class gameOverMessage
	! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:58:38'!
putOAt: aPoint
	self error: self class gameOverMessage
	! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:58:58'!
isOver
	 ^true.
	! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:59:17'!
isOver
	^false.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:59:22'!
isOver
	^false.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:59:39'!
putOAt: aPoint
	self error: TerniLapilli invalidMoveMessage.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:00:04'!
putOAt: aPoint
	game putOAtWhenValid: aPoint.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:00:45'!
putOAtWhenValid: aPoint 

	oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	oTokens add: aPoint.
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:01:10' prior: 50905702!
putOAt: aPoint 
	state putOAt: aPoint.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:01:14'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:01:20'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:01:20'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:01:53'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:01:53'!
ERROR!
!TerniLapilliState class methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:02:09' prior: 50905849!
for: aTerniLapilli
	self new initializeFor: aTerniLapilli! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:02:11'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:02:11'!
FAILURE!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:02:11'!
FAILURE!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:02:11'!
ERROR!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:02:12'!
ERROR!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:02:20'!
ERROR!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:02:20'!
ERROR!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:02:32'!
ERROR!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:02:32'!
ERROR!
!TerniLapilliState class methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:01' prior: 50906109!
for: aTerniLapilli
	^self new initializeFor: aTerniLapilli! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:03:04'!
FAILURE!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:03:04'!
FAILURE!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:03:04'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:03:04'!
PASSED!
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:36'!
isPlayingO
	^true.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:41'!
isPlayingX
	^false.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:53'!
isPlayingX
	^true.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:57'!
isPlayingO
	^false.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:04:36' prior: 50901924!
isPlayingX
	^state isPlayingX.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:04:44' prior: 50901920!
isPlayingO
	^state isPlayingO.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:04:47'!
FAILURE!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:04:47'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:04:47'!
FAILURE!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:05:16'!
FAILURE!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:05:16'!
FAILURE!
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:05:41' prior: 50905969!
putXAt: aPoint
	self error: TerniLapilli gameOverMessage
	! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:05:52' prior: 50905974!
putOAt: aPoint
	self error: TerniLapilli gameOverMessage
	! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:05:56'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:05:56'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:05:56'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:05:57'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:05:57'!
FAILURE!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:05:57'!
FAILURE!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:06:02'!
FAILURE!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:06:02'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:07:40'!
validateMove: aPoint

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:07:40' prior: 50905953!
putXAtWhenValid: aPoint 

	self validateMove: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:07:59' prior: 50906502!
putXAtWhenValid: aPoint 

	self validateMove: aPoint for: xTokens.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:08:17'!
validateMove: aPoint for: tokens

	tokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint! !

!methodRemoval: TerniLapilli #validateMove: stamp: 'FC 10/31/2020 17:08:18'!
validateMove: aPoint

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:08:43' prior: 50906000!
putOAtWhenValid: aPoint 

	self validateMove: aPoint for: oTokens. 
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XTurnState for: self.		]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:08:48'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:08:48'!
FAILURE!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:08:48'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:09:02' prior: 50905485!
test25
	| game |
	"
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	"! !

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:09:05'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:09:05'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:10:57' prior: 50905867!
putXAt: aPoint 
	state putXAt: aPoint.
! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:11:38' prior: 50903253!
isOver
	^state isOver.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:11:40'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:11:40'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:16:39' prior: 50906634!
test25
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:17:36'!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:18:00' prior: 50905536!
moveXFrom: aPoint to: aPoint2 
	
	state moveXFrom: aPoint to: aPoint2.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:01'!
moveXWhenValidFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:15'!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:15' prior: 50906842!
moveXWhenValidFrom: aPoint to: aPoint2 
	game moveXFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:15' prior: 50906848!
moveXFrom: aPoint to: aPoint2 
	game moveXFrom: aPoint  to: aPoint2. ! !

!methodRemoval: XTurnState #moveXWhenValidFrom:to: stamp: 'FC 10/31/2020 17:19:15'!
moveXWhenValidFrom: aPoint to: aPoint2 
	game moveXFrom: aPoint  to: aPoint2. !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:25' prior: 50906860!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:44'!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:20:00'!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:20:06'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:20:06'!
PASSED!
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:20:48'!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli gameOverMessage.! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:20:52'!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli gameOverMessage.! !

Object subclass: #TerniLapilli
	instanceVariableNames: 'xTokens oTokens state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/31/2020 17:21:09'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'xTokens oTokens state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:21:11'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:21:12'!
PASSED!

!testRun: #TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:21:12'!
PASSED!

!testRun: #TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:21:12'!
PASSED!

!testRun: #TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:21:12'!
PASSED!

!testRun: #TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:21:12'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:21:52'!
test22XPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert: (game isXAt: 1@1).
	! !

!methodRemoval: TerniLapilliTest #test22 stamp: 'FC 10/31/2020 17:21:53'!
test22
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert: (game isXAt: 1@1).
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:22:35'!
test23XPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!methodRemoval: TerniLapilliTest #test23 stamp: 'FC 10/31/2020 17:22:35'!
test23
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:22:59'!
test24XPlayerShouldNotOverlapTokens
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!methodRemoval: TerniLapilliTest #test24 stamp: 'FC 10/31/2020 17:22:59'!
test24
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:23:17'!
test25XPlayerShouldNotMoveWhenNotItsTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test25 stamp: 'FC 10/31/2020 17:23:17'!
test25
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:23:45'!
test25XPlayerShouldNotMoveWhenIsOTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test25XPlayerShouldNotMoveWhenNotItsTurn stamp: 'FC 10/31/2020 17:23:45'!
test25XPlayerShouldNotMoveWhenNotItsTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:26:40'!
test26
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

1@1 dist: 2@1.!

1@1 dist: 2@2.!

1@1 dist: 1@2.!

1@1 dist: 3@2.!

2@1 dist: 2@2.!

2@1 dist: 2@3.!

2@1 dist: 2@3.!

1@1 dist: 2@2!

1@1 dist: 2@2.!

2@2 dist: 1@1.!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:30:51' prior: 50906824!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(aPoint dist: aPoint2 = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:30:55'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:30:55'!
ERROR!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:30:55'!
FAILURE!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:30:55'!
FAILURE!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:30:55'!
ERROR!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:30:55'!
FAILURE!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:31:18' prior: 50907206!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(aPoint dist: aPoint2 = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]] ifFalse:[ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:31:29' prior: 50907303!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	((aPoint dist: aPoint2 = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:31:30'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:31:31'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:31:31'!
ERROR!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:31:31'!
FAILURE!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:31:31'!
FAILURE!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:31:31'!
ERROR!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:31:31'!
FAILURE!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:31:59'!
ERROR!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:31:59'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:32:28' prior: 50907319!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:32:29'!
FAILURE!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:32:29'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:32:29'!
FAILURE!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:32:44'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:32:47'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:32:48'!
FAILURE!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:32:48'!
FAILURE!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:33:01'!
FAILURE!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:33:43'!
FAILURE!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:33:43'!
FAILURE!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:34:03' prior: 50907425!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = 2@2) or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:34:03'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:34:04'!
FAILURE!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:34:04'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:34:04'!
FAILURE!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:34:51'!
FAILURE!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:34:51'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:35:15' prior: 50907087!
test23XPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	self halt.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:36:02'!
FAILURE!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:36:25' prior: 50907548!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:36:31' prior: 50907671!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:36:32'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:36:32'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:36:44' prior: 50907654!
test23XPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:36:44'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:36:45'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:36:45'!
PASSED!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:37:22'!
validatePlacement: aPoint for: tokens

	tokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:37:22' prior: 50906545!
putOAtWhenValid: aPoint 

	self validatePlacement: aPoint for: oTokens. 
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XTurnState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:37:22' prior: 50906511!
putXAtWhenValid: aPoint 

	self validatePlacement: aPoint for: xTokens.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !

!methodRemoval: TerniLapilli #validateMove:for: stamp: 'FC 10/31/2020 17:37:22'!
validateMove: aPoint for: tokens

	tokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:37:44' prior: 50907688!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:38:36'!
validateMoveFrom: aPoint2 to: aPoint

	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:38:36' prior: 50907927!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint2 to: aPoint.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:39:40' prior: 50907943!
validateMoveFrom: aPoint to: aPoint2

	(((aPoint2 dist: aPoint) = 1) or: [aPoint2 = (2@2) or: [aPoint = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint) ifTrue: [self error: self class invalidMoveMessage ]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:39:41'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:39:42'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:39:42'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:39:42'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:39:42'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:39:42'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:39:43'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:39:43'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:40:35'!
test27
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	
	self should: [game moveXFrom: 1@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!testRun: #TerniLapilliTest #test27 stamp: 'FC 10/31/2020 17:40:36'!
FAILURE!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:42:04' prior: 50907954!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint2 to: aPoint.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 17:42:05'!
PASSED!

!testRun: #TerniLapilliTest #test27 stamp: 'FC 10/31/2020 17:42:06'!
PASSED!

!testRun: #TerniLapilliTest #test27 stamp: 'FC 10/31/2020 18:04:26'!
PASSED!

----STARTUP---- (31 October 2020 18:12:16) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!

!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:34:45'!
test23
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:36:13' prior: 50904921!
moveXFrom: aPoint to: aPoint2 

	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:36:39'!
test24
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:37:33'!
isOccupied: aPoint
	^(self isXAt: aPoint) or: [self isOAt: aPoint ]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:37:34' prior: 50904772!
putXAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifTrue: [
		xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		xTokens add: aPoint.
		currentTurn  := #O.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:37:34' prior: 50904790!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifTrue: [
		oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
		(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
		(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
		oTokens add: aPoint.
		currentTurn  := #X.
	] ifFalse: [
		self error: self class invalidMoveMessage.
	]! !

!methodRemoval: TerniLapilli #cellIsOccupied: stamp: 'FC 10/31/2020 18:12:18'!
cellIsOccupied: aPoint
	^(self isXAt: aPoint) or: [self isOAt: aPoint ]!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:38:05' prior: 50908271!
moveXFrom: aPoint to: aPoint2 
	(self isOccupied: aPoint2) ifTrue: [self error self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:38:08' prior: 50908337!
moveXFrom: aPoint to: aPoint2 
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens remove: aPoint. 
	xTokens add: aPoint2.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:39:48' prior: 50908348!
moveXFrom: aPoint to: aPoint2 
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	currentTurn := #O.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:39:51' prior: 50908359!
moveXFrom: aPoint to: aPoint2 
	
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	currentTurn := #O.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:41:28'!
test25
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:41:56' prior: 50908383!
test25
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:42:54' prior: 50908296!
putXAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifFalse: [
		self error: self class invalidMoveMessage.
	].
	
	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	currentTurn  := #O.
! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:43:18' prior: 50908314!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifFalse: [
		self error: self class invalidMoveMessage.
	]
	
	oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	oTokens add: aPoint.
	currentTurn  := #X.
! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:43:39' prior: 50908371!
moveXFrom: aPoint to: aPoint2 
	
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	
	self isPlayingX ifFalse: [
		self error: self class invalidMoveMessage.
	].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	currentTurn := #O.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:43:54' prior: 50908427!
putOAt: aPoint 
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingO ifFalse: [
		self error: self class invalidMoveMessage.
	].
	
	oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	oTokens add: aPoint.
	currentTurn  := #X.
! !

!classDefinition: #TerniLapilliState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:18'!
Object subclass: #TerniLapilliState
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:18'!
Object subclass: #TerniLapilliState
	instanceVariableNames: 'currentTurn xTokens oTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XTurnState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:18'!
TerniLapilliState subclass: #XTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XTurnState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:18'!
TerniLapilliState subclass: #XTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OTurnState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:18'!
TerniLapilliState subclass: #OTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OTurnState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:18'!
TerniLapilliState subclass: #OTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:19'!
Object subclass: #TerniLapilliState
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:19'!
Object subclass: #TerniLapilliState
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliState class methodsFor: 'nil' stamp: 'FC 10/31/2020 16:46:50'!
for: aTerniLapilli
	self initializeFor: aTerniLapilli! !
!TerniLapilliState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:47:27'!
initializeFor: aTerniLapilli
	game := aTerniLapilli.! !

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:19'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'currentTurn xTokens oTokens state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:48:12' prior: 50908409!
putXAt: aPoint 
	state putXAt: aPoint.
"
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	self isPlayingX ifFalse: [
		self error: self class invalidMoveMessage.
	].
	
	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	currentTurn  := #O.
"! !
!TerniLapilli methodsFor: 'initialization' stamp: 'FC 10/31/2020 16:48:54' prior: 50902369 overrides: 16896425!
initialize 
	currentTurn := #X.
	xTokens := OrderedCollection new.
	oTokens := OrderedCollection new.
	state := XTurnState for: self.! !
!OTurnState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:49:33'!
putXAt: aPoint
	self error: TerniLapilli invalidMoveMessage.! !
!XTurnState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:49:45'!
putXAt: aPoint
	! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:51:06' prior: 50908585!
putXAt: aPoint
	game putXAtWhenValid: aPoint.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:51:48'!
putXAtWhenValid: aPoint 

	self isOver ifTrue: [ self error: self class gameOverMessage ].

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	state := OTurnState for: self.! !

!classDefinition: #GameOverState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:19'!
TerniLapilliState subclass: #GameOverState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #GameOverState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:19'!
TerniLapilliState subclass: #GameOverState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:57:56' prior: 50908593!
putXAtWhenValid: aPoint 
	"
	self isOver ifTrue: [ self error: self class gameOverMessage ].
	"
	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 16:58:18' prior: 50908624!
putXAtWhenValid: aPoint 

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!GameOverState methodsFor: 'no messages' stamp: 'FC 10/31/2020 16:58:34'!
putXAt: aPoint
	self error: self class gameOverMessage
	! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:58:38'!
putOAt: aPoint
	self error: self class gameOverMessage
	! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:58:58'!
isOver
	 ^true.
	! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:59:17'!
isOver
	^false.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:59:22'!
isOver
	^false.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 16:59:39'!
putOAt: aPoint
	self error: TerniLapilli invalidMoveMessage.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:00:04'!
putOAt: aPoint
	game putOAtWhenValid: aPoint.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:00:45'!
putOAtWhenValid: aPoint 

	oTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	oTokens add: aPoint.
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:01:10' prior: 50908459!
putOAt: aPoint 
	state putOAt: aPoint.! !
!TerniLapilliState class methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:02:09' prior: 50908536!
for: aTerniLapilli
	self new initializeFor: aTerniLapilli! !
!TerniLapilliState class methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:01' prior: 50908711!
for: aTerniLapilli
	^self new initializeFor: aTerniLapilli! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:36'!
isPlayingO
	^true.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:41'!
isPlayingX
	^false.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:53'!
isPlayingX
	^true.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:03:57'!
isPlayingO
	^false.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:04:36' prior: 50901924!
isPlayingX
	^state isPlayingX.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:04:44' prior: 50901920!
isPlayingO
	^state isPlayingO.! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:05:41' prior: 50908659!
putXAt: aPoint
	self error: TerniLapilli gameOverMessage
	! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:05:52' prior: 50908664!
putOAt: aPoint
	self error: TerniLapilli gameOverMessage
	! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:07:40'!
validateMove: aPoint

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:07:40' prior: 50908643!
putXAtWhenValid: aPoint 

	self validateMove: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:07:59' prior: 50908770!
putXAtWhenValid: aPoint 

	self validateMove: aPoint for: xTokens.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:08:17'!
validateMove: aPoint for: tokens

	tokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint! !

!methodRemoval: TerniLapilli #validateMove: stamp: 'FC 10/31/2020 18:12:20'!
validateMove: aPoint

	xTokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	xTokens add: aPoint!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:08:43' prior: 50908690!
putOAtWhenValid: aPoint 

	self validateMove: aPoint for: oTokens. 
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XTurnState for: self.		]! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:09:02' prior: 50908396!
test25
	| game |
	"
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	"! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:10:57' prior: 50908554!
putXAt: aPoint 
	state putXAt: aPoint.
! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:11:38' prior: 50903253!
isOver
	^state isOver.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:16:39' prior: 50908823!
test25
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:17:36'!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:18:00' prior: 50908445!
moveXFrom: aPoint to: aPoint2 
	
	state moveXFrom: aPoint to: aPoint2.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:01'!
moveXWhenValidFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:15'!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:15' prior: 50908875!
moveXWhenValidFrom: aPoint to: aPoint2 
	game moveXFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:15' prior: 50908881!
moveXFrom: aPoint to: aPoint2 
	game moveXFrom: aPoint  to: aPoint2. ! !

!methodRemoval: XTurnState #moveXWhenValidFrom:to: stamp: 'FC 10/31/2020 18:12:20'!
moveXWhenValidFrom: aPoint to: aPoint2 
	game moveXFrom: aPoint  to: aPoint2. !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:25' prior: 50908893!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:19:44'!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:20:00'!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:20:48'!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli gameOverMessage.! !
!GameOverState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:20:52'!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli gameOverMessage.! !

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:20'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'xTokens oTokens state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilli category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:12:20'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'xTokens oTokens state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:21:52'!
test22XPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert: (game isXAt: 1@1).
	! !

!methodRemoval: TerniLapilliTest #test22 stamp: 'FC 10/31/2020 18:12:20'!
test22
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self assert: (game isXAt: 1@1).
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:22:35'!
test23XPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!methodRemoval: TerniLapilliTest #test23 stamp: 'FC 10/31/2020 18:12:20'!
test23
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:22:59'!
test24XPlayerShouldNotOverlapTokens
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!methodRemoval: TerniLapilliTest #test24 stamp: 'FC 10/31/2020 18:12:20'!
test24
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 2@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:23:17'!
test25XPlayerShouldNotMoveWhenNotItsTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test25 stamp: 'FC 10/31/2020 18:12:20'!
test25
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:23:45'!
test25XPlayerShouldNotMoveWhenIsOTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test25XPlayerShouldNotMoveWhenNotItsTurn stamp: 'FC 10/31/2020 18:12:20'!
test25XPlayerShouldNotMoveWhenNotItsTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [	game moveXFrom: 1@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:26:40'!
test26
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:30:51' prior: 50908857!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(aPoint dist: aPoint2 = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:31:18' prior: 50909082!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(aPoint dist: aPoint2 = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]] ifFalse:[ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:31:29' prior: 50909097!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	((aPoint dist: aPoint2 = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:32:28' prior: 50909113!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [aPoint = 2@2 or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:34:03' prior: 50909129!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = 2@2) or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:35:15' prior: 50908968!
test23XPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	self halt.
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:36:25' prior: 50909146!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = 2@2]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:36:31' prior: 50909177!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:36:44' prior: 50909163!
test23XPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 17:37:22'!
validatePlacement: aPoint for: tokens

	tokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:37:22' prior: 50908813!
putOAtWhenValid: aPoint 

	self validatePlacement: aPoint for: oTokens. 
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XTurnState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:37:22' prior: 50908779!
putXAtWhenValid: aPoint 

	self validatePlacement: aPoint for: xTokens.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !

!methodRemoval: TerniLapilli #validateMove:for: stamp: 'FC 10/31/2020 18:12:21'!
validateMove: aPoint for: tokens

	tokens size = 3 ifTrue: [self error: self class tokenLimitExceededMessage ].
	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:37:44' prior: 50909194!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ].
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:38:36'!
validateMoveFrom: aPoint2 to: aPoint

	(((aPoint dist: aPoint2) = 1) or: [(aPoint = (2@2)) or: [aPoint2 = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:38:36' prior: 50909268!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint2 to: aPoint.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:39:40' prior: 50909284!
validateMoveFrom: aPoint to: aPoint2

	(((aPoint2 dist: aPoint) = 1) or: [aPoint2 = (2@2) or: [aPoint = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint) ifTrue: [self error: self class invalidMoveMessage ]! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:40:35'!
test27
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	
	self should: [game moveXFrom: 1@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 17:42:04' prior: 50909295!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint2 to: aPoint.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:12:27'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:12:27'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:12:27'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:12:27'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test26 stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

!testRun: #TerniLapilliTest #test27 stamp: 'FC 10/31/2020 18:12:28'!
PASSED!

----SNAPSHOT----(31 October 2020 18:12:34) CuisUniversity-4383.image priorSource: 18348058!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:14:01'!
test26XPlayerShouldNotMoveMoreThanOneSlot
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test26 stamp: 'FC 10/31/2020 18:14:03'!
test26
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [game moveXFrom: 1@2 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:14:20'!
test27XPlayerShouldNotMoveBeforePlacingAllTokens
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	
	self should: [game moveXFrom: 1@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test27 stamp: 'FC 10/31/2020 18:14:23'!
test27
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	
	self should: [game moveXFrom: 1@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:15:14'!
test28OPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	game moveOFrom: 3@1 to: 3@2.
	self assert: (game isOAt: 3@2).
	! !

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:15:15'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:16:02'!
moveOWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isOAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:16:11' prior: 50909328!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	state := OTurnState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:16:11'!
ERROR!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:16:11'!
ERROR!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:16:11'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:16:11'!
ERROR!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:16:15'!
ERROR!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:16:15'!
ERROR!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:16:15'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:16:15'!
ERROR!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:16:22'!
ERROR!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:16:22'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:17:09' prior: 50909306!
validateMoveFrom: aPoint to: aPoint2

	(((aPoint2 dist: aPoint) = 1) or: [aPoint2 = (2@2) or: [aPoint = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:17:10'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:17:10'!
ERROR!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:17:10'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:17:38' prior: 50909490!
moveOWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isOAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	oTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	oTokens remove: aPoint. 
	oTokens add: aPoint2.
	
	state := XTurnState for: self.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:18:08'!
moveOFrom: aPoint to: aPoint2 
	
	state moveOFrom: aPoint to: aPoint2.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:18:36'!
moveOFrom: aPoint to: aPoint2 
	game moveOWhenValidFrom: aPoint  to: aPoint2. ! !

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:18:53'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:18:55'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:18:56'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:18:56'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:20:23'!
test29XPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	self should: [game moveOFrom: 3@3 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!testRun: #TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:20:39'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:20:40'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:41'!
PASSED!

!testRun: #TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:20:41'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:20:59'!
test29OPlayerShouldNotMoveInvalidToken
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	self should: [game moveOFrom: 3@3 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!methodRemoval: TerniLapilliTest #test29XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:21:03'!
test29XPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	self should: [game moveOFrom: 3@3 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:22:21'!
test30XPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [ game moveOFrom: 2@2 to: 2@3 ] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:22:47'!
test30OPlayerShouldNotOverlapTokens
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [ game moveOFrom: 2@2 to: 2@3 ] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	! !

!methodRemoval: TerniLapilliTest #test30XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:22:49'!
test30XPlayerShouldMoveCorrectly
	| game |
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [ game moveOFrom: 2@2 to: 2@3 ] raise: Error withMessageText: TerniLapilli invalidMoveMessage.	

	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:23:55'!
test31OPlayerShouldNotMoveWhenIsXTurn
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	self should: [	game moveOFrom: 2@2 to: 3@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:23:58'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:23:59'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:23:59'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:23:59'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:23:59'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:23:59'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:23:59'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:23:59'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:24:52'!
test32OPlayerShouldNotMoveMoreThanOneSlot
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	game putOAt: 2@3.
	game putXAt: 3@3.
	game putOAt: 3@1.
	
	game moveXFrom: 1@2 to: 1@1.
	
	self should: [game moveOFrom: 3@1 to: 1@2] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:24:54'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:24:55'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:24:55'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:25:30'!
test33OPlayerShouldNotMoveBeforePlacingAllTokens
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	
	self should: [game moveOFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:25:31'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:25:31'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:26:12'!
test34XPlayerShouldWinOnMovingPhase
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@2.
	game putOAt: 2@2.
	game putXAt: 1@3.
	
	self should: [game moveOFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:28:16' prior: 50910666!
test34XPlayerShouldWinOnMovingPhase
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@3.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 2@3.
	game putOAt: 3@3.	
	
	self should: [game moveOFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:28:54' prior: 50910677!
test34XPlayerShouldWinOnMovingPhase
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@3.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@2.
	game putOAt: 3@3.	
	
	self should: [game moveOFrom: 2@2 to: 1@1] raise: Error withMessageText: TerniLapilli invalidMoveMessage.
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:29:52' prior: 50910690!
test34XPlayerShouldWinOnMovingPhase
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@3.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@2.
	game putOAt: 3@3.	
	
	game moveXFrom: 1@1 to: 1@2.
	
	self assert: game hasPlayerXWon.
	! !

!testRun: #TerniLapilliTest #test34XPlayerShouldWinOnMovingPhase stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:29:53'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!testRun: #TerniLapilliTest #test34XPlayerShouldWinOnMovingPhase stamp: 'FC 10/31/2020 18:29:54'!
PASSED!

!methodRemoval: TerniLapilliTest #test34XPlayerShouldWinOnMovingPhase stamp: 'FC 10/31/2020 18:30:12'!
test34XPlayerShouldWinOnMovingPhase
	| game |
	
	game := TerniLapilli new.
	
	game putXAt: 1@1.
	game putOAt: 1@3.
	game putXAt: 2@2.
	game putOAt: 2@1.
	game putXAt: 3@2.
	game putOAt: 3@3.	
	
	game moveXFrom: 1@1 to: 1@2.
	
	self assert: game hasPlayerXWon.
	!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:30:14'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:30:16'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:30:16'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:30:16'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:30:17'!
PASSED!

OTurnState subclass: #OPlacingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OPlacingState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:31:26'!
OTurnState subclass: #OPlacingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

OTurnState subclass: #OMovingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OMovingState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:31:33'!
OTurnState subclass: #OMovingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

XTurnState subclass: #XMovingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XMovingState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:31:38'!
XTurnState subclass: #XMovingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

XTurnState subclass: #XPlacingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XPlacingState category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:31:44'!
XTurnState subclass: #XPlacingState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!OPlacingState methodsFor: 'nil' stamp: 'FC 10/31/2020 18:32:09' overrides: 50908686!
putOAt: aPoint
	game putOAtWhenValid: aPoint.! !
!OMovingState methodsFor: 'no messages' stamp: 'FC 10/31/2020 18:33:04' overrides: 50909828!
moveOFrom: aPoint to: aPoint2 
	game moveOWhenValidFrom: aPoint  to: aPoint2. ! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:34:23' prior: 50909504!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OTurnState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:34:48' prior: 50911013!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	xTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OMovingState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:35:33' prior: 50909810!
moveOWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isOAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
	oTokens size < 3 ifTrue: [self error: self class invalidMoveMessage ].
		
	oTokens remove: aPoint. 
	oTokens add: aPoint2.
	
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XMovingState for: self.		]! !
!OPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:36:07' overrides: 50909828!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!XPlacingState methodsFor: 'nil' stamp: 'FC 10/31/2020 18:37:13' overrides: 50908904!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:37:26' overrides: 50908589!
putXAt: aPoint
	game putXAtWhenValid: aPoint.! !

!methodRemoval: XPlacingState #moveXFrom:to: stamp: 'FC 10/31/2020 18:37:34'!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. !
!XMovingState methodsFor: 'nil' stamp: 'FC 10/31/2020 18:37:39' overrides: 50908904!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. ! !
!XMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:37:57' overrides: 50908589!
putXAt: aPoint
	self error: TerniLapilli invalidMoveMessage.! !
!XPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:38:06' overrides: 50908904!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 18:39:15' prior: 50909236!
putOAtWhenValid: aPoint 

	self validatePlacement: aPoint for: oTokens. 
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[	xTokens < 3 ifTrue: [
				state := XPlacingState for: self.		
			] ifFalse: [
				state := XMovingState for: self.
			]
		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 18:40:08' prior: 50909246!
putXAtWhenValid: aPoint 

	self validatePlacement: aPoint for: xTokens.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[	oTokens size < 3 ifTrue: [
				state := OPlacingState for: self.		
			] ifFalse: [
				state := OMovingState for: self.
			]
		]! !
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 18:40:14' prior: 50911102!
putOAtWhenValid: aPoint 

	self validatePlacement: aPoint for: oTokens. 
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[	xTokens size < 3 ifTrue: [
				state := XPlacingState for: self.		
			] ifFalse: [
				state := XMovingState for: self.
			]
		]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:40:15'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:40:16'!
FAILURE!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:40:16'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:40:16'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 18:40:37' prior: 50909223!
validatePlacement: aPoint for: tokens


	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:40:39'!
FAILURE!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:40:39'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:40:39'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'FC 10/31/2020 18:40:45' prior: 50911250!
validatePlacement: aPoint for: tokens

	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
	tokens add: aPoint! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:41:03' prior: 50911029!
moveXWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isXAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPoint. 
	xTokens add: aPoint2.
	
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OMovingState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:41:08' prior: 50911045!
moveOWhenValidFrom: aPoint to: aPoint2 
	
	self validateMoveFrom: aPoint to: aPoint2.
	(self isOAt: aPoint) ifFalse: [self error: self class invalidMoveMessage ].
		
	oTokens remove: aPoint. 
	oTokens add: aPoint2.
	
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XMovingState for: self.		]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:41:10'!
FAILURE!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:41:10'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:41:10'!
FAILURE!
!XPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:41:58' prior: 50911096 overrides: 50908904!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli tokenLimitExceededMessage.! !
!OMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:43:35' overrides: 50908686!
putOAt: aPoint
	self error: TerniLapilli tokenLimitExceededMessage.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:43:41'!
FAILURE!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:43:41'!
FAILURE!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:43:41'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:43:53'!
FAILURE!
!XPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:44:20' prior: 50911525 overrides: 50908904!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage .! !
!XPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:44:24' prior: 50911649 overrides: 50908904!
moveXFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!XMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:44:31' prior: 50911090 overrides: 50908589!
putXAt: aPoint
	self error: TerniLapilli tokenLimitExceededMessage.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:44:33'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:44:34'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:44:34'!
PASSED!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:45:05' prior: 50909705!
validateMoveFrom: aPointSource to: aPoint2

	(((aPoint2 dist: aPointSource) = 1) or: [aPoint2 = (2@2) or: [aPointSource = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPoint2) ifTrue: [self error: self class invalidMoveMessage ]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:45:37' prior: 50911777!
validateMoveFrom: aPointSource to: aPointDestiny

	(((aPointDestiny dist: aPointSource) = 1) or: [aPointDestiny = (2@2) or: [aPointSource = (2@2)]]) ifFalse: [ self error: self class invalidMoveMessage] .
	(self isOccupied: aPointDestiny) ifTrue: [self error: self class invalidMoveMessage ]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:45:45' prior: 50911384!
moveXWhenValidFrom: aPointSource to: aPoint2 
	
	self validateMoveFrom: aPointSource to: aPoint2.
	(self isXAt: aPointSource) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPointSource. 
	xTokens add: aPoint2.
	
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OMovingState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:45:53' prior: 50911802!
moveXWhenValidFrom: aPointSource to: aPointDestiny 
	
	self validateMoveFrom: aPointSource to: aPointDestiny.
	(self isXAt: aPointSource) ifFalse: [self error: self class invalidMoveMessage ].
		
	xTokens remove: aPointSource. 
	xTokens add: aPointDestiny.
	
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := OMovingState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:46:15' prior: 50908870!
moveXFrom: aPointSource to: aPoint2 
	
	state moveXFrom: aPointSource to: aPoint2.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:46:19' prior: 50911832!
moveXFrom: aPointSource to: aPointDestiny 
	
	state moveXFrom: aPointSource to: aPointDestiny.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:46:39' prior: 50911398!
moveOWhenValidFrom: aPointSource to: aPointDestiny 
	
	self validateMoveFrom: aPointSource to: aPointDestiny.
	(self isOAt: aPointSource) ifFalse: [self error: self class invalidMoveMessage ].
		
	oTokens remove: aPointSource. 
	oTokens add: aPointDestiny.
	
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[state := XMovingState for: self.		]! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:46:46' prior: 50909823!
moveOFrom: aPointSource to: aPoint2 
	
	state moveOFrom: aPointSource to: aPoint2.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:46:51' prior: 50911860!
moveOFrom: aPointSource to: aPointDestiny 
	
	state moveOFrom: aPointSource to: aPointDestiny.! !

!methodRemoval: OTurnState #moveOFrom:to: stamp: 'FC 10/31/2020 18:47:07'!
moveOFrom: aPoint to: aPoint2 
	game moveOWhenValidFrom: aPoint  to: aPoint2. !

!methodRemoval: OTurnState #putOAt: stamp: 'FC 10/31/2020 18:47:09'!
putOAt: aPoint
	game putOAtWhenValid: aPoint.!

!methodRemoval: XTurnState #putOAt: stamp: 'FC 10/31/2020 18:47:18'!
putOAt: aPoint
	self error: TerniLapilli invalidMoveMessage.!

!methodRemoval: XTurnState #moveOFrom:to: stamp: 'FC 10/31/2020 18:47:20'!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.!
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:48:03'!
moveOFrom: aPoint to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:48:13'!
putOAt: aPoint 
	self error: TerniLapilli invalidMoveMessage.! !

!methodRemoval: XTurnState #putXAt: stamp: 'FC 10/31/2020 18:48:17'!
putXAt: aPoint
	game putXAtWhenValid: aPoint.!

!methodRemoval: XTurnState #moveXFrom:to: stamp: 'FC 10/31/2020 18:48:18'!
moveXFrom: aPoint to: aPoint2 
	game moveXWhenValidFrom: aPoint  to: aPoint2. !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:48:21'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:48:21'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:48:21'!
FAILURE!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:48:21'!
ERROR!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:48:21'!
ERROR!
!TerniLapilli methodsFor: 'initialization' stamp: 'FC 10/31/2020 18:48:49' prior: 50908573 overrides: 16896425!
initialize 
	xTokens := OrderedCollection new.
	oTokens := OrderedCollection new.
	state := XPlacingState for: self.! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:48:50'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:48:51'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:48:51'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:48:51'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:48:51'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:48:51'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:48:51'!
PASSED!
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:49:24' prior: 50911889!
moveOFrom: aPointSource to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!XTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:49:29' prior: 50912131!
moveOFrom: aPointSource to: aPointDestiny 
	self error: TerniLapilli invalidMoveMessage.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:49:41' prior: 50908915!
moveXFrom: aPointSource to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!OTurnState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:49:46' prior: 50912143!
moveXFrom: aPointSource to: aPointDestiny 
	self error: TerniLapilli invalidMoveMessage.! !
!OMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:50:16' prior: 50911007!
moveOFrom: aPointSource to: aPoint2 
	game moveOWhenValidFrom: aPointSource  to: aPoint2. ! !
!OMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:50:22' prior: 50912155!
moveOFrom: aPointSource to: aPointDestiny 
	game moveOWhenValidFrom: aPointSource  to: aPointDestiny. ! !
!OPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:50:30' prior: 50911062!
moveOFrom: aPointSource to: aPoint2 
	self error: TerniLapilli invalidMoveMessage.! !
!OPlacingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:50:33' prior: 50912168!
moveOFrom: aPointSource to: aPointDestiny 
	self error: TerniLapilli invalidMoveMessage.! !
!XMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:50:42' prior: 50911084!
moveXFrom: aPointSource to: aPoint2 
	game moveXWhenValidFrom: aPointSource  to: aPoint2. ! !
!XMovingState methodsFor: 'as yet unclassified' stamp: 'FC 10/31/2020 18:50:47' prior: 50912180!
moveXFrom: aPointSource to: aPointDestiny 
	game moveXWhenValidFrom: aPointSource  to: aPointDestiny. ! !
!TerniLapilli methodsFor: 'testing - private' stamp: 'FC 10/31/2020 18:53:10' prior: 50904047!
hasOWinningColumn

	^(1 to: 3) anySatisfy: [ :colNumber | (self isOAt: 1@colNumber) and: [ (self isOAt: 2@colNumber) and: [ self isOAt: 3@colNumber ] ] ].! !
!TerniLapilli methodsFor: 'testing - private' stamp: 'FC 10/31/2020 18:53:55' prior: 50911373!
validatePlacement: aPoint for: tokens

	(self isValidPosition: aPoint) ifFalse: [ self error: self class outOfBoundsMoveMessage ]. 
	(self isOccupied: aPoint) ifTrue: [ 		self error: self class invalidMoveMessage. ].
! !
!TerniLapilli methodsFor: 'movements' stamp: 'FC 10/31/2020 18:54:17' prior: 50911126!
putOAtWhenValid: aPoint 

	self validatePlacement: aPoint for: oTokens. 
	oTokens add: aPoint.
	self hasPlayerOWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[	xTokens size < 3 ifTrue: [
				state := XPlacingState for: self.		
			] ifFalse: [
				state := XMovingState for: self.
			]
		]! !
!TerniLapilli methodsFor: 'movements' stamp: 'FC 10/31/2020 18:54:28' prior: 50911114!
putXAtWhenValid: aPoint 

	self validatePlacement: aPoint for: xTokens.
	xTokens add: aPoint.
	self hasPlayerXWon 
	ifTrue: 
		[ state := GameOverState for: self] 
	ifFalse: 
		[	oTokens size < 3 ifTrue: [
				state := OPlacingState for: self.		
			] ifFalse: [
				state := OMovingState for: self.
			]
		]! !

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 18:54:29'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 18:54:30'!
PASSED!

!classDefinition: #TerniLapilliTest category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:58:39'!
TestCase subclass: #TerniLapilliTest
	instanceVariableNames: 'game2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliTest methodsFor: 'setUp/tearDown' stamp: 'FC 10/31/2020 18:58:37' overrides: 16927572!
setUp
	game2 := TerniLapilli new.! !
!TerniLapilliTest methodsFor: 'tests' stamp: 'FC 10/31/2020 18:58:51' prior: 50902022!
test01PlayerXShouldStart
	
	self assert: game2 isPlayingX.
	! !

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: 'game2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliTest category: 'TerniLapilli' stamp: 'FC 10/31/2020 18:59:14'!
TestCase subclass: #TerniLapilliTest
	instanceVariableNames: 'game2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliTest methodsFor: 'tests' stamp: 'FC 10/31/2020 19:00:21' prior: 50912357!
test01PlayerXShouldStart
	| game |
	
	game := TerniLapilli new.
	self assert: game isPlayingX.
	! !

!methodRemoval: TerniLapilliTest #setUp stamp: 'FC 10/31/2020 19:00:25'!
setUp
	game2 := TerniLapilli new.!

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliTest category: 'TerniLapilli' stamp: 'FC 10/31/2020 19:00:34'!
TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 10/31/2020 19:00:36'!
PASSED!

----SNAPSHOT----(31 October 2020 19:00:54) CuisUniversity-4383.image priorSource: 18488807!

----SNAPSHOT----(31 October 2020 19:01:59) CuisUniversity-4383.image priorSource: 18587576!

----STARTUP---- (2 November 2020 19:12:01) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\2020-2c\18-Portfolio1\Portfolio-Ejercicio.st----!

!classRemoval: #ReceptiveAccount stamp: 'FC 11/2/2020 19:13:48'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'FC 11/2/2020 19:13:48'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'FC 11/2/2020 19:13:48'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'FC 11/2/2020 19:13:49'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'FC 11/2/2020 19:13:49'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\2020-2c\18-Portfolio1\Portfolio-Ejercicio.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:16:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:16:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:16:12'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/2/2020 19:16:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/2/2020 19:16:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/2/2020 19:16:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/2/2020 19:16:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:16:12'!
FAILURE!
!ReceptiveAccount methodsFor: 'balance' stamp: 'FC 11/2/2020 19:17:22' prior: 50912998!
balance

	^transactions sum: [ :aTransaction | 
		aTransaction class = Deposit ifTrue: [aTransaction value] 
		ifFalse: [aTransaction value *-1 ]] ifEmpty: [ 0 ]! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:17:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:17:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:17:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/2/2020 19:17:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/2/2020 19:17:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/2/2020 19:17:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/2/2020 19:17:23'!
PASSED!
!ReceptiveAccount methodsFor: 'balance' stamp: 'FC 11/2/2020 19:17:30' prior: 50913042!
balance

	^transactions sum: [ :aTransaction | 
		aTransaction class = Deposit 
		ifTrue: [aTransaction value] 
		ifFalse: [aTransaction value *-1 ]] ifEmpty: [ 0 ]! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'FC 11/2/2020 19:18:52' prior: 50913077!
balance

	^transactions sum: [ :aTransaction | 
		aTransaction class = Deposit 
		ifTrue: [aTransaction value] 
		ifFalse: [aTransaction value * -1 ]] ifEmpty: [ 0 ]! !

Object subclass: #Account
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Account category: 'Portfolio-Ejercicio' stamp: 'FC 11/2/2020 19:20:36'!
Object subclass: #Account
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #ReceptiveAccount
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'FC 11/2/2020 19:20:52'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Account category: 'Portfolio-Ejercicio' stamp: 'FC 11/2/2020 19:21:01'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'FC 11/2/2020 19:21:08'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #Portfolio
	instanceVariableNames: 'accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'FC 11/2/2020 19:21:30'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'FC 11/2/2020 19:24:38'!
test08PortfolioHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'FC 11/2/2020 19:24:49' prior: 50913158!
test08PortfolioHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := Portfolio new.

	self assert: 0 equals: account balance.
! !

!testRun: #ReceptiveAccountTest #test08PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:24:50'!
ERROR!
!Portfolio methodsFor: 'nil' stamp: 'FC 11/2/2020 19:25:01'!
balance
	^0! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test08PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:25:03'!
PASSED!

TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'FC 11/2/2020 19:25:26'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'nil' stamp: 'FC 11/2/2020 19:25:38'!
test01PortfolioHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := Portfolio new.

	self assert: 0 equals: account balance.
! !

!methodRemoval: ReceptiveAccountTest #test08PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:25:41'!
test08PortfolioHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := Portfolio new.

	self assert: 0 equals: account balance.
!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:25:43'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:27:03'!
test02PortfolioHaveBalanceOfAddedReceptiveAccount 

	| account receptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	self assert: 0 equals: account balance.
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:27:48' prior: 50913239!
test02PortfolioHaveBalanceOfAddedReceptiveAccount 

	| account receptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	Deposit register: 100 on: receptiveAccount.
	self assert: receptiveAccount balance equals: account balance.
! !

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:27:56'!
FAILURE!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:28:16' prior: 50913249!
test02PortfolioHaveBalanceOfAddedReceptiveAccount 

	| account receptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	Deposit register: 100 on: receptiveAccount.
	account add: receptiveAccount.
	self assert: receptiveAccount balance equals: account balance.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:28:47'!
add: anAccount
	accounts add: anAccount.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:29:03' overrides: 16896425!
initialize
	accounts := OrderedCollection new.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:29:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:29:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 19:29:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/2/2020 19:29:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/2/2020 19:29:06'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/2/2020 19:29:06'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/2/2020 19:29:06'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:29:08'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:29:08'!
FAILURE!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:29:08'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:30:24' prior: 50913176!
balance
	accounts size = 0 ifTrue: [
			^0
		]
		ifFalse: [
			^ accounts first balance
		]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:30:25'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:30:25'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:31:43'!
test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: 300 equals: account balance.
! !

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:31:44'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:32:27' prior: 50913324!
balance
	^accounts sum: [:anAccount | anAccount balance ] ifEmpty:[0]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:32:28'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:32:28'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:32:28'!
PASSED!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:32:42' prior: 50913359!
balance
	^accounts sum: [:anAccount | anAccount balance ] ifEmpty: [0]! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:34:20'!
test04PortfolioKnowsRegisteredTransactions 

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: 300 equals: account balance.
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:34:37'!
test04PortfolioKnowsRegisteredTransactionsOfChildren 

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: 300 equals: account balance.
! !

!methodRemoval: PortfolioTest #test04PortfolioKnowsRegisteredTransactions stamp: 'FC 11/2/2020 19:34:37'!
test04PortfolioKnowsRegisteredTransactions 

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: 300 equals: account balance.
!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:34:58'!
test04PortfolioKnowsRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: 300 equals: account balance.
! !

!methodRemoval: PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfChildren stamp: 'FC 11/2/2020 19:34:59'!
test04PortfolioKnowsRegisteredTransactionsOfChildren 

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: 300 equals: account balance.
!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:35:31' prior: 50913432!
test04PortfolioKnowsRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount anotherReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: 300 equals: account balance.
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:35:54' prior: 50913467!
test04PortfolioKnowsRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: 300 equals: account balance.
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:36:34' prior: 50913480!
test04PortfolioKnowsRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
! !

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:36:35'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:37:10'!
hasRegistered: aTransaction
	^true.! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:37:11'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:37:11'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:37:11'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:37:11'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:37:35'!
test05PortfolioDoesntKnowRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:37:55'!
test05PortfolioDoesNotKnowRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
! !

!methodRemoval: PortfolioTest #test05PortfolioDoesntKnowRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:37:55'!
test05PortfolioDoesntKnowRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:38:04'!
test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
! !

!methodRemoval: PortfolioTest #test05PortfolioDoesNotKnowRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:38:04'!
test05PortfolioDoesNotKnowRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:38:22' prior: 50913569!
test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	
	self assert: (account hasRegistered: deposit).
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:38:26' prior: 50913596!
test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	
	self deny: (account hasRegistered: deposit).
! !

!testRun: #PortfolioTest #test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:38:27'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:39:08' prior: 50913510!
hasRegistered: aTransaction
	^accounts anySatisfy: [ :anAccount | anAccount hasRegistered: aTransaction ].! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:39:09'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:39:09'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:39:09'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:39:09'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:39:09'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:39:16'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:39:16'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:39:16'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:39:16'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:39:16'!
PASSED!

array := #()!

array anySatisfy: [ :element | element = 1 ].!

array anySatisfy: [ :element | element = 1 ].!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:41:43'!
test06PortfolioKnowsItsTransactions 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
		
	self deny: (account hasRegistered: deposit).
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:42:34' prior: 50913674!
test06PortfolioKnowsItsTransactions 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: account transactions size equals: 1.
	self assert: (account transactions includes: deposit).

! !

array1,array2.!

array1 := #(0).
array2 := #(1).!

array1,array2.!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:45:57'!
transactions
	^accounts inject: #() into: [ :transactions :anAccount | transactions,anAccount transactions] . ! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:45:59'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:45:59'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:45:59'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:45:59'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:45:59'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 19:45:59'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:46:45'!
test07PortfolioKnowsTransactionsOfMoreThanOneAccount 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: account transactions size equals: 2.
	self assert: (account transactions includes: deposit).

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:47:42' prior: 50913732!
test07PortfolioKnowsTransactionsOfMoreThanOneAccount 

	| account receptiveAccount deposit anotherReceptiveAccount anotherDeposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	
	self assert: account transactions size equals: 2.
	self assert: (account transactions includes: deposit).
	self assert: (account transactions includes: anotherDeposit).

! !

!testRun: #PortfolioTest #test07PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 19:47:42'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 19:47:42'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 19:47:48' prior: 50913747!
test07PortfolioKnowsTransactionsOfMoreThanOneAccount 

	| account receptiveAccount deposit anotherReceptiveAccount anotherDeposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: account transactions size equals: 2.
	self assert: (account transactions includes: deposit).
	self assert: (account transactions includes: anotherDeposit).

! !
!Deposit methodsFor: 'value' stamp: 'FC 11/2/2020 20:00:02'!
addBalanceFor: anAccount

	^ anAccount addDeposit: self.! !
!Withdraw methodsFor: 'value' stamp: 'FC 11/2/2020 20:00:19'!
addBalanceFor: anAccount

	^ value! !
!Withdraw methodsFor: 'value' stamp: 'FC 11/2/2020 20:00:38' prior: 50913826!
addBalanceFor: anAccount

	^ anAccount addWithdraw: self.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'FC 11/2/2020 20:01:12'!
addDeposit: aDeposit
	^ aDeposit value.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'FC 11/2/2020 20:01:33'!
addWithdraw: aWithdrawal
	^ aWithdrawal value * -1.! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'FC 11/2/2020 20:01:59' prior: 50913085!
balance

	^transactions sum: [ :aTransaction | 
		aTransaction addBalanceFor: self.] ifEmpty: [ 0 ]! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:01:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 20:01:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 20:01:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/2/2020 20:01:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/2/2020 20:01:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/2/2020 20:01:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/2/2020 20:01:59'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:19:25'!
test04PortfolioKnowsRegisteredTransactionsOfAnAccount 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
! !

!methodRemoval: PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:19:28'!
test04PortfolioKnowsRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: (account hasRegistered: deposit).
!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:19:33'!
test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	
	self deny: (account hasRegistered: deposit).
! !

!methodRemoval: PortfolioTest #test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:19:33'!
test05PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	
	self deny: (account hasRegistered: deposit).
!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:19:40'!
test07PortfolioKnowsItsTransactions 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: account transactions size equals: 1.
	self assert: (account transactions includes: deposit).

! !

!methodRemoval: PortfolioTest #test06PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:19:40'!
test06PortfolioKnowsItsTransactions 

	| account receptiveAccount deposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	
	account add: receptiveAccount.
	
	self assert: account transactions size equals: 1.
	self assert: (account transactions includes: deposit).

!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:19:45'!
test08PortfolioKnowsTransactionsOfMoreThanOneAccount 

	| account receptiveAccount deposit anotherReceptiveAccount anotherDeposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: account transactions size equals: 2.
	self assert: (account transactions includes: deposit).
	self assert: (account transactions includes: anotherDeposit).

! !

!methodRemoval: PortfolioTest #test07PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:19:45'!
test07PortfolioKnowsTransactionsOfMoreThanOneAccount 

	| account receptiveAccount deposit anotherReceptiveAccount anotherDeposit |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	anotherReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 200 on: anotherReceptiveAccount.
	
	account add: receptiveAccount.
	account add: anotherReceptiveAccount.
	
	self assert: account transactions size equals: 2.
	self assert: (account transactions includes: deposit).
	self assert: (account transactions includes: anotherDeposit).

!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:24:02'!
test05PortfolioKnowsRegisteredTransactionsOfManyAccounts 

	| account aPortfolio receptiveAccount deposit anotherDeposit 
	portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 150 on: portfolioReceptiveAccount.
	
	portfolioReceptiveAccount add: receptiveAccount.
	
	account add: receptiveAccount.
	account add: portfolioReceptiveAccount.
	
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: anotherDeposit).
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:24:22' prior: 50914002!
test05PortfolioKnowsRegisteredTransactionsOfManyAccounts 

	| account aPortfolio receptiveAccount deposit anotherDeposit 
	portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 150 on: portfolioReceptiveAccount.
	
	aPortfolio add: portfolioReceptiveAccount.
	
	account add: receptiveAccount.
	account add: aPortfolio.
	
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: anotherDeposit).
! !

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:24:23'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:29:33'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:29:33'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:30:23' prior: 50913337!
test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts

	| account receptiveAccount anotherReceptiveAccount aPortfolio anotherDeposit deposit portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 150 on: portfolioReceptiveAccount.
	
	aPortfolio add: portfolioReceptiveAccount.
	
	account add: receptiveAccount.
	account add: aPortfolio.
	
	self assert: 300 equals: account balance.
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:30:48' prior: 50914117!
test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts

	| account receptiveAccount aPortfolio anotherDeposit deposit portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: receptiveAccount.
	anotherDeposit := Deposit register: 150 on: portfolioReceptiveAccount.
	
	aPortfolio add: portfolioReceptiveAccount.
	
	account add: receptiveAccount.
	account add: aPortfolio.
	
	self assert: 250 equals: account balance.
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:31:02' prior: 50914140!
test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts

	| account receptiveAccount aPortfolio portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 150 on: portfolioReceptiveAccount.
	
	aPortfolio add: portfolioReceptiveAccount.
	
	account add: receptiveAccount.
	account add: aPortfolio.
	
	self assert: 250 equals: account balance.
! !

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:31:05'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:31:05'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:31:27'!
test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts

	| account receptiveAccount aPortfolio portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 150 on: portfolioReceptiveAccount.
	
	aPortfolio add: portfolioReceptiveAccount.
	
	account add: receptiveAccount.
	account add: aPortfolio.
	
	self assert: 250 equals: account balance.
! !

!methodRemoval: PortfolioTest #test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:31:28'!
test03PortfolioHaveBalanceOfMultipleAddedReceptiveAccounts

	| account receptiveAccount aPortfolio portfolioReceptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	aPortfolio := Portfolio new.
	portfolioReceptiveAccount := ReceptiveAccount new.
	
	Deposit register: 100 on: receptiveAccount.
	Deposit register: 150 on: portfolioReceptiveAccount.
	
	aPortfolio add: portfolioReceptiveAccount.
	
	account add: receptiveAccount.
	account add: aPortfolio.
	
	self assert: 250 equals: account balance.
!

----SNAPSHOT----(2 November 2020 20:33:09) CuisUniversity-4383.image priorSource: 18587669!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:36:40'!
test09CantAddSameReceptiveAccountTwiceOnPortfolio
	| account  receptiveAccount |
	
	account := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	account add: receptiveAccount.
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:36:45'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:36:53'!
ERROR!
!Portfolio class methodsFor: 'error' stamp: 'FC 11/2/2020 20:36:59'!
duplicateAccountMessage
	self shouldBeImplemented.! !
!Portfolio class methodsFor: 'error' stamp: 'FC 11/2/2020 20:37:11' prior: 50914279!
duplicateAccountMessage
	^'Cuenta ya presente en el Portfolio'.! !

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:37:14'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:38:06' prior: 50913277!
add: anAccount
	(accounts includes: anAccount) ifTrue: [self error: self class duplicateAccountMessage ].
	accounts add: anAccount.! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:38:06'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:38:06'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:38:06'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:38:07'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:38:07'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:38:07'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:38:07'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:38:07'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:38:07'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:40:09'!
test10
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	aPortfolio add: receptiveAccount.
	account add: aPortfolio.
	
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:40:11' prior: 50914334!
test10
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	aPortfolio add: receptiveAccount.
	account add: aPortfolio.
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!testRun: #PortfolioTest #test10 stamp: 'FC 11/2/2020 20:40:12'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:40:54' prior: 50914293!
add: anAccount

	(accounts hasChild: anAccount) ifTrue: [self error: self class duplicateAccountMessage ].
	accounts add: anAccount.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'FC 11/2/2020 20:41:17'!
hasChild: anAccount
	^false.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:43:14'!
hasChild: anAccount
	^(accounts includes: anAccount) or: [ accounts anySatisfy: [ :account | account hasChild: anAccount ]]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:43:15'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:43:15'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:43:15'!
ERROR!

!testRun: #PortfolioTest #test10 stamp: 'FC 11/2/2020 20:43:15'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:44:06'!
isPresent: anAccount
	^accounts anySatisfy: [ :account | account hasChild: anAccount ]! !

!methodRemoval: Portfolio #hasChild: stamp: 'FC 11/2/2020 20:44:10'!
hasChild: anAccount
	^(accounts includes: anAccount) or: [ accounts anySatisfy: [ :account | account hasChild: anAccount ]]!
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'FC 11/2/2020 20:44:24'!
isPresent: anAccount
	^anAccount = self.! !

!methodRemoval: ReceptiveAccount #hasChild: stamp: 'FC 11/2/2020 20:44:27'!
hasChild: anAccount
	^false.!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/2/2020 20:44:29'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:44:31'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:44:31'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:44:31'!
ERROR!

!testRun: #PortfolioTest #test10 stamp: 'FC 11/2/2020 20:44:31'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:44:45' prior: 50914364!
add: anAccount

	(accounts isPresent: anAccount) ifTrue: [self error: self class duplicateAccountMessage ].
	accounts add: anAccount.! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:44:46'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:44:46'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test10 stamp: 'FC 11/2/2020 20:44:46'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:44:57'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:44:57'!
ERROR!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:45:10' prior: 50914499!
add: anAccount

	(self isPresent: anAccount) ifTrue: [self error: self class duplicateAccountMessage ].
	accounts add: anAccount.! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:45:13'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:45:13'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:45:13'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:45:13'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:45:13'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:45:13'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:45:13'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:45:14'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:45:14'!
FAILURE!

!testRun: #PortfolioTest #test10 stamp: 'FC 11/2/2020 20:45:14'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:45:30' prior: 50914417!
isPresent: anAccount
	^accounts anySatisfy: [ :account | account isPresent: anAccount ]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:45:31'!
PASSED!

!testRun: #PortfolioTest #test10 stamp: 'FC 11/2/2020 20:45:31'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:45:58'!
test10CantAddSameReceptiveAccountTwiceOnDifferentLevels
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	aPortfolio add: receptiveAccount.
	account add: aPortfolio.
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!methodRemoval: PortfolioTest #test10 stamp: 'FC 11/2/2020 20:46:00'!
test10
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	aPortfolio add: receptiveAccount.
	account add: aPortfolio.
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

!

----SNAPSHOT----(2 November 2020 20:47:16) CuisUniversity-4383.image priorSource: 18643366!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:47:29'!
test11PortfolioCantAddToItself
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	aPortfolio add: receptiveAccount.
	account add: aPortfolio.
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:47:47' prior: 50914664!
test11PortfolioCantAddToItself
	| account |
	
	account := Portfolio new.
	

	
	self should: [	account add: account.] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:47:51' prior: 50914679!
test11PortfolioCantAddToItself
	| account |
	
	account := Portfolio new.
	
	self should: [	account add: account.] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/2/2020 20:47:52'!
FAILURE!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:48:44' prior: 50914592!
isPresent: anAccount
	^self = anAccount or: [ accounts anySatisfy: [ :account | account isPresent: anAccount ]]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/2/2020 20:48:45'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/2/2020 20:48:45'!
PASSED!
!Account methodsFor: 'nil' stamp: 'FC 11/2/2020 20:52:30'!
hasRegistered: aTransaction
	self subclassResponsibility.! !
!Account methodsFor: 'as yet unclassified' stamp: 'FC 11/2/2020 20:52:39'!
balance
	self subclassResponsibility.! !
!Account methodsFor: 'nil' stamp: 'FC 11/2/2020 20:52:54'!
transactions
	self subclassResponsibility.! !

----SNAPSHOT----(2 November 2020 20:53:22) CuisUniversity-4383.image priorSource: 18656337!

----SNAPSHOT----(2 November 2020 20:54:56) CuisUniversity-4383.image priorSource: 18659469!

----SNAPSHOT----(2 November 2020 20:58:49) CuisUniversity-4383.image priorSource: 18659562!

portfolio1 add: portfolio2.!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.
portfolio3 := Portfolio new.
!

portfolio1 add: portfolio2.
!

portfolio1.!

portfolio2 add: portfolio1.!

portfolio2 add: portfolio1.!

portfiolio1!

portfolio1.!

portfolio2!

portfolio1!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.
portfolio3 := Portfolio new.
!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.
!


portfolio1 add: portfolio2.
portfolio2 add: portfolio1.
!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.
!

portfolio2 add: portfolio1.
portfolio1 add: portfolio2.

!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/2/2020 21:03:46' prior: 50914549!
add: anAccount

	((self isPresent: anAccount) or: [anAccount isPresent: self]) ifTrue: [self error: self class duplicateAccountMessage ].
	accounts add: anAccount.! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/2/2020 21:03:46'!
PASSED!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.

portfolio2 add: portfolio1.
portfolio1 add: portfolio2.

!

portfolio2 add: portfolio3.!

portfolio2 add: portfolio1.!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.!


portfolio1 add: portfolio2.
portfolio2 add: portfolio1.

!
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/2/2020 21:06:01'!
test12PortfolioCantAddToItselfOnChild
	| account aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	account add: aPortfolio.
	
	self should: [	aPortfolio add: account.] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/2/2020 21:06:02'!
PASSED!

portfolio1 := Portfolio new.
portfolio2 := Portfolio new.
portfolio3 := Portfolio new.!

account := Portfolio new.
aPortfolio := Portfolio new.
receptiveAccount := ReceptiveAccount new.
!

aPortfolio add: receptiveAccount.
account add: aPortfolio.
account add: receptiveAccount.!

account := Portfolio new.
aPortfolio := Portfolio new.
receptiveAccount := ReceptiveAccount new.!

account := Portfolio new.
aPortfolio := Portfolio new.
receptiveAccount := ReceptiveAccount new.!

account add: receptiveAccount.
account add: aPortfolio.
aPortfolio add: receptiveAccount.!

account := Portfolio new.
aPortfolio := Portfolio new.
receptiveAccount := ReceptiveAccount new.!

account := Portfolio new.
aPortfolio := Portfolio new.
receptiveAccount := ReceptiveAccount new.!

----SNAPSHOT----(2 November 2020 22:46:26) CuisUniversity-4383.image priorSource: 18659655!

----SNAPSHOT----(2 November 2020 22:46:43) CuisUniversity-4383.image priorSource: 18664801!

----QUIT----(2 November 2020 22:46:46) CuisUniversity-4383.image priorSource: 18664894!

----STARTUP---- (4 November 2020 17:26:35) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'FC 11/4/2020 17:30:18'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/4/2020 17:31:22' prior: 50914634!
test10CantAddSameReceptiveAccountTwiceOnDifferentLevels
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.

	account add: receptiveAccount.
	account add: aPortfolio.

	self should: [	aPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/4/2020 17:31:28'!
test13
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.

	account add: receptiveAccount.
	account add: aPortfolio.

	self should: [	aPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/2/2020 20:45:58' prior: 50914951!
test10CantAddSameReceptiveAccountTwiceOnDifferentLevels
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
	
	aPortfolio add: receptiveAccount.
	account add: aPortfolio.
	
	self should: [account add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:31:42'!
PASSED!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:31:42'!
FAILURE!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:31:42'!
FAILURE!
!Portfolio methodsFor: 'initialization' stamp: 'FC 11/4/2020 17:31:55' prior: 50913282 overrides: 16896425!
initialize
	accounts := OrderedCollection new.
	parents := OrderedCollection new.! !
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:34:05' prior: 50914787!
add: anAccount

	((self isPresent: anAccount) or: [anAccount isPresent: self]) ifTrue: [self error: self class duplicateAccountMessage ].
	anAccount addParent: self.
	
	accounts add: anAccount.! !
!Portfolio methodsFor: 'nil' stamp: 'FC 11/4/2020 17:34:35'!
addParent: anAccount
	self parents add: anAccount.! !
!ReceptiveAccount methodsFor: 'nil' stamp: 'FC 11/4/2020 17:34:56'!
addParent: anAccount! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/4/2020 17:34:59'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:35:01'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:35:01'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:35:01'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:35:01'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:35:01'!
ERROR!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:35:01'!
ERROR!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:35:07'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:35:07'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:35:07'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:35:07'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:35:07'!
ERROR!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:35:07'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:35:16'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:35:16'!
ERROR!
!Portfolio methodsFor: 'adding - private' stamp: 'FC 11/4/2020 17:35:32' prior: 50915062!
addParent: anAccount
	parents add: anAccount.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/4/2020 17:35:35'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:35:36'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:35:37'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:35:37'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:35:37'!
PASSED!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:35:37'!
FAILURE!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:35:37'!
FAILURE!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:40:32'!
roots
	parents isEmpty ifTrue: [^self].
	^parents inject: #() into: [ :roots :aParent |  roots , aParent roots  ]! !

----SNAPSHOT----(4 November 2020 17:40:35) CuisUniversity-4383.image priorSource: 18664987!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:41:05'!
validateAdd: anAccount

	^ ((self isPresent: anAccount) or: [anAccount isPresent: self]) ifTrue: [self error: self class duplicateAccountMessage ]! !
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:41:05' prior: 50915053!
add: anAccount

	self validateAdd: anAccount.
	anAccount addParent: self.
	
	accounts add: anAccount.! !
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:43:13' prior: 50915283!
validateAdd: anAccount

	^ ((self roots anySatisfy: [ :aRoot | aRoot isPresent: anAccount ]) or: [anAccount roots anySatisfy: [:aRoot | aRoot isPresent: self]]) 
		ifTrue: [self error: self class duplicateAccountMessage ]. 
	"((self isPresent: anAccount) or: [anAccount isPresent: self])" ! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:43:14'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:43:14'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:43:14'!
FAILURE!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:43:14'!
ERROR!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:43:14'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:43:24' prior: 50915297!
validateAdd: anAccount

	^ ((self roots anySatisfy: [ :aRoot | aRoot isPresent: anAccount ]) or: [anAccount roots anySatisfy: [:aRoot | aRoot isPresent: self]]) 
		ifTrue: [self error: self class duplicateAccountMessage ]. 
	
	"((self isPresent: anAccount) or: [anAccount isPresent: self])" ! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:43:24'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:43:24'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:43:24'!
FAILURE!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:43:24'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:43:30'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:43:30'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:44:29' prior: 50915274!
roots
	parents isEmpty ifTrue: [^#(self)].
	^parents inject: #() into: [ :roots :aParent |  roots , aParent roots  ]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:44:30'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:44:30'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:44:30'!
FAILURE!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:44:30'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:44:37'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:44:37'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:45:18'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:45:18'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:46:20' prior: 50915420!
roots
	parents isEmpty ifTrue: [^#() add: self].
	^parents inject: #() into: [ :roots :aParent |  roots , aParent roots  ]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:46:20'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:46:20'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:46:20'!
ERROR!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:46:21'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:46:21'!
FAILURE!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:46:21'!
ERROR!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:46:21'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:46:32'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:46:32'!
ERROR!

account := Portfolio new.
aPortfolio := Portfolio new.
receptiveAccount := ReceptiveAccount new.
!

account!

#(account)!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:47:40' prior: 50915487!
roots
	parents isEmpty ifTrue: [^Array with: self].
	^parents inject: #() into: [ :roots :aParent |  roots , aParent roots  ]! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:47:41'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:47:41'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:47:41'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:47:41'!
PASSED!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:47:41'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:47:47'!
ERROR!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:47:47'!
ERROR!

----SNAPSHOT----(4 November 2020 17:49:28) CuisUniversity-4383.image priorSource: 18676148!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:56:59' prior: 50915355!
validateAdd: anAccount

	^ (self roots anySatisfy: [ :aRoot | aRoot isPresent: anAccount ])		ifTrue: [self error: self class duplicateAccountMessage ]. 
	
	"((self isPresent: anAccount) or: [anAccount isPresent: self])" ! !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:57:00'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 17:57:17'!
PASSED!

!testRun: #PortfolioTest #test13 stamp: 'FC 11/4/2020 17:57:17'!
PASSED!
!Portfolio methodsFor: 'adding' stamp: 'FC 11/4/2020 17:57:57' prior: 50915614!
validateAdd: anAccount

	^ (self roots anySatisfy: [ :aRoot | aRoot isPresent: anAccount ])		ifTrue: [self error: self class duplicateAccountMessage ]. 
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/4/2020 18:00:40'!
test13PortfolioCantAddAccountWhenParentHasIt
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.

	account add: receptiveAccount.
	account add: aPortfolio.

	self should: [	aPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!methodRemoval: PortfolioTest #test13 stamp: 'FC 11/4/2020 18:00:41'!
test13
	| account receptiveAccount aPortfolio |
	
	account := Portfolio new.
	aPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.

	account add: receptiveAccount.
	account add: aPortfolio.

	self should: [	aPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

!
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/4/2020 18:04:50'!
test14PortfolioCantAddAccountWhenParentHasIt
	| rootPortfolio1 receptiveAccount rootPortfolio2  childPortfolio grandChildPortfolio|
	
	rootPortfolio1 := Portfolio new.
	rootPortfolio2 := Portfolio new.
	childPortfolio := Portfolio new.
	grandChildPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
		
	rootPortfolio1 add: childPortfolio.
	rootPortfolio2 add: childPortfolio.
	childPortfolio add: receptiveAccount.
	childPortfolio add: grandChildPortfolio.

	self should: [	grandChildPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test13PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/4/2020 18:04:51'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/4/2020 18:04:51'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'FC 11/4/2020 18:05:26'!
test14PortfolioCantAddAccountWhenManyParentsHasIt
	| rootPortfolio1 receptiveAccount rootPortfolio2  childPortfolio grandChildPortfolio|
	
	rootPortfolio1 := Portfolio new.
	rootPortfolio2 := Portfolio new.
	childPortfolio := Portfolio new.
	grandChildPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
		
	rootPortfolio1 add: childPortfolio.
	rootPortfolio2 add: childPortfolio.
	childPortfolio add: receptiveAccount.
	childPortfolio add: grandChildPortfolio.

	self should: [	grandChildPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

! !

!methodRemoval: PortfolioTest #test14PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/4/2020 18:05:36'!
test14PortfolioCantAddAccountWhenParentHasIt
	| rootPortfolio1 receptiveAccount rootPortfolio2  childPortfolio grandChildPortfolio|
	
	rootPortfolio1 := Portfolio new.
	rootPortfolio2 := Portfolio new.
	childPortfolio := Portfolio new.
	grandChildPortfolio := Portfolio new.
	receptiveAccount := ReceptiveAccount new.
		
	rootPortfolio1 add: childPortfolio.
	rootPortfolio2 add: childPortfolio.
	childPortfolio add: receptiveAccount.
	childPortfolio add: grandChildPortfolio.

	self should: [	grandChildPortfolio add: receptiveAccount ] raise: Error withMessageText: Portfolio duplicateAccountMessage.
	

!

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenManyParentsHasIt stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test13PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenManyParentsHasIt stamp: 'FC 11/4/2020 18:06:26'!
PASSED!

----SNAPSHOT----(4 November 2020 18:07:48) CuisUniversity-4383.image priorSource: 18686714!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 18:08:16'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/4/2020 18:08:16'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test13PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenManyParentsHasIt stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/4/2020 18:08:17'!
PASSED!

!testRun: #TerniLapilliTest #test01PlayerXShouldStart stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test02PlayerXShouldEndTurnAfterPlaying stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test03PlayerOShouldNotBeAbleToPlayAtGameStart stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test04PlayerXShouldGoAfterO stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test05PlayerXShouldNotBeAbleToPlayWhenIsOsTurn stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test06XTokenShouldBePlacedOnBoard stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokenShouldBePlacedOnBoard stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test10OPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test11XPlayerShouldNotBeAbleToPlayOnOccupiedCell stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test12XPlayerShouldNotBeAbleToPlayOnOutOfBoundsCell stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test13GameShouldNotBeOverAtStart stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test14OPlayerShouldWinWhenCompletingARow stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test15XPlayerShouldWinWhenCompletingARow stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test16XPlayerShouldWinWhenCompletingAColumn stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test17OPlayerShouldWinWhenCompletingAColumn stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test18XPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test19OPlayerShouldWinWhenCompletingADiagonal stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test20XPlayerShouldNotBeAbleToPlayOnGameOver stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test21XPlayerShouldNotHaveMoreThanThreeTokens stamp: 'FC 11/4/2020 18:08:20'!
PASSED!

!testRun: #TerniLapilliTest #test22XPlayerShouldMoveCorrectly stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test23XPlayerShouldNotMoveInvalidToken stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test24XPlayerShouldNotOverlapTokens stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test25XPlayerShouldNotMoveWhenIsOTurn stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test26XPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test27XPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test28OPlayerShouldMoveCorrectly stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test29OPlayerShouldNotMoveInvalidToken stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test30OPlayerShouldNotOverlapTokens stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test31OPlayerShouldNotMoveWhenIsXTurn stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test32OPlayerShouldNotMoveMoreThanOneSlot stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

!testRun: #TerniLapilliTest #test33OPlayerShouldNotMoveBeforePlacingAllTokens stamp: 'FC 11/4/2020 18:08:21'!
PASSED!

----QUIT----(4 November 2020 18:27:02) CuisUniversity-4383.image priorSource: 18696796!

----STARTUP---- (5 November 2020 17:21:03) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


Portfolio class.!

Portfolio class.!

TerniLapilli class compiledMethodAt: #gameOverMessage.!

TerniLapilli class compiledMethodAt: #gameOverMessage.!

TerniLapilli compiledMethodAt: #gameOverMessage.!

Class class.!

Class class!

Class class!

Class class.!

Class!

Class!

Class!

Class!

 Class !

 Class !

 Class !

 Class !

 Class !

 Class !

 Class !

 Class !

 Class !

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test13PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenManyParentsHasIt stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/5/2020 20:36:09'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/5/2020 20:36:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/5/2020 20:36:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/5/2020 20:36:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/5/2020 20:36:10'!
PASSED!

TerniLapilli class class!

TerniLapilli class class class!

TerniLapilli class class class class!

TerniLapilli class class class class class!

Object class!

Object class class!

Behavior class!

Class class!

----STARTUP---- (16 November 2020 16:34:39) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\Ejercicios\inge1-talleres\19-Portfolio2\Portfolio-Solucion.st----!

!testRun: #AccountSummaryTest #test01AccountSummaryForAnAccountWithoutTransactionsHasBalance0 stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #AccountSummaryTest #test02AccountSummaryForAnAccountWithADepositPrintsCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #AccountSummaryTest #test03AccountSummaryForAnAccountWithAWithdrawPrintsCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #AccountSummaryTest #test04AccountSummaryForAnAccountThatSentATransferPrintsCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #AccountSummaryTest #test05AccountSummaryForAnAccountThatReceivedATransferPrintsCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #AccountSummaryTest #test06AccountSummaryForAnAccountWithManyTransactionsPrintsCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #AccountSummaryTest #test07AccountSummaryForAPortfolioPrintsCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test01PortfolioHaveZeroAsBalanceWhenCreated stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithOneAccountIsAccountBalance stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test02PortfolioHaveBalanceOfAddedReceptiveAccount stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test03PortfolioHaveBalanceOfManyAddedReceptiveAccounts stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioKnowsRegisteredTransactionsOfAnAccount stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioKnowsRegisteredTransactionsOfManyAccounts stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioDoesNotKnowNotRegisteredTransactionsOfItsAccounts stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioKnowsItsTransactions stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioKnowsTransactionsOfMoreThanOneAccount stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test09CantAddSameReceptiveAccountTwiceOnPortfolio stamp: 'FC 11/16/2020 16:35:05'!
FAILURE!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test10CantAddSameReceptiveAccountTwiceOnDifferentLevels stamp: 'FC 11/16/2020 16:35:05'!
FAILURE!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCantAddToItself stamp: 'FC 11/16/2020 16:35:05'!
FAILURE!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCantAddToItselfOnChild stamp: 'FC 11/16/2020 16:35:05'!
FAILURE!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test13PortfolioCantAddAccountWhenParentHasIt stamp: 'FC 11/16/2020 16:35:05'!
FAILURE!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCantAddAccountWhenManyParentsHasIt stamp: 'FC 11/16/2020 16:35:05'!
FAILURE!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferNetTest #test01TransferNetWithNoOperationsIsZero stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferNetTest #test02TransferNetForSenderWithTransferSubstracts stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferNetTest #test03TransferNetForReceiverWithTransferAdds stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferNetTest #test04TransferNetForManyTransfersCalculatesCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferNetTest #test05TransferNetWithOnlyWithdrawIsZero stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferNetTest #test06TransferNetWithOnlyDepositIsZero stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferTest #test01TransferModifiesSenderAndReceiverAccountBalanceCorrectly stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferTest #test02TransferReceiverCanAccessToSendPart stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferTest #test03TransferSenderCanAccessToReceivePart stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferTest #test04TransferIsRegisteredOnSenderAndReceiverAccount stamp: 'FC 11/16/2020 16:35:05'!
PASSED!

!testRun: #TransferTest #test05TransferCanNotHaveAnAccountAsSenderAndReceiverAtTheSameTime stamp: 'FC 11/16/2020 16:35:06'!
PASSED!

!testRun: #TransferTest #test06TransferCanNotHaveZeroAsValue stamp: 'FC 11/16/2020 16:35:06'!
PASSED!

!testRun: #TransferTest #test07TransferCanNotHaveNegativeValue stamp: 'FC 11/16/2020 16:35:06'!
PASSED!

!classRemoval: #Transfer stamp: 'FC 11/16/2020 16:35:17'!
Object subclass: #Transfer
	instanceVariableNames: 'sendPart receivePart value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferNet stamp: 'FC 11/16/2020 16:35:18'!
Reports subclass: #TransferNet
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #AccountSummary stamp: 'FC 11/16/2020 16:35:18'!
Reports subclass: #AccountSummary
	instanceVariableNames: 'summary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Reports stamp: 'FC 11/16/2020 16:35:18'!
Object subclass: #Reports
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Withdraw stamp: 'FC 11/16/2020 16:35:18'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferSend stamp: 'FC 11/16/2020 16:35:19'!
TransferPart subclass: #TransferSend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferReceive stamp: 'FC 11/16/2020 16:35:19'!
TransferPart subclass: #TransferReceive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferPart stamp: 'FC 11/16/2020 16:35:19'!
AccountTransaction subclass: #TransferPart
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Deposit stamp: 'FC 11/16/2020 16:35:20'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #AccountTransaction stamp: 'FC 11/16/2020 16:35:20'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #ReceptiveAccount stamp: 'FC 11/16/2020 16:35:20'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Portfolio stamp: 'FC 11/16/2020 16:35:20'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Account stamp: 'FC 11/16/2020 16:35:21'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferTest stamp: 'FC 11/16/2020 16:35:21'!
TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferNetTest stamp: 'FC 11/16/2020 16:35:21'!
TestCase subclass: #TransferNetTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #ReceptiveAccountTest stamp: 'FC 11/16/2020 16:35:22'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #PortfolioTest stamp: 'FC 11/16/2020 16:35:22'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #AccountSummaryTest stamp: 'FC 11/16/2020 16:35:22'!
TestCase subclass: #AccountSummaryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\Ejercicios\inge1-talleres\19-Portfolio2\Portfolio-Solucion.st----!

!testRun: #AccountSummaryTest #test01AccountSummaryForAnAccountWithoutTransactionsHasBalance0 stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test02AccountSummaryForAnAccountWithADepositPrintsCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test03AccountSummaryForAnAccountWithAWithdrawPrintsCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test04AccountSummaryForAnAccountThatSentATransferPrintsCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test05AccountSummaryForAnAccountThatReceivedATransferPrintsCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test06AccountSummaryForAnAccountWithManyTransactionsPrintsCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test07AccountSummaryForAPortfolioPrintsCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithOneAccountIsAccountBalance stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferNetTest #test01TransferNetWithNoOperationsIsZero stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferNetTest #test02TransferNetForSenderWithTransferSubstracts stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferNetTest #test03TransferNetForReceiverWithTransferAdds stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferNetTest #test04TransferNetForManyTransfersCalculatesCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferNetTest #test05TransferNetWithOnlyWithdrawIsZero stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferNetTest #test06TransferNetWithOnlyDepositIsZero stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test01TransferModifiesSenderAndReceiverAccountBalanceCorrectly stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test02TransferReceiverCanAccessToSendPart stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test03TransferSenderCanAccessToReceivePart stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test04TransferIsRegisteredOnSenderAndReceiverAccount stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test05TransferCanNotHaveAnAccountAsSenderAndReceiverAtTheSameTime stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test06TransferCanNotHaveZeroAsValue stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #TransferTest #test07TransferCanNotHaveNegativeValue stamp: 'FC 11/16/2020 16:35:36'!
PASSED!

!testRun: #AccountSummaryTest #test01AccountSummaryForAnAccountWithoutTransactionsHasBalance0 stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #AccountSummaryTest #test02AccountSummaryForAnAccountWithADepositPrintsCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #AccountSummaryTest #test03AccountSummaryForAnAccountWithAWithdrawPrintsCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #AccountSummaryTest #test04AccountSummaryForAnAccountThatSentATransferPrintsCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #AccountSummaryTest #test05AccountSummaryForAnAccountThatReceivedATransferPrintsCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #AccountSummaryTest #test06AccountSummaryForAnAccountWithManyTransactionsPrintsCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #AccountSummaryTest #test07AccountSummaryForAPortfolioPrintsCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithOneAccountIsAccountBalance stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferNetTest #test01TransferNetWithNoOperationsIsZero stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferNetTest #test02TransferNetForSenderWithTransferSubstracts stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferNetTest #test03TransferNetForReceiverWithTransferAdds stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferNetTest #test04TransferNetForManyTransfersCalculatesCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferNetTest #test05TransferNetWithOnlyWithdrawIsZero stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferNetTest #test06TransferNetWithOnlyDepositIsZero stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test01TransferModifiesSenderAndReceiverAccountBalanceCorrectly stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test02TransferReceiverCanAccessToSendPart stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test03TransferSenderCanAccessToReceivePart stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test04TransferIsRegisteredOnSenderAndReceiverAccount stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test05TransferCanNotHaveAnAccountAsSenderAndReceiverAtTheSameTime stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test06TransferCanNotHaveZeroAsValue stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

!testRun: #TransferTest #test07TransferCanNotHaveNegativeValue stamp: 'FC 11/16/2020 16:35:44'!
PASSED!

----STARTUP---- (16 November 2020 17:35:43) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!classRemoval: #Rot13Test stamp: 'FC 11/16/2020 17:36:07'!
TestCase subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!

Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cart category: 'TusLibros' stamp: 'FC 11/16/2020 17:45:31'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/16/2020 17:49:00'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'no messages' stamp: 'FC 11/16/2020 18:55:06'!
test01
	|aCart|
	
	aCart := Cart new.
	
	self assert: aCart isEmpty.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 18:55:07'!
ERROR!
!Cart methodsFor: 'testing' stamp: 'FC 11/16/2020 18:55:15'!
isEmpty
	self shouldBeImplemented.! !
!Cart methodsFor: 'testing' stamp: 'FC 11/16/2020 18:55:22' prior: 50919674!
isEmpty
	^true! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 18:55:25'!
PASSED!

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 18:55:25'!
PASSED!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 18:55:48'!
test02
	|aCart|
	
	aCart := Cart new.
	
	aCart add: 'Librito'.
	
	self deny: aCart isEmpty.! !

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 18:55:50'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 18:55:58'!
add: aString 
	self shouldBeImplemented.! !

!classDefinition: #Cart category: 'TusLibros' stamp: 'FC 11/16/2020 18:57:04'!
Object subclass: #Cart
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 18:57:02' prior: 50919693!
add: aBook
	contents add: aBook! !

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 18:57:10'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 18:57:26' overrides: 16896425!
initialize
	contents := OrderedCollection new.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 18:57:26'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 18:57:26'!
FAILURE!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 18:57:26'!
FAILURE!
!Cart methodsFor: 'testing' stamp: 'FC 11/16/2020 18:57:38' prior: 50919678!
isEmpty
	^contents isEmpty.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 18:57:38'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 18:57:38'!
PASSED!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 18:59:32'!
test03
	|aCart|
	
	aCart := Cart new.
	
	aCart add: 'Librito'.
	aCart add: 'Falopa y Pasta Base'.
	
	self deny: aCart isEmpty.
	self assert: (aCart contains: 'Librito').
	self assert: (aCart contains: 'Falopa y Pasta Base').! !
!Cart methodsFor: 'testing' stamp: 'FC 11/16/2020 19:00:00'!
contains: aBook
	^contents includes: aBook.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:00:01'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:00:01'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:00:01'!
PASSED!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/16/2020 19:01:55'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/16/2020 19:01:56'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook anotherBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:01:53' overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	anotherBook := 'Design Patterns'.
! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:02:05' prior: 50919686!
test02
	|aCart|
	
	aCart := Cart new.
	
	aCart add: aBook.
	
	self deny: aCart isEmpty.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:02:31' prior: 50919729!
test03
	|aCart|
	
	aCart := Cart new.
	
	aCart add: aBook.
	aCart add: anotherBook.
	
	self deny: aCart isEmpty.
	self assert: (aCart contains: aBook).
	self assert: (aCart contains: anotherBook).! !

Object subclass: #Cart
	instanceVariableNames: 'contents catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cart category: 'TusLibros' stamp: 'FC 11/16/2020 19:02:59'!
Object subclass: #Cart
	instanceVariableNames: 'contents catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/16/2020 19:03:50'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook anotherBook invalidBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:03:48' prior: 50919764 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	anotherBook := 'Design Patterns'.
	invalidBook := 'Computer Networks: A systems approach'.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:04:04' prior: 50919805 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	anotherBook := 'Design Patterns'.
	invalidBook   := 'Computer Networks: A systems approach'.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:04:13' prior: 50919813 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	anotherBook := 'Design Patterns'.
	invalidBook := 'Computer Networks: A systems approach'.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:05:24'!
test04
	|aCart|
	
	aCart := Cart new.
	
	self should: [ aCart add: invalidBook ] raise: Error withMessageText: Cart invalidBookMessage.
	
	self assert: aCart isEmpty. 
! !
!Cart class methodsFor: 'no messages' stamp: 'FC 11/16/2020 19:06:18'!
withCatalog: aCatalog
	self new initializeFor: aCatalog.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:07:07'!
initializeFor: aCatalog
	catalog := aCatalog.
	contents := OrderedCollection new.! !

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/16/2020 19:07:33'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook anotherBook invalidBook aCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:07:31' prior: 50919821 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	anotherBook := 'Design Patterns'.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := OrderedCollection with: aBook with: anotherBook.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:07:55' prior: 50919854 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	anotherBook := 'Design Patterns'.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := OrderedCollection with: aBook with: anotherBook.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:08:13' prior: 50919667!
test01
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self assert: aCart isEmpty.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:08:18' prior: 50919770!
test02
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: aBook.
	
	self deny: aCart isEmpty.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:08:22' prior: 50919776!
test03
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: aBook.
	aCart add: anotherBook.
	
	self deny: aCart isEmpty.
	self assert: (aCart contains: aBook).
	self assert: (aCart contains: anotherBook).! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:08:27' prior: 50919828!
test04
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: invalidBook ] raise: Error withMessageText: Cart invalidBookMessage.
	
	self assert: aCart isEmpty. 
! !
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:09:27' prior: 50919704!
add: aBook
	(catalog includes: aBook) ifFalse:[^self error: self class invalidBookMessage].
	contents add: aBook.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:09:28'!
ERROR!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:09:28'!
ERROR!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:09:28'!
ERROR!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:09:28'!
ERROR!

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:09:32'!
ERROR!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:09:32'!
ERROR!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:09:32'!
ERROR!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:09:32'!
ERROR!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:09:34'!
ERROR!
!Cart class methodsFor: 'error' stamp: 'FC 11/16/2020 19:09:42'!
invalidBookMessage
	self shouldBeImplemented.! !
!Cart class methodsFor: 'error' stamp: 'FC 11/16/2020 19:09:50' prior: 50919931!
invalidBookMessage
	^'Book not in catalog'.! !

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:09:53'!
FAILURE!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:09:59'!
ERROR!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:10:01'!
ERROR!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:10:02'!
ERROR!
!Cart class methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:10:18' prior: 50919836!
withCatalog: aCatalog
	^self new initializeFor: aCatalog.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:10:19'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:10:19'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:10:19'!
PASSED!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:10:19'!
PASSED!
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:20:40'!
add: aQuantity copiesOf: aBook
	(catalog includes: aBook) ifFalse:[^self error: self class invalidBookMessage].
	
	contents add: aBook.! !

!methodRemoval: Cart #initialize stamp: 'FC 11/16/2020 19:20:47'!
initialize
	contents := OrderedCollection new.!
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:20:56' prior: 50919840!
initializeFor: aCatalog
	catalog := aCatalog.
	contents := Dictionary new.! !

!methodRemoval: Cart #add: stamp: 'FC 11/16/2020 19:21:25'!
add: aBook
	(catalog includes: aBook) ifFalse:[^self error: self class invalidBookMessage].
	contents add: aBook.!
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:25:11' prior: 50919963!
add: aQuantity copiesOf: aBook
	(catalog includes: aBook) ifFalse:[^self error: self class invalidBookMessage].
	(contents includesKey: aBook)
	ifTrue: [
		contents at: aBook put: (contents at: aBook + aQuantity)
	] 
	ifFalse: [ 
		contents at: aBook put: aQuantity.
	]
	! !
!Cart methodsFor: 'testing' stamp: 'FC 11/16/2020 19:25:37' prior: 50919739!
contains: aBook
	^contents includesKey: aBook.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:25:57' prior: 50919985!
add: aQuantity copiesOf: aBook
	(catalog includes: aBook) ifFalse:[^self error: self class invalidBookMessage].
	
	(self contains: aBook)
	ifTrue: [
		contents at: aBook put: (contents at: aBook + aQuantity)
	] 
	ifFalse: [ 
		contents at: aBook put: aQuantity.
	]
	! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:26:13' prior: 50919879!
test02
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 1 copiesOf:aBook.
	
	self deny: aCart isEmpty.! !

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:26:14'!
PASSED!

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:26:14'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:26:14'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:26:14'!
ERROR!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:26:14'!
FAILURE!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:26:37' prior: 50919886!
test03
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 1 copiesOf: aBook.
	aCart add: 1 copiesOf: anotherBook.
	
	self deny: aCart isEmpty.
	self assert: (aCart contains: aBook).
	self assert: (aCart contains: anotherBook).! !

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:26:38'!
PASSED!

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:26:38'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:26:38'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:26:38'!
PASSED!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:26:38'!
FAILURE!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:26:38'!
FAILURE!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:26:46' prior: 50919896!
test04
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: 1 copiesOf: invalidBook ] raise: Error withMessageText: Cart invalidBookMessage.
	
	self assert: aCart isEmpty. 
! !

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:26:46'!
PASSED!

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:26:46'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:26:46'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:26:46'!
PASSED!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:26:46'!
PASSED!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:27:26'!
test05
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: -1 copiesOf: aBook ] raise: Error withMessageText: Cart invalidQuantity.
	
	self assert: aCart isEmpty. 
! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:27:39'!
test06
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: 0 copiesOf: aBook ] raise: Error withMessageText: Cart invalidQuantity.
	
	self assert: aCart isEmpty. 
! !
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:28:20' prior: 50920000!
add: aQuantity copiesOf: aBook
	(catalog includes: aBook) ifFalse:[self error: self class invalidBookMessage].
	(aQuantity <= 0) ifTrue: [self error: self class invalidQuantity].
	(self contains: aBook)
	ifTrue: [
		contents at: aBook put: (contents at: aBook + aQuantity)
	] 
	ifFalse: [ 
		contents at: aBook put: aQuantity.
	]
	! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:28:21'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:28:21'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:28:21'!
PASSED!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:28:21'!
PASSED!

!testRun: #CartTest #test05 stamp: 'FC 11/16/2020 19:28:21'!
ERROR!

!testRun: #CartTest #test06 stamp: 'FC 11/16/2020 19:28:21'!
ERROR!
!Cart class methodsFor: 'error' stamp: 'FC 11/16/2020 19:28:39'!
invalidQuantity
	^'Book quantity must be positive'.! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:28:40'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:28:40'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:28:40'!
PASSED!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:28:40'!
PASSED!

!testRun: #CartTest #test05 stamp: 'FC 11/16/2020 19:28:40'!
PASSED!

!testRun: #CartTest #test06 stamp: 'FC 11/16/2020 19:28:40'!
PASSED!
!CartTest methodsFor: 'as yet unclassified' stamp: 'FC 11/16/2020 19:29:55'!
test07
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 2 copiesOf: aBook.

	self deny: aCart isEmpty.
	self assert: (aCart copiesOf: aBook) equals: 2.
! !
!Cart methodsFor: 'accessing' stamp: 'FC 11/16/2020 19:30:40'!
copiesOf: aBook
	^contents at: aBook ifAbsent: [0]! !

!testRun: #CartTest #test01 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!

!testRun: #CartTest #test02 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!

!testRun: #CartTest #test03 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!

!testRun: #CartTest #test04 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!

!testRun: #CartTest #test05 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!

!testRun: #CartTest #test06 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!

!testRun: #CartTest #test07 stamp: 'FC 11/16/2020 19:30:41'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:31:19'!
test01newCartShouldBeEmpty
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self assert: aCart isEmpty.! !

!methodRemoval: CartTest #test01 stamp: 'FC 11/16/2020 19:31:20'!
test01
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self assert: aCart isEmpty.!
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:31:34'!
test02canAddOneCopyOfValidBook
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 1 copiesOf:aBook.
	
	self deny: aCart isEmpty.! !

!methodRemoval: CartTest #test02 stamp: 'FC 11/16/2020 19:31:37'!
test02
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 1 copiesOf:aBook.
	
	self deny: aCart isEmpty.!
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:31:51'!
test03canAddOneCopyOfManyValidBooks
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 1 copiesOf: aBook.
	aCart add: 1 copiesOf: anotherBook.
	
	self deny: aCart isEmpty.
	self assert: (aCart contains: aBook).
	self assert: (aCart contains: anotherBook).! !

!methodRemoval: CartTest #test03 stamp: 'FC 11/16/2020 19:31:54'!
test03
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 1 copiesOf: aBook.
	aCart add: 1 copiesOf: anotherBook.
	
	self deny: aCart isEmpty.
	self assert: (aCart contains: aBook).
	self assert: (aCart contains: anotherBook).!
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:32:13'!
test04canNotAddCopiesOfBookNotInCatalog
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: 1 copiesOf: invalidBook ] raise: Error withMessageText: Cart invalidBookMessage.
	
	self assert: aCart isEmpty. 
! !

!methodRemoval: CartTest #test04 stamp: 'FC 11/16/2020 19:32:15'!
test04
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: 1 copiesOf: invalidBook ] raise: Error withMessageText: Cart invalidBookMessage.
	
	self assert: aCart isEmpty. 
!
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:32:32'!
test05canNotAddNegativeCopiesOfABook
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: -1 copiesOf: aBook ] raise: Error withMessageText: Cart invalidQuantity.
	
	self assert: aCart isEmpty. 
! !

!methodRemoval: CartTest #test05 stamp: 'FC 11/16/2020 19:32:34'!
test05
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: -1 copiesOf: aBook ] raise: Error withMessageText: Cart invalidQuantity.
	
	self assert: aCart isEmpty. 
!
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:32:50'!
test06canNotAddZeroCopiesOfABook
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: 0 copiesOf: aBook ] raise: Error withMessageText: Cart invalidQuantity.
	
	self assert: aCart isEmpty. 
! !
!CartTest methodsFor: 'tests' stamp: 'FC 11/16/2020 19:33:03'!
test07canAddMultipleCopiesOfOneValidBook
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 2 copiesOf: aBook.

	self deny: aCart isEmpty.
	self assert: (aCart copiesOf: aBook) equals: 2.
! !

!methodRemoval: CartTest #test07 stamp: 'FC 11/16/2020 19:33:05'!
test07
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	aCart add: 2 copiesOf: aBook.

	self deny: aCart isEmpty.
	self assert: (aCart copiesOf: aBook) equals: 2.
!

!methodRemoval: CartTest #test06 stamp: 'FC 11/16/2020 19:33:06'!
test06
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [ aCart add: 0 copiesOf: aBook ] raise: Error withMessageText: Cart invalidQuantity.
	
	self assert: aCart isEmpty. 
!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/16/2020 19:33:19'!
PASSED!

a := Bag new.!

a occurrencesOf: 122!
!Cart methodsFor: 'testing' stamp: 'FC 11/16/2020 19:38:55' prior: 50919996!
contains: aBook
	^contents includes: aBook.! !
!Cart methodsFor: 'accessing' stamp: 'FC 11/16/2020 19:39:15' prior: 50920144!
copiesOf: aBook
	^contents occurrencesOf: aBook.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/16/2020 19:41:31' prior: 50920092!
add: aQuantity copiesOf: aBook
	(catalog includes: aBook) ifFalse:[self error: self class invalidBookMessage].
	(aQuantity <= 0) ifTrue: [self error: self class invalidQuantity].
	contents add: aBook withOccurrences: aQuantity.! !

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/16/2020 19:41:32'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/16/2020 19:41:32'!
ERROR!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/16/2020 19:41:32'!
ERROR!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/16/2020 19:41:32'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/16/2020 19:41:32'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/16/2020 19:41:32'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/16/2020 19:41:32'!
ERROR!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/16/2020 19:41:36'!
ERROR!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/16/2020 19:41:44'!
ERROR!
!Cart methodsFor: 'initialization' stamp: 'FC 11/16/2020 19:42:27' prior: 50919974!
initializeFor: aCatalog
	catalog := aCatalog.
	contents := Bag new.! !

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/16/2020 19:42:27'!
PASSED!

----SNAPSHOT----(16 November 2020 19:42:53) CuisUniversity-4383.image priorSource: 18702785!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/16/2020 19:50:21'!
PASSED!

----SNAPSHOT----(16 November 2020 19:50:24) CuisUniversity-4383.image priorSource: 18839188!

----SNAPSHOT----(16 November 2020 22:01:44) CuisUniversity-4383.image priorSource: 18839968!

----QUIT----(16 November 2020 22:01:47) CuisUniversity-4383.image priorSource: 18840062!

----STARTUP---- (18 November 2020 16:27:14) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/18/2020 16:27:17'!
PASSED!

----STARTUP---- (19 November 2020 18:44:57) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 18:45:07'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 18:45:07'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 18:45:07'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 18:45:07'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 18:45:07'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 18:45:07'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 18:45:07'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'FC 11/19/2020 18:47:22'!
test08canNotAddNonIntegerCopiesOfABook
	|aCart|
	
	aCart := Cart withCatalog: aCatalog.
	
	self should: [aCart add: 1.5 copiesOf: aBook] raise: Error withMessageText: Cart invalidQuantity.

	self assert: (aCart isEmpty).
! !

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 18:47:23'!
FAILURE!
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 18:47:42' prior: 50920311!
add: aQuantity copiesOf: aBook

	(catalog includes: aBook) ifFalse:[self error: self class invalidBookMessage].
	(aQuantity <= 0) ifTrue: [self error: self class invalidQuantity].
	contents add: aBook withOccurrences: aQuantity.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 18:47:55'!
validateBook: aBook

	^ (catalog includes: aBook) ifFalse:[self error: self class invalidBookMessage]! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 18:47:55' prior: 50920472!
add: aQuantity copiesOf: aBook

	self validateBook: aBook.
	(aQuantity <= 0) ifTrue: [self error: self class invalidQuantity].
	contents add: aBook withOccurrences: aQuantity.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 18:48:06'!
validateQuantity: aQuantity

	^ (aQuantity <= 0) ifTrue: [self error: self class invalidQuantity]! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 18:48:06' prior: 50920488!
add: aQuantity copiesOf: aBook

	self validateBook: aBook.
	self validateQuantity: aQuantity.
	contents add: aBook withOccurrences: aQuantity.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 18:48:38' prior: 50920496!
validateQuantity: aQuantity

	^ ((aQuantity <= 0) or: [(aQuantity isInteger) not ]) ifTrue: [self error: self class invalidQuantity]! !

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 18:48:39'!
PASSED!

TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 18:49:12'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 18:50:23'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'FC 11/19/2020 18:50:32'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'no messages' stamp: 'FC 11/19/2020 18:50:20'!
test01
	| aCashier aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	
	aCashier := Cashier for: aCart

! !

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 18:51:13'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 18:51:12' overrides: 16927572!
setUp
	aBook := 'Design Patterns'.
 	testCatalog := OrderedCollection with: aBook.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 18:51:25' prior: 50920579 overrides: 16927572!
setUp
	aBook := 'Design Patterns'.
 	testCatalog := OrderedCollection with: aBook.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 18:51:29'!
ERROR!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/19/2020 18:51:35'!
for: aCart 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFor: aCart ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 18:53:37' prior: 50920565!
test01
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 18:53:44' prior: 50920602!
test01
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 18:53:51'!
ERROR!
!Cashier class methodsFor: 'error' stamp: 'FC 11/19/2020 18:54:00'!
emptyCartMessage
	self shouldBeImplemented.! !
!Cashier class methodsFor: 'error' stamp: 'FC 11/19/2020 18:54:09' prior: 50920621!
emptyCartMessage
	^'Cart is empty'! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 18:54:10'!
FAILURE!

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 18:54:21'!
FAILURE!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/19/2020 18:54:49' prior: 50920594!
for: aCart 
	^self error: self emptyCartMessage.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 18:54:50'!
PASSED!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/19/2020 18:55:09' prior: 50920635!
for: aCart 
	self error: self emptyCartMessage.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 18:55:10'!
PASSED!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 18:57:55'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 18:57:50'!
test02
	| aCart aCashier total|
	
	aCart := Cart withCatalog: testCatalog.
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart.
	
	total := aCashier checkOut.
	
	self assert total equals: aBookPrice.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 18:58:03' prior: 50920656!
test02
	| aCart aCashier total|
	
	aCart := Cart withCatalog: testCatalog.
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/19/2020 18:59:40'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook anotherBook invalidBook aCatalog aBookPrice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'FC 11/19/2020 18:59:41'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook anotherBook invalidBook aCatalog aBookPrice anotherBookPrice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'setUp/tearDown' stamp: 'FC 11/19/2020 18:59:39' prior: 50919864 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := OrderedCollection with: aBook with: anotherBook.! !
!CartTest methodsFor: 'setUp/tearDown' stamp: 'FC 11/19/2020 19:00:16' prior: 50920694 overrides: 16927572!
setUp
	
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.! !

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 19:00:19'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 19:00:19'!
ERROR!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 19:00:19'!
ERROR!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 19:00:19'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 19:00:19'!
FAILURE!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 19:00:19'!
FAILURE!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 19:00:19'!
ERROR!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 19:00:19'!
FAILURE!
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 19:00:33' prior: 50920482!
validateBook: aBook

	^ (catalog includesKey: aBook) ifFalse:[self error: self class invalidBookMessage]! !

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 19:00:34'!
PASSED!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 19:01:02'!
PASSED!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 19:01:26'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 19:01:27'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 19:01:28'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice invalidBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 19:01:29'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice invalidBook aCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:01:24' prior: 50920586 overrides: 16927572!
setUp
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:01:31'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:01:31'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:01:31'!
ERROR!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 19:01:40'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 19:01:40'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:01:57' prior: 50920666!
test02
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:01:57'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:02:00'!
ERROR!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/19/2020 19:02:40' prior: 50920642!
for: aCart 
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	self new initializeFor: aCart.! !

!classDefinition: #Cashier category: 'TusLibros' stamp: 'FC 11/19/2020 19:03:13'!
Object subclass: #Cashier
	instanceVariableNames: 'cart'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'no messages' stamp: 'FC 11/19/2020 19:03:11'!
initializeFor: aCart
	cart := aCart.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:03:14'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:03:14'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:03:14'!
ERROR!
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:03:39'!
checkOut
	self cart! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 19:04:31'!
listBooks
	contents copy.! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 19:04:34' prior: 50920917!
listBooks
	^contents copy.! !

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 19:04:35'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 19:04:35'!
PASSED!
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:05:15' prior: 50920914!
checkOut
	cart listBooks first! !
!Cart methodsFor: 'adding' stamp: 'FC 11/19/2020 19:05:28'!
catalog
	^catalog copy.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:06:05' prior: 50920950!
checkOut
	^ cart catalog at: cart listBooks first! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:06:06'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:06:06'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:06:06'!
ERROR!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/19/2020 19:06:18' prior: 50920890!
for: aCart 
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	^self new initializeFor: aCart.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:06:19'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:06:19'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:06:19'!
ERROR!
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:08:09' prior: 50920957!
checkOut
	| total  catalog|
	catalog := cart catalog.
	total := 0.
	cart listBooks do: [ :aBook | total := total + catalog at: aBook ].
	^ total.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:08:09'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:08:09'!
PASSED!
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:08:22' prior: 50920983!
checkOut
	| total  catalog |
	catalog := cart catalog.
	total := 0.
	cart listBooks do: [ :aBook | total := total + catalog at: aBook ].
	^ total.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:08:25' prior: 50920996!
checkOut
	| total catalog |
	catalog := cart catalog.
	total := 0.
	cart listBooks do: [ :aBook | total := total + catalog at: aBook ].
	^ total.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:09:17'!
test03
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
! !

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:09:17'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:09:17'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:09:17'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:09:17'!
PASSED!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 19:11:23'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice invalidBook aCatalog anExpiredCreditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:11:21'!
test04
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:11:42' prior: 50921041!
test04
	| aCart |
	
	aCart := Cart withCatalog: aCatalog .
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	! !

Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'FC 11/19/2020 19:12:07'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

May / 20 class!

(May / 20) class!

May / 2020!

2020 /  May!

CreditCard class
	instanceVariableNames: 'expirationDate'!

!classDefinition: 'CreditCard class' category: 'TusLibros' stamp: 'FC 11/19/2020 19:14:26'!
CreditCard class
	instanceVariableNames: 'expirationDate'!

CreditCard class
	instanceVariableNames: ''!

!classDefinition: 'CreditCard class' category: 'TusLibros' stamp: 'FC 11/19/2020 19:14:33'!
CreditCard class
	instanceVariableNames: ''!
!CreditCard class methodsFor: 'no messages' stamp: 'FC 11/19/2020 19:15:06'!
withExpirationDate: aMonthOfYear
	self new initializeWithExpirationDate: aMonthOfYear.! !
!CreditCard methodsFor: 'no messages' stamp: 'FC 11/19/2020 19:15:49'!
initalizeWithExpirationDate: aMonthOfYear
	expirationDate := aMonthOfYear.! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:16:58'!
isExpired
	^GregorianMonthOfYear today > expirationDate.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:17:50' prior: 50920832 overrides: 16927572!
setUp
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.
	anExpiredCreditCard := CreditCard withExpirationDate: (GregorianMonthOfYear year: 2020 month: May). ! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:18:11' prior: 50921086!
withExpirationDate: aMonthOfYear
	^self new initializeWithExpirationDate: aMonthOfYear.! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:18:35'!
initializeWithExpirationDate: aMonthOfYear
	expirationDate := aMonthOfYear.! !

!methodRemoval: CreditCard #initalizeWithExpirationDate: stamp: 'FC 11/19/2020 19:18:37'!
initalizeWithExpirationDate: aMonthOfYear
	expirationDate := aMonthOfYear.!

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:18:41'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:18:41'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:18:41'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:18:41'!
ERROR!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:18:41'!
ERROR!
!Cashier class methodsFor: 'error' stamp: 'FC 11/19/2020 19:19:04'!
creditCardExpiredMessage
	^'Credit Card is expired'! !
!Cashier class methodsFor: 'error' stamp: 'FC 11/19/2020 19:19:06' prior: 50921146!
creditCardExpiredMessage
	^'Credit Card is expired'! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:19:06'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:19:06'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:19:06'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:19:06'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:19:06'!
FAILURE!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/19/2020 19:19:39'!
for: aCart using: aCreditCard
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:19:40'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:19:40'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:19:40'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:19:40'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:19:40'!
FAILURE!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:20:05' prior: 50921051!
test04
	| aCart |
	
	aCart := Cart withCatalog: aCatalog .
	aCart add: 1 copiesOf: aBook.
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	! !

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:20:05'!
FAILURE!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:20:23' prior: 50921097!
isExpired
	^(GregorianMonthOfYear today) > expirationDate.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:20:23'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:20:23'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:20:23'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:20:23'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:20:23'!
FAILURE!

GregorianMonthOfYear today!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:21:05' prior: 50921202!
isExpired
	^(GregorianMonthOfYear current) > expirationDate.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:21:06'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:21:06'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:21:06'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:21:06'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:21:06'!
FAILURE!

GregorianMonthOfYear current!

GregorianMonthOfYear current > GregorianMonthOfYear current!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:21:40' prior: 50921220!
isExpired
	^GregorianMonthOfYear current > expirationDate.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:21:40'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:21:40'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:21:40'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:21:40'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:21:40'!
FAILURE!

expirationDate!

GregorianMonthOfYear current > expirationDate!

expirationDate!

GregorianMonthOfYear current!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:23:39' prior: 50921240!
isExpired
	| currentMonth |
	currentMonth := GregorianMonthOfYear current.
	^currentMonth > expirationDate.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:23:41'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:23:41'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:23:41'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:23:42'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:23:42'!
FAILURE!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:23:48'!
FAILURE!

GregorianMonthOfYear current > GregorianMonthOfYear current!

GregorianMonthOfYear current > GregorianMonthOfYear aprilOf: 20.!

GregorianMonthOfYear aprilOf: 20!

GregorianMonthOfYear current > GregorianMonthOfYear aprilOf: 20!

GregorianMonthOfYear current > (GregorianMonthOfYear aprilOf: 20)!

GregorianMonthOfYear current < (GregorianMonthOfYear aprilOf: 20)!

(GregorianMonthOfYear current) < (GregorianMonthOfYear aprilOf: 20)!

aGregorianMonth year !

aGregorianMonth year !

year!

year!

year!

(GregorianMonthOfYear current) < (GregorianMonthOfYear aprilOf: (GregorianYear createYear: 2020) )!

(GregorianMonthOfYear current) < (GregorianMonthOfYear aprilOf: (GregorianYear createYear: 2020) )!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:27:35' prior: 50921103 overrides: 16927572!
setUp
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.
	anExpiredCreditCard := CreditCard withExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2020) month: May). ! !

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:27:36'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:27:36'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:27:36'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:27:36'!
PASSED!

!methodRemoval: Cashier class #for: stamp: 'FC 11/19/2020 19:28:00'!
for: aCart 
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	^self new initializeFor: aCart.!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/19/2020 19:28:29'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice invalidBook aCatalog anExpiredCreditCard aValidCreditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:28:28' prior: 50921303 overrides: 16927572!
setUp
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.
	anExpiredCreditCard := CreditCard withExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2020) month: May). 
	aValidCreditCard := CreditCard withExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2022) month: May). ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:28:42' prior: 50920611!
test01
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart using: aValidCreditCard ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:28:49' prior: 50920875!
test02
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard .
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/19/2020 19:28:56' prior: 50921012!
test03
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard .
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
! !

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:28:57'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 19:28:57'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 19:28:57'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 19:28:57'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 19:28:57'!
PASSED!

----SNAPSHOT----(19 November 2020 19:29:46) CuisUniversity-4383.image priorSource: 18840156!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/19/2020 20:02:42'!
PASSED!

----SNAPSHOT----(19 November 2020 20:20:02) CuisUniversity-4383.image priorSource: 18872197!

----SNAPSHOT----(19 November 2020 21:38:04) CuisUniversity-4383.image priorSource: 18873371!

----QUIT----(19 November 2020 21:38:08) CuisUniversity-4383.image priorSource: 18873465!

----STARTUP---- (21 November 2020 16:50:02) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!classDefinition: #CreditCard category: 'TusLibros' stamp: 'FC 11/21/2020 16:50:58'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate ownerName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'FC 11/21/2020 16:50:59'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate ownerName cardNumber'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:50:56'!
initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	ownerName = aName.
	cardNumber = aCardNumber.
	expirationDate := aMonthOfYear.! !

!methodRemoval: CreditCard #initializeWithExpirationDate: stamp: 'FC 11/21/2020 16:51:02'!
initializeWithExpirationDate: aMonthOfYear
	expirationDate := aMonthOfYear.!
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:51:53'!
withOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	self validateName: aName.
	self validateCardNumber: aCardNumber.
	^self new initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear! !

52123 digitLength.!

52123 size!
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:56:27' prior: 50921484!
withOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	aName size = 0 ifTrue: [self error: self emptyNameMessage].
	aCardNumber size < 16 ifTrue: [self error: self invalidCardNumberMessage ].
	^self new initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:56:41'!
validateCardNumber: aCardNumber

	^ aCardNumber size < 16 ifTrue: [self error: self invalidCardNumberMessage ]! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:56:41' prior: 50921496!
withOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	aName size = 0 ifTrue: [self error: self emptyNameMessage].
	self validateCardNumber: aCardNumber.
	^self new initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:56:50'!
validateOwnerName: aName

	^ aName size = 0 ifTrue: [self error: self emptyNameMessage]! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:56:50' prior: 50921515!
withOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	self validateOwnerName: aName.
	self validateCardNumber: aCardNumber.
	^self new initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:57:06'!
emptyNameMessage
	^'Name can not be empty'.! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:57:22'!
invalidCardNumberMessage
	^'Card number is invalid'.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 16:58:40' prior: 50921345 overrides: 16927572!
setUp
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.
	anExpiredCreditCard := CreditCard withOwner: 'Felipe Curti' Number: '4555123490908765'  ExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2020) month: May). 
	aValidCreditCard := CreditCard withOwner: 'Tinchoni' Number: '4554623490908765'  ExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2022) month: May). ! !

!testRun: #CashierTest #test01 stamp: 'FC 11/21/2020 16:58:41'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/21/2020 16:58:41'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/21/2020 16:58:41'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/21/2020 16:58:41'!
PASSED!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'FC 11/21/2020 17:00:31'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice invalidBook aCatalog anExpiredCreditCard aValidCreditCard aMerchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:00:23'!
test05
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor .
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	self assert: aMerchantProcessor amountBilled equals: total.
	
! !

Object subclass: #MerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #MerchantProcessorDouble category: 'TusLibros' stamp: 'FC 11/21/2020 17:00:59'!
Object subclass: #MerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

MerchantProcessorDouble subclass: #ValidTransactionMerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #ValidTransactionMerchantProcessorDouble category: 'TusLibros' stamp: 'FC 11/21/2020 17:01:14'!
MerchantProcessorDouble subclass: #ValidTransactionMerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

MerchantProcessorDouble subclass: #InsufficientFundsMerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InsufficientFundsMerchantProcessorDouble category: 'TusLibros' stamp: 'FC 11/21/2020 17:01:33'!
MerchantProcessorDouble subclass: #InsufficientFundsMerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

MerchantProcessorDouble subclass: #ValidTransactionMerchantProcessorDouble
	instanceVariableNames: 'billedAmount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #ValidTransactionMerchantProcessorDouble category: 'TusLibros' stamp: 'FC 11/21/2020 17:01:49'!
MerchantProcessorDouble subclass: #ValidTransactionMerchantProcessorDouble
	instanceVariableNames: 'billedAmount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!ValidTransactionMerchantProcessorDouble methodsFor: 'nil' stamp: 'FC 11/21/2020 17:04:48'!
debit: anAmount for: aCreditCard
	billedAmount = anAmount.! !
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/21/2020 17:06:47'!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor.
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor.! !

!methodRemoval: Cashier class #for:using: stamp: 'FC 11/21/2020 17:07:06'!
for: aCart using: aCreditCard
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart.!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'FC 11/21/2020 17:07:29'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'FC 11/21/2020 17:07:30'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard merchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:07:27'!
initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor.
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.! !

!methodRemoval: Cashier #initializeFor: stamp: 'FC 11/21/2020 17:07:34'!
initializeFor: aCart
	cart := aCart.!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:07:54' prior: 50921365!
test01
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:08:06' prior: 50921374!
test02
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:08:14' prior: 50921385!
test03
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor .
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:08:15' prior: 50921742!
test03
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:08:29' prior: 50921189!
test04
	| aCart |
	
	aCart := Cart withCatalog: aCatalog .
	aCart add: 1 copiesOf: aBook.
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard withMerchantProcessor: aMerchantProcessor] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:08:37' prior: 50921595!
test05
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	self assert: aMerchantProcessor amountBilled equals: total.
	
! !

!testRun: #CashierTest #test05 stamp: 'FC 11/21/2020 17:08:38'!
ERROR!
!ValidTransactionMerchantProcessorDouble methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:08:54' prior: 50921665!
debit: anAmount for: aCreditCard
	billedAmount := anAmount.! !
!ValidTransactionMerchantProcessorDouble methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:09:03'!
billedAmount
	^billedAmount.! !
!InsufficientFundsMerchantProcessorDouble methodsFor: 'no messages' stamp: 'FC 11/21/2020 17:09:36'!
debit: anAmount for: aCreditCard
	self error: Cashier insufficientFundsMessage.! !
!Cashier class methodsFor: 'error' stamp: 'FC 11/21/2020 17:10:02'!
insufficientFundsMessage
	^'Card has insufficient funds'! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:10:41' prior: 50921004!
checkOut
	| total catalog |
	catalog := cart catalog.
	total := 0.
	cart listBooks do: [ :aBook | total := total + catalog at: aBook ].
	
	merchantProcessor debit: total for: creditCard.
	
	^ total.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/21/2020 17:10:43'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/21/2020 17:10:43'!
ERROR!

!testRun: #CashierTest #test03 stamp: 'FC 11/21/2020 17:10:43'!
ERROR!

!testRun: #CashierTest #test04 stamp: 'FC 11/21/2020 17:10:43'!
PASSED!

!testRun: #CashierTest #test05 stamp: 'FC 11/21/2020 17:10:43'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'FC 11/21/2020 17:10:47'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:11:09' prior: 50921553 overrides: 16927572!
setUp
	aBook := 'Librito'.
	aBookPrice := 20.
	anotherBook := 'Design Patterns'.
	anotherBookPrice :=  500.
	invalidBook := 'Computer Networks: A systems approach'.
	aCatalog := Dictionary new.
	aCatalog add: aBook->aBookPrice; add: anotherBook->anotherBookPrice.
	anExpiredCreditCard := CreditCard withOwner: 'Felipe Curti' Number: '4555123490908765'  ExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2020) month: May). 
	aValidCreditCard := CreditCard withOwner: 'Tinchoni' Number: '4554623490908765'  ExpirationDate: (GregorianMonthOfYear year: (GregorianYear createYear: 2022) month: May). 
	aMerchantProcessor := ValidTransactionMerchantProcessorDouble new.! !

!testRun: #CashierTest #test01 stamp: 'FC 11/21/2020 17:11:10'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/21/2020 17:11:10'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/21/2020 17:11:10'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/21/2020 17:11:10'!
PASSED!

!testRun: #CashierTest #test05 stamp: 'FC 11/21/2020 17:11:10'!
ERROR!

!testRun: #CashierTest #test05 stamp: 'FC 11/21/2020 17:11:10'!
ERROR!
!ValidTransactionMerchantProcessorDouble methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:11:24'!
amountBilled
	^billedAmount.! !

!methodRemoval: ValidTransactionMerchantProcessorDouble #billedAmount stamp: 'FC 11/21/2020 17:11:25'!
billedAmount
	^billedAmount.!

!testRun: #CashierTest #test01 stamp: 'FC 11/21/2020 17:11:28'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/21/2020 17:11:28'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/21/2020 17:11:28'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/21/2020 17:11:28'!
PASSED!

!testRun: #CashierTest #test05 stamp: 'FC 11/21/2020 17:11:28'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:12:17'!
test06
	| aCart aCashier anInvalidTransactionMerchantProcessor |
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: anInvalidTransactionMerchantProcessor.
	
	self should: [aCashier checkOut] raise: Error withMessageText: Cashier insufficientFundsMessage.
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/21/2020 17:12:44' prior: 50921902!
test06
	| aCart aCashier anInvalidTransactionMerchantProcessor |
	
	aCart := Cart withCatalog: aCatalog .
	
	anInvalidTransactionMerchantProcessor := InsufficientFundsMerchantProcessorDouble new.
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: anInvalidTransactionMerchantProcessor.
	
	self should: [aCashier checkOut] raise: Error withMessageText: Cashier insufficientFundsMessage.
	! !

!testRun: #CashierTest #test06 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!

!testRun: #CashierTest #test05 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!

!testRun: #CashierTest #test06 stamp: 'FC 11/21/2020 17:12:44'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:14:11'!
test01CanNotCheckOutEmptyCart
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
! !

!methodRemoval: CashierTest #test01 stamp: 'FC 11/21/2020 17:14:13'!
test01
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:14:33'!
test02checkOutReturnsTotalPrice
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !

!methodRemoval: CashierTest #test02 stamp: 'FC 11/21/2020 17:14:36'!
test02
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:14:44'!
test02checkOutReturnsTotalPriceOfOneItem
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !

!methodRemoval: CashierTest #test02checkOutReturnsTotalPrice stamp: 'FC 11/21/2020 17:14:46'!
test02checkOutReturnsTotalPrice
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:14:58'!
test03checkOutReturnsTotalPriceOfManyItems
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
! !

!methodRemoval: CashierTest #test03 stamp: 'FC 11/21/2020 17:15:00'!
test03
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:15:16'!
test04CanNotCheckoutWithExpiredCard
	| aCart |
	
	aCart := Cart withCatalog: aCatalog .
	aCart add: 1 copiesOf: aBook.
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard withMerchantProcessor: aMerchantProcessor] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	! !

!methodRemoval: CashierTest #test04 stamp: 'FC 11/21/2020 17:15:17'!
test04
	| aCart |
	
	aCart := Cart withCatalog: aCatalog .
	aCart add: 1 copiesOf: aBook.
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard withMerchantProcessor: aMerchantProcessor] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:15:27'!
test05ValidTransactionGetsBilledCorrectly
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	self assert: aMerchantProcessor amountBilled equals: total.
	
! !

!methodRemoval: CashierTest #test05 stamp: 'FC 11/21/2020 17:15:29'!
test05
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	self assert: aMerchantProcessor amountBilled equals: total.
	
!
!CashierTest methodsFor: 'tests' stamp: 'FC 11/21/2020 17:15:56'!
test06CanNotCheckoutWithCardWithInsufficientFunds
	| aCart aCashier anInvalidTransactionMerchantProcessor |
	
	aCart := Cart withCatalog: aCatalog .
	
	anInvalidTransactionMerchantProcessor := InsufficientFundsMerchantProcessorDouble new.
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: anInvalidTransactionMerchantProcessor.
	
	self should: [aCashier checkOut] raise: Error withMessageText: Cashier insufficientFundsMessage.
	! !

!methodRemoval: CashierTest #test06 stamp: 'FC 11/21/2020 17:16:01'!
test06
	| aCart aCashier anInvalidTransactionMerchantProcessor |
	
	aCart := Cart withCatalog: aCatalog .
	
	anInvalidTransactionMerchantProcessor := InsufficientFundsMerchantProcessorDouble new.
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: anInvalidTransactionMerchantProcessor.
	
	self should: [aCashier checkOut] raise: Error withMessageText: Cashier insufficientFundsMessage.
	!
!MerchantProcessorDouble methodsFor: 'no messages' stamp: 'FC 11/21/2020 17:17:59'!
debit: anAmount for: aCreditCard
	self subclassResponsibility.! !

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/21/2020 17:18:06'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/21/2020 17:18:06'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/21/2020 17:18:06'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/21/2020 17:18:06'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/21/2020 17:18:06'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/21/2020 17:18:06'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/21/2020 17:18:08'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/21/2020 17:18:08'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/21/2020 17:18:08'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/21/2020 17:18:08'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/21/2020 17:18:08'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/21/2020 17:18:08'!
PASSED!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/21/2020 17:18:11'!
PASSED!

!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/21/2020 17:19:15'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/21/2020 17:19:16'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/21/2020 17:19:16'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/21/2020 17:19:16'!
PASSED!

----SNAPSHOT----(21 November 2020 17:19:42) CuisUniversity-4383.image priorSource: 18873559!

----QUIT----(21 November 2020 17:19:46) CuisUniversity-4383.image priorSource: 18898883!

----STARTUP---- (21 November 2020 17:23:06) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!testRun: #CartTest #test01newCartShouldBeEmpty stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test02canAddOneCopyOfValidBook stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test03canAddOneCopyOfManyValidBooks stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test04canNotAddCopiesOfBookNotInCatalog stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test05canNotAddNegativeCopiesOfABook stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test06canNotAddZeroCopiesOfABook stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test07canAddMultipleCopiesOfOneValidBook stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CartTest #test08canNotAddNonIntegerCopiesOfABook stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/21/2020 17:23:22'!
PASSED!

----QUIT----(21 November 2020 17:29:34) CuisUniversity-4383.image priorSource: 18898977!

----STARTUP---- (26 November 2020 20:33:00) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!

!Cashier methodsFor: 'initialization' stamp: 'FC 11/26/2020 20:36:50' prior: 50921707!
initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.! !
!Cashier methodsFor: 'initialization' stamp: 'FC 11/26/2020 20:37:19'!
initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook 
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:37:19' prior: 50921670!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor.
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new.! !

!methodRemoval: Cashier #initializeFor:using:withMerchantProcessor: stamp: 'FC 11/26/2020 20:37:19'!
initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'FC 11/26/2020 20:37:29'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard merchantProcessor salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'FC 11/26/2020 20:37:28' prior: 50922310!
initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook 
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.
	salesBook = aSalesBook.! !
!Cashier methodsFor: 'initialization' stamp: 'FC 11/26/2020 20:37:34' prior: 50922351!
initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook 
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.
	salesBook := aSalesBook.! !
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/26/2020 20:37:46' prior: 50922320!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new.! !

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/26/2020 20:37:55'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/26/2020 20:37:55'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/26/2020 20:37:55'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/26/2020 20:37:55'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/26/2020 20:37:55'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/26/2020 20:37:55'!
PASSED!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/26/2020 20:38:27' prior: 50922371!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: 1.! !
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/26/2020 20:39:07'!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook 
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: 1.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:39:07' prior: 50922064!
test05ValidTransactionGetsBilledCorrectly
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	self assert: aMerchantProcessor amountBilled equals: total.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:39:07' prior: 50922092!
test06CanNotCheckoutWithCardWithInsufficientFunds
	| aCart aCashier anInvalidTransactionMerchantProcessor |
	
	aCart := Cart withCatalog: aCatalog .
	
	anInvalidTransactionMerchantProcessor := InsufficientFundsMerchantProcessorDouble new.
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: anInvalidTransactionMerchantProcessor registeringOn: OrderedCollection new.
	
	self should: [aCashier checkOut] raise: Error withMessageText: Cashier insufficientFundsMessage.
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:39:07' prior: 50921950!
test01CanNotCheckOutEmptyCart
	| aCart |
	
	aCart := Cart withCatalog: testCatalog.
	
	self should: [ Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new ] raise: Error withMessageText: Cashier emptyCartMessage.
	
	
	
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:39:07' prior: 50922018!
test03checkOutReturnsTotalPriceOfManyItems
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 2 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice * 2.
	
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:39:07' prior: 50922042!
test04CanNotCheckoutWithExpiredCard
	| aCart |
	
	aCart := Cart withCatalog: aCatalog .
	aCart add: 1 copiesOf: aBook.
	
	
	self should: [Cashier for: aCart using: anExpiredCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new] raise: Error withMessageText: Cashier creditCardExpiredMessage.
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 11/26/2020 20:39:07' prior: 50921993!
test02checkOutReturnsTotalPriceOfOneItem
	| aCart aCashier total|
	
	aCart := Cart withCatalog: aCatalog .
	
	aCart add: 1 copiesOf: aBook.
	
	aCashier := Cashier for: aCart using: aValidCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: OrderedCollection new.
	
	total := aCashier checkOut.
	
	self assert: total equals: aBookPrice.
	
! !

!methodRemoval: Cashier class #for:using:withMerchantProcessor: stamp: 'FC 11/26/2020 20:39:07'!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: 1.!
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/26/2020 20:39:13' prior: 50922420!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook 
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook ! !
!Cashier class methodsFor: 'instance creation' stamp: 'FC 11/26/2020 20:39:15' prior: 50922542!
for: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook 
	
	aCart isEmpty ifTrue: [
		self error: self emptyCartMessage.
	].
	
	aCreditCard isExpired ifTrue: [
		self error: self creditCardExpiredMessage.
	].
	
	^self new initializeFor: aCart using: aCreditCard withMerchantProcessor: aMerchantProcessor registeringOn: aSalesBook.! !

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/26/2020 20:39:15'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/26/2020 20:39:15'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/26/2020 20:39:15'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/26/2020 20:39:15'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/26/2020 20:39:15'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/26/2020 20:39:15'!
PASSED!
!Cashier methodsFor: 'checkOut' stamp: 'FC 11/26/2020 20:39:42' prior: 50921819!
checkOut
	| total catalog |
	catalog := cart catalog.
	total := 0.
	cart listBooks do: [ :aBook | total := total + catalog at: aBook ].
	
	merchantProcessor debit: total for: creditCard.
	
	salesBook add: total.
	
	^ total.! !

!testRun: #CashierTest #test01CanNotCheckOutEmptyCart stamp: 'FC 11/26/2020 20:39:44'!
PASSED!

!testRun: #CashierTest #test02checkOutReturnsTotalPriceOfOneItem stamp: 'FC 11/26/2020 20:39:44'!
PASSED!

!testRun: #CashierTest #test03checkOutReturnsTotalPriceOfManyItems stamp: 'FC 11/26/2020 20:39:44'!
PASSED!

!testRun: #CashierTest #test04CanNotCheckoutWithExpiredCard stamp: 'FC 11/26/2020 20:39:44'!
PASSED!

!testRun: #CashierTest #test05ValidTransactionGetsBilledCorrectly stamp: 'FC 11/26/2020 20:39:44'!
PASSED!

!testRun: #CashierTest #test06CanNotCheckoutWithCardWithInsufficientFunds stamp: 'FC 11/26/2020 20:39:44'!
PASSED!

TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:08:37'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:11:27'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'tusLibrosInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/26/2020 21:11:35'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:11:38'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'tusLibrosInterface aCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:11:39'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'tusLibrosInterface aCatalog registeredUsers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:11:49'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'tusLibrosInterface aCatalog registeredUsers aValidUser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:11:52'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'tusLibrosInterface aCatalog registeredUsers aValidUser validUserPassword'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterfaceTest methodsFor: 'nil' stamp: 'FC 11/26/2020 21:11:23'!
test01
	
	| cartId |
	tusLibrosInterface := TusLibrosInterface for: aCatalog withUsers: registeredUsers.
	
	cartId := tusLibrosInterface createCartFor: aValidUser withPassword: validUserPassword.
	
	self assert tusLibrosInterface listCartWithId: cartId isEmpty.
	! !

!classRemoval: #TusLibrosInterface stamp: 'FC 11/26/2020 21:13:06'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #ValidTransactionMerchantProcessorDouble stamp: 'FC 11/26/2020 21:13:06'!
MerchantProcessorDouble subclass: #ValidTransactionMerchantProcessorDouble
	instanceVariableNames: 'billedAmount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InsufficientFundsMerchantProcessorDouble stamp: 'FC 11/26/2020 21:13:06'!
MerchantProcessorDouble subclass: #InsufficientFundsMerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #MerchantProcessorDouble stamp: 'FC 11/26/2020 21:13:07'!
Object subclass: #MerchantProcessorDouble
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'FC 11/26/2020 21:13:07'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate ownerName cardNumber'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'FC 11/26/2020 21:13:07'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard merchantProcessor salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'FC 11/26/2020 21:13:07'!
Object subclass: #Cart
	instanceVariableNames: 'contents catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #TusLibrosInterfaceTest stamp: 'FC 11/26/2020 21:13:08'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'tusLibrosInterface aCatalog registeredUsers aValidUser validUserPassword'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'FC 11/26/2020 21:13:08'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testCatalog aBook aBookPrice anotherBook anotherBookPrice invalidBook aCatalog anExpiredCreditCard aValidCreditCard aMerchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'FC 11/26/2020 21:13:08'!
TestCase subclass: #CartTest
	instanceVariableNames: 'aBook anotherBook invalidBook aCatalog aBookPrice anotherBookPrice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\Iteracion2\TusLibros-33.st----!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 11/26/2020 21:14:11'!
PASSED!

TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/26/2020 21:14:41'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----SNAPSHOT----(26 November 2020 21:38:02) CuisUniversity-4383.image priorSource: 18900616!

----STARTUP---- (27 November 2020 14:46:11) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


----End fileIn of C:\Users\Felip\Downloads\DesignPatterns-Proxy.st----!

----STARTUP---- (29 November 2020 16:38:14) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/29/2020 16:39:57'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterfaceTest methodsFor: 'no messages' stamp: 'FC 11/29/2020 16:39:54' overrides: 16927572!
setUp 

	testObjectsFactory := StoreTestObjectsFactory new.! !

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:44:48'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 16:44:39'!
test01
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'FC 11/29/2020 16:45:47'!
defaultUsers
	^Dictionary new add: 'validUser'->'asasas'.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:46:16'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:46:16'!
ERROR!
!TusLibrosInterface class methodsFor: 'instance creation' stamp: 'FC 11/29/2020 16:46:25'!
forCatalog: aDictionary withUsers: anAssociation through: aTusLibrosInterfaceTest 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeForCatalog: aDictionary withUsers: anAssociation through: aTusLibrosInterfaceTest ! !
!TusLibrosInterface class methodsFor: 'instance creation' stamp: 'FC 11/29/2020 16:47:07' prior: 50923589!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor. ! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:47:10'!
ERROR!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:47:21'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:47:21'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog registeredUsers_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:47:21'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog registeredUsers_CHANGE_ME merchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/29/2020 16:47:21'!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 
	self shouldBeImplemented.
	catalog := aCatalog.
	registeredUsers_CHANGE_ME := registeredUsers.
	merchantProcessor := aMerchantProcessor.! !
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/29/2020 16:47:34' prior: 50923640!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 

	catalog := aCatalog.
	registeredUsers_CHANGE_ME := registeredUsers.
	merchantProcessor := aMerchantProcessor.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:47:35'!
ERROR!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 16:47:51'!
createCartForUser: aString withPassword: aString2 
	self shouldBeImplemented.! !

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:52:18'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog registeredUsers_CHANGE_ME merchantProcessor lastId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:52:20'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog registeredUsers_CHANGE_ME merchantProcessor lastId carts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 16:52:02' prior: 50923663!
createCartForUser: aUser withPassword: aPassword 
	
	| actualPassword cartId |
	actualPassword := registeredUsers_CHANGE_ME at: aUser ifAbsent: [self error: self class invalidUsernameMessage].
	actualPassword = aPassword ifFalse: [self error: self class invalidPasswordMessage].
	
	cartId := lastId + 1.
	lastId := lastId +1.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:52:32'!
ERROR!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 16:53:15'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 16:53:15' prior: 50923651!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 16:53:15' prior: 50923687!
createCartForUser: aUser withPassword: aPassword 
	
	| actualPassword cartId |
	actualPassword := validUsers at: aUser ifAbsent: [self error: self class invalidUsernameMessage].
	actualPassword = aPassword ifFalse: [self error: self class invalidPasswordMessage].
	
	cartId := lastId + 1.
	lastId := lastId +1.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !
!StoreTestObjectsFactory methodsFor: 'authentication' stamp: 'FC 11/29/2020 16:53:49' prior: 50923579!
defaultUsers
	^Dictionary new add: ('validUser'->'asasas').! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:53:50'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 11/29/2020 16:53:50'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:53:50'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:54:01'!
ERROR!
!StoreTestObjectsFactory methodsFor: 'authentication' stamp: 'FC 11/29/2020 16:55:29' prior: 50923740!
defaultUsers
	
	| users |
	users := Dictionary new. 
	users add: ('validUser'->'asasas').
	^users! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:55:32'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 11/29/2020 16:55:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:55:32'!
ERROR!
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/29/2020 16:56:11' prior: 50923714!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:56:12'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:56:12'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:56:23'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:56:23'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:56:26'!
ERROR!
!TusLibrosInterface methodsFor: 'accessing' stamp: 'FC 11/29/2020 16:56:33'!
listCartForId: aSmallInteger 
	self shouldBeImplemented.! !
!Cart methodsFor: 'queries' stamp: 'FC 11/29/2020 16:58:29'!
items
	^items.! !
!TusLibrosInterface methodsFor: 'accessing' stamp: 'FC 11/29/2020 16:58:40' prior: 50923879!
listCartForId: aCartId 
	
	|aCart|
	
	aCart := carts at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	
	^aCart items.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:58:44'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 16:58:53'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:00:29'!
test02
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	self should: [tusLibros createCartForUser: 'validUser' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidPasswordMessage.
	
 	
! !

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:00:33'!
ERROR!
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/29/2020 17:00:42'!
invalidPasswordMessage
	self shouldBeImplemented.! !
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/29/2020 17:00:49' prior: 50923916!
invalidPasswordMessage
	^'Passwor is invalid'.! !

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:00:51'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:00:51'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:00:51'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:01:16'!
test03
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	self should: [tusLibros createCartForUser: 'a' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidUserMessage.
	
 	
! !

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:01:19'!
ERROR!
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/29/2020 17:01:28'!
invalidUserMessage
	self shouldBeImplemented.! !

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:01:40'!
ERROR!
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/29/2020 17:02:23' prior: 50923949!
invalidUserMessage
	^'User not found'.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:02:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:02:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:02:23'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:02:23'!
FAILURE!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:02:37' prior: 50923724!
createCartForUser: aUser withPassword: aPassword 
	
	| actualPassword cartId |
	actualPassword := validUsers at: aUser ifAbsent: [self error: self class invalidUserMessage].
	actualPassword = aPassword ifFalse: [self error: self class invalidPasswordMessage].
	
	cartId := lastId + 1.
	lastId := lastId +1.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:02:37'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:02:37'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:02:37'!
PASSED!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:05:57'!
authenticateUser: aUsername withPassword: aPassword
	
	|actualPassword| 
	actualPassword := validUsers at: aUsername ifAbsent: [self error: self class invalidUserMessage].
	actualPassword = aPassword ifFalse: [self error: self class invalidPasswordMessage].! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:06:32' prior: 50923972!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := lastId + 1.
	lastId := lastId +1.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:06:51' prior: 50924005!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := 
	lastId + 1.
	lastId := lastId +1.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:06:56' prior: 50924016!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := 1.
	lastId + 1.
	lastId := lastId +1.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:07:04'!
getNewId

	lastId + 1.
	lastId := lastId +1! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:07:04' prior: 50924027!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := 1.
	self getNewId.
	
	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:07:13' prior: 50924042!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	carts add: cartId->(Cart acceptingItemsOf: catalog).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/29/2020 17:07:32' prior: 50924037!
getNewId

	lastId := lastId +1.
	^lastId! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:07:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:07:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:07:33'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:09:37'!
test04
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 copiesOf: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:10:13' prior: 50924075!
test04
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:10:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:10:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:10:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:10:19'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:10:19'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:10:20'!
ERROR!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:10:28'!
addToCart: aSmallInteger of: aString forId: aSmallInteger3 
	self shouldBeImplemented.! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:13:00' prior: 50924122!
addToCart: aQuantity of: aBook forId: aCartId
	
	| aCart |
	aCart := carts at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	
	aCart add: aQuantity of: aBook.
	
	! !

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:13:06'!
FAILURE!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:13:29' prior: 50924091!
test04
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .! !

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:13:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:13:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:13:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:13:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:13:30'!
PASSED!
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/29/2020 17:13:56'!
cartNotFoundMessage
	^'Cart not found'.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:13:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:13:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:13:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:13:56'!
PASSED!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:14:18' prior: 50924128!
addToCart: aQuantity of: aBook forId: aCartId
	
	| aCart |
	aCart := 0
	carts at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	
	aCart add: aQuantity of: aBook.
	
	! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:14:19' prior: 50924185!
addToCart: aQuantity of: aBook forId: aCartId
	
	| aCart |
	aCart := 0.
	carts at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	
	aCart add: aQuantity of: aBook.
	
	! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:14:29'!
getCartAt: aCartId

	^ carts at: aCartId ifAbsent: [self error: self class cartNotFoundMessage]! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:14:29' prior: 50924194!
addToCart: aQuantity of: aBook forId: aCartId
	
	| aCart |
	aCart := 0.
	self getCartAt: aCartId.
	
	aCart add: aQuantity of: aBook.
	
	! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/29/2020 17:14:35' prior: 50924209!
addToCart: aQuantity of: aBook forId: aCartId
	
	| aCart |
	aCart := 	self getCartAt: aCartId.
	
	aCart add: aQuantity of: aBook.
	
	! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:14:36'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:14:36'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:14:36'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:14:36'!
PASSED!
!TusLibrosInterface methodsFor: 'accessing' stamp: 'FC 11/29/2020 17:15:00' prior: 50923887!
listCartForId: aCartId 
	
	|aCart|
	
	aCart := aCart := 	self getCartAt: aCartId.
	
	^aCart items.! !
!TusLibrosInterface methodsFor: 'accessing' stamp: 'FC 11/29/2020 17:15:03' prior: 50924235!
listCartForId: aCartId 
	
	|aCart|
	
	aCart := 	self getCartAt: aCartId.
	
	^aCart items.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:15:03'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:15:03'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:15:03'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:15:03'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:16:28'!
test05
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 2 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:17:05' prior: 50924259!
test05
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 2 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .
	self assert: ((tusLibros listCartForId: cartId) occurrencesOf: testObjectsFactory itemSellByTheStore) equals: 2 .! !

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:17:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:17:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:17:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:17:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:17:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:17:05'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:17:25' prior: 50924277!
test05
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 2 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .
	self assert: ((tusLibros listCartForId: cartId) occurrencesOf: testObjectsFactory itemSellByTheStore) equals: 2.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:18:29'!
test06
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	
	self should: [tusLibros listCartForId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:18:33'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:20:23'!
test07
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	
	self should: [tusLibros addToCart: 1 of: testObjectsFactory itemNotSellByTheStore forId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:20:24'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:24:33'!
test08
	
	|cartId tusLibros total |
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	self assert: total equals: testObjectsFactory itemSellByTheStorePrice.! !
!TusLibrosInterface class methodsFor: 'instance creation' stamp: 'FC 11/29/2020 17:24:50' prior: 50923602!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor. ! !
!TusLibrosInterface class methodsFor: 'instance creation' stamp: 'FC 11/29/2020 17:25:18'!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook  

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor. ! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50923900!
test02
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'validUser' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidPasswordMessage.
	
 	
! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50923566!
test01
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50924366!
test07
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros addToCart: 1 of: testObjectsFactory itemNotSellByTheStore forId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50924335!
test06
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros listCartForId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50924314!
test05
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 2 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .
	self assert: ((tusLibros listCartForId: cartId) occurrencesOf: testObjectsFactory itemSellByTheStore) equals: 2.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50924401!
test08
	
	|cartId tusLibros total |
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	self assert: total equals: testObjectsFactory itemSellByTheStorePrice.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50924140!
test04
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:25:18' prior: 50923934!
test03
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'a' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidUserMessage.
	
 	
! !

!methodRemoval: TusLibrosInterface class #forCatalog:withUsers:through: stamp: 'FC 11/29/2020 17:25:18'!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor. !
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/29/2020 17:26:03'!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.! !
!TusLibrosInterface class methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:26:03' prior: 50924430!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook  

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook. ! !

!methodRemoval: TusLibrosInterface #initializeForCatalog:withUsers:through: stamp: 'FC 11/29/2020 17:26:03'!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor 

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 17:26:22'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/29/2020 17:26:17' prior: 50924584!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	salesBook := aSalesBook.! !

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:27:06'!
ERROR!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/29/2020 17:27:16'!
checkOutCartId: aSmallInteger payingWith: aCreditCard 
	self shouldBeImplemented.! !
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/29/2020 17:28:39' prior: 50924640!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: 1  registeringOn: salesBook.! !

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:28:51'!
ERROR!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/29/2020 17:29:48' prior: 50924646!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: GregorianDate today registeringOn: salesBook.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:29:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:29:53'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:29:53'!
ERROR!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 11/29/2020 17:30:14'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 11/29/2020 17:30:14'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 11/29/2020 17:30:14'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 11/29/2020 17:30:14'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 11/29/2020 17:30:14'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 11/29/2020 17:30:14'!
PASSED!
!TusLibrosInterface class methodsFor: 'instance creation' stamp: 'FC 11/29/2020 17:32:09'!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook. ! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924542!
test04
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924499!
test05
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 2 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .
	self assert: ((tusLibros listCartForId: cartId) occurrencesOf: testObjectsFactory itemSellByTheStore) equals: 2.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924440!
test02
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'validUser' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidPasswordMessage.
	
 	
! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924561!
test03
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'a' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidUserMessage.
	
 	
! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924470!
test07
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros addToCart: 1 of: testObjectsFactory itemNotSellByTheStore forId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924455!
test01
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924521!
test08
	
	|cartId tusLibros total |
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	self assert: total equals: testObjectsFactory itemSellByTheStorePrice.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:32:09' prior: 50924485!
test06
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros listCartForId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !

!methodRemoval: TusLibrosInterface class #forCatalog:withUsers:through:registeringOn: stamp: 'FC 11/29/2020 17:32:09'!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook  

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook. !

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/29/2020 17:32:33'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/29/2020 17:32:31' prior: 50924659!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDate registeringOn: salesBook.! !
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/29/2020 17:33:03'!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	salesBook := aSalesBook.
	currentDate := aDate.! !

!methodRemoval: TusLibrosInterface #initializeForCatalog:withUsers:through:registeringOn: stamp: 'FC 11/29/2020 17:33:08'!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	salesBook := aSalesBook.!
!TusLibrosInterface class methodsFor: 'instance creation' stamp: 'FC 11/29/2020 17:33:18' prior: 50924714!
forCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	^self new initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook. ! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:33:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:33:19'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:33:19'!
FAILURE!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/29/2020 17:33:43' prior: 50924889!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDate registeringOn: salesBook.
	
	^cashier checkOut.! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:33:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:33:43'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:33:43'!
ERROR!

!classDefinition: #TusLibrosInterfaceTest category: 'TusLibros' stamp: 'FC 11/29/2020 17:34:04'!
TestCase subclass: #TusLibrosInterfaceTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:33:58'!
debit: anAmount from: aCreditCard 

	^debitBehavior value: anAmount value: aCreditCard ! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:34:21' prior: 50923554 overrides: 16927572!
setUp 

	testObjectsFactory := StoreTestObjectsFactory new.
		debitBehavior := [ :anAmount :aCreditCard | ]! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:34:22'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/29/2020 17:34:26' prior: 50925010 overrides: 16927572!
setUp 

	testObjectsFactory := StoreTestObjectsFactory new.
	debitBehavior := [ :anAmount :aCreditCard | ]! !

!testRun: #TusLibrosInterfaceTest #test01 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test05 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08 stamp: 'FC 11/29/2020 17:34:26'!
PASSED!

----SNAPSHOT----(29 November 2020 17:35:01) CuisUniversity-4383.image priorSource: 18935489!

----SNAPSHOT----(29 November 2020 17:35:03) CuisUniversity-4383.image priorSource: 18989293!

----SNAPSHOT----(29 November 2020 17:35:04) CuisUniversity-4383.image priorSource: 18989387!

----QUIT----(29 November 2020 17:35:06) CuisUniversity-4383.image priorSource: 18989481!

----STARTUP---- (30 November 2020 18:10:16) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


GregorianDateTime now.!

Object subclass: #TimeSimulator
	instanceVariableNames: 'currentDateTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TimeSimulator category: 'TusLibros' stamp: 'FC 11/30/2020 18:19:27'!
Object subclass: #TimeSimulator
	instanceVariableNames: 'currentDateTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TimeSimulator class methodsFor: 'no messages' stamp: 'FC 11/30/2020 18:22:18'!
startingAt: aDateTime
	^self new initializeStartingAt: aDateTime.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:22:55'!
test01InterfaceCreatesEmptyCart
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !

!methodRemoval: TusLibrosInterfaceTest #test01 stamp: 'FC 11/30/2020 18:22:55'!
test01
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:23:21'!
test02CanNotCreateCartWithInvalidPassword
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'validUser' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidPasswordMessage.
	
 	
! !

!methodRemoval: TusLibrosInterfaceTest #test02 stamp: 'FC 11/30/2020 18:23:21'!
test02
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'validUser' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidPasswordMessage.
	
 	
!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:23:51'!
test03CanNotCreateCartWithInvalidUsername
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'a' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidUserMessage.
	
 	
! !

!methodRemoval: TusLibrosInterfaceTest #test03 stamp: 'FC 11/30/2020 18:23:51'!
test03
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'a' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidUserMessage.
	
 	
!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:24:43'!
test04InterfaceListsOneItem
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .! !

!methodRemoval: TusLibrosInterfaceTest #test04 stamp: 'FC 11/30/2020 18:24:43'!
test04
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .!

!methodRemoval: TusLibrosInterfaceTest #test05 stamp: 'FC 11/30/2020 18:25:02'!
test05
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 2 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .
	self assert: ((tusLibros listCartForId: cartId) occurrencesOf: testObjectsFactory itemSellByTheStore) equals: 2.!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:25:17'!
test06CanNotListInvalidCart
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros listCartForId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !

!methodRemoval: TusLibrosInterfaceTest #test06 stamp: 'FC 11/30/2020 18:25:17'!
test06
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros listCartForId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:25:29'!
test07CanNotAddToInvalidCart
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros addToCart: 1 of: testObjectsFactory itemNotSellByTheStore forId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !

!methodRemoval: TusLibrosInterfaceTest #test07 stamp: 'FC 11/30/2020 18:25:29'!
test07
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros addToCart: 1 of: testObjectsFactory itemNotSellByTheStore forId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:26:07'!
test08CheckOutReturnsTotal
	
	|cartId tusLibros total |
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	self assert: total equals: testObjectsFactory itemSellByTheStorePrice.! !

!methodRemoval: TusLibrosInterfaceTest #test08 stamp: 'FC 11/30/2020 18:26:07'!
test08
	
	|cartId tusLibros total |
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	self assert: total equals: testObjectsFactory itemSellByTheStorePrice.!
!TimeSimulator methodsFor: 'no messages' stamp: 'FC 11/30/2020 18:26:44'!
initializeStartingAt: aDateTime
	currentDateTime := aDateTime.! !
!TimeSimulator methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:27:11'!
now
	currentDateTime.! !
!TimeSimulator methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:27:19' prior: 50925358!
now
	^currentDateTime.! !
!TimeSimulator methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:28:24'!
passTime: anInterval.
	currentDateTime := currentDateTime + anInterval.! !

!testRun: #GregorianMonthTest #testApril stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testAugust stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testComma stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testCommonMonthsMeasure stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testCurrent stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testDayOfMonthCreation stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testDecember stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testDivisionSymbolCanBeUseToCreateADayOfMonth stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testFebruary stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testGlobalVariables stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIdentity stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsApril stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsAugust stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsDecember stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsFebruary stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsJanuary stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsJuly stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsJune stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsMarch stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsMay stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsNovember stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsOctober stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testIsSeptember stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testJanuary stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testJuly stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testJune stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testLastDayOfMonth stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testMarch stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testMay stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testMonthCreation stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsFrom stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsTo stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testNamed stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testNextInANumberOfMonths stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testNovember stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testNumberOfMonthsPerYear stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testOctober stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testOf stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testOfYear stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testPreviousInANumberOfMonths stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testSeptember stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testTo stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testToBy stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testToByDo stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testToReverse stamp: 'FC 11/30/2020 18:29:13'!
PASSED!

!testRun: #GregorianMonthTest #testApril stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testAugust stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testComma stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testCommonMonthsMeasure stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testCurrent stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testDayOfMonthCreation stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testDecember stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testDivisionSymbolCanBeUseToCreateADayOfMonth stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testFebruary stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testGlobalVariables stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIdentity stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsApril stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsAugust stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsDecember stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsFebruary stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsJanuary stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsJuly stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsJune stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsMarch stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsMay stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsNovember stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsOctober stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testIsSeptember stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testJanuary stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testJuly stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testJune stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testLastDayOfMonth stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testMarch stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testMay stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testMonthCreation stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsFrom stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsTo stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testNamed stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testNextInANumberOfMonths stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testNovember stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testNumberOfMonthsPerYear stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testOctober stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testOf stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testOfYear stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testPreviousInANumberOfMonths stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testSeptember stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testTo stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testToBy stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testToByDo stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #GregorianMonthTest #testToReverse stamp: 'FC 11/30/2020 18:29:16'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #test29OfFebruaryToEveryDayOfMonth stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testAsSmalltalkDate stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testAt stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtMidnight stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtNoon stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtTimeOfDay stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testCreation stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testDay stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testDayNumber stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testDayOfMonth stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testDaysFrom stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testDaysTo stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testEqual stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testHash stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testImmutableValue stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesDate stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesDateTime stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesMonthOfYear stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesYear stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsApril stamp: 'FC 11/30/2020 18:29:20'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsAugust stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsDecember stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFebruary stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFirstDayOfYear stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFriday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJanuary stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJuly stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJune stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsLastDayOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsLastDayOfYear stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMarch stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMonday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsNovember stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsOctober stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSaturday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSeptember stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSunday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsThursday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsTuesday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsWednesday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testLessThan stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testMonthOfYear stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNext stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextDay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextDayOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextInNumberOfDays stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextInWeeks stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromBaseDate stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromBeginningOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysToEndOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysToEndOfYear stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testPrevious stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousDay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousDayOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousInNumberOfDays stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousInWeeks stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testPrintString stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testTheBeginningAndTheEndOfTime stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testTo stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToBy stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToByDo stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToByReverse stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryBeginningDifferentDay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryBeginningSameDay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayBeginningDifferentDay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayBeginningSameDay stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayNumber stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayNumbers stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayOfMonth stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testTomorrow stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testVisitorAccessing stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testYear stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #FixedGregorianDateTest #testYesterday stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #GregorianDateTimeTest #testAccessing stamp: 'FC 11/30/2020 18:29:21'!
PASSED!

!testRun: #GregorianDateTimeTest #testAdd stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testComparing stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testFirstTimeOfDay stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testHash stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testLastTimeOfDay stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testLessThan stamp: 'FC 11/30/2020 18:29:22'!
PASSED!

!testRun: #GregorianDateTimeTest #testNow stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testPrintString stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testReverse stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testSameDateAs stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testSameTimeOfDayAs stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testSpecialDateTimes stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testSubtract stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeFrom stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeFromMidnight stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeTo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeToEndOfDay stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testTo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testToBy stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testToByDo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testToByMinutesDo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testWithDay stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDateTimeTest #testWithDayOfMonth stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testComma stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testComparing stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testCreation stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDateOfYear stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDaysFrom stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDaysTo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDivisionSymbolCanBeUseToCreateADate stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testHash stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsFirstDayOfYear stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsLastDayOfMonth stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsLastDayOfYear stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNext stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNextANumberOfDays stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysFromBeginningOfMonth stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysToEndOfMonth stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysToEndOfYear stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPreviousANumberOfDays stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testTo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToBy stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToByDo stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToEveryDayNumber stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToEveryDayNumbers stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:23'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToReverse stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testCommonDaysMeasure stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testDayCreation stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testDayPositionedInWeek stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testDays stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testDaysFrom stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testDaysTo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testEqual stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testGlobalVariables stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testInvalidNameCreation stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsFriday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsMonday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsSaturday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsSunday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsThursday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsTuesday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testIsWednesday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testName stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testNext stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testNextInANumberOfDays stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testNumberOfDaysSinceSunday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testPrevious stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testPreviousInANumberOfDays stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testPrintString stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testSinceSunday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testTo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testToBy stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testToDo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianDayTest #testToday stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCardinalDay stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCreation stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCurrent stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testDates stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testEqual stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testFirstDate stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testFirstDay stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testHash stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesDate stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesDateTime stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesMonthOfYear stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesYear stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDate stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDay stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLessThan stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testMonthsFrom stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testMonthsTo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testName stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNext stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNextANumberOfMonths stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNextMonthDefinedAs stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNumberOfDays stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPrevious stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPreviousANumberOfMonths stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPreviousMonthDefinedAs stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPrintString stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testTo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToBy stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToByDo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToByYearsDo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToReverse stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testApril stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testAugust stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testComma stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testCommonMonthsMeasure stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testCurrent stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testDayOfMonthCreation stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testDecember stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testDivisionSymbolCanBeUseToCreateADayOfMonth stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testFebruary stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testGlobalVariables stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIdentity stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsApril stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsAugust stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsDecember stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsFebruary stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsJanuary stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsJuly stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsJune stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsMarch stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsMay stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsNovember stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsOctober stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testIsSeptember stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testJanuary stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testJuly stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testJune stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testLastDayOfMonth stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testMarch stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testMay stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testMonthCreation stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsFrom stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsTo stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testNamed stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testNextInANumberOfMonths stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testNovember stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testNumberOfMonthsPerYear stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testOctober stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testOf stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testOfYear stamp: 'FC 11/30/2020 18:29:24'!
PASSED!

!testRun: #GregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testPreviousInANumberOfMonths stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testSeptember stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testTo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testToBy stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testToByDo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianMonthTest #testToReverse stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testAccessing stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testAsInterval stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testCanCreateATimespanAfterATimeMeasure stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testCanCreateATimespanBeforeATimeMeasure stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testEqual stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testFromInterval stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testHash stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testPrintString stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianTimespanTest #testTo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testCurrent stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testDates stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testDaysInFebruary stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testDistanceTo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testEqual stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testFirstDate stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testFirstDay stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testFirstMonth stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testHash stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testIncludesDate stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testIncludesDateTime stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testIncludesMonthOfYear stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testIncludesYear stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testInvalidNextANumberOfYears stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testInvalidPreviousANumberOfYears stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testInvalidYear stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testIsLeap stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testLastDate stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testLastDay stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testLastMonth stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testLessThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testMonths stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testMonthsOfYearsAccessing stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testNext stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testNextANumberOfYears stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testNextLeapYear stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testNumber stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testNumberOfDays stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testNumberOfDaysFromBaseDate stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testPrevious stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testPreviousANumberOfYears stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testPreviousLeapYear stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testPrintString stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testTo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testToBy stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testToByDo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testToByReverse stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testYearsFrom stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testYearsTo stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #GregorianYearTest #testZeroYears stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #MoreThanOnePointInTimeIntervalStrategyTest #testIsValidIntervalFromToBy stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testDayOfMonthCreation stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:25'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyOneDaysGregorianMonthTest #testThirtieth stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #ThirtyOneDaysGregorianMonthTest #testThirtyfirst stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testAdd stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCanCreateAsWrittenInEnglish stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCanNotCreateTimeOfDayWithSemiColonWhenReceiverHasSeconds stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testComparing stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCreation stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCreationHour stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCreationMilliseconds stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCreationMinute stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testCreationSecond stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testFirstTimeOfDay stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testHash stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testLastTimeOfDay stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #TimeOfDayTest #testLessThan stamp: 'FC 11/30/2020 18:29:26'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testNow stamp: 'FC 11/30/2020 18:29:27'!
FAILURE!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testOneMillisecond stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testOneSecond stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testPrintString stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testReverse stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testSubtract stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testTimeFrom stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testTimeFromMidnight stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testTimeTo stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testTimeToEndOfDay stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testTo stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testToBy stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testToByDo stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testTwentyFourHours stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testZeroHours stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testAllUnits stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testDay stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testHour stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testMillisecond stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testMinute stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testMonth stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testSecond stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testWeek stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeUnitsTest #testYear stamp: 'FC 11/30/2020 18:29:27'!
PASSED!

!testRun: #TimeOfDayTest #testNow stamp: 'FC 11/30/2020 18:29:28'!
PASSED!
!NonSpecificThirtyOneDaysGregorianMonthTest methodsFor: 'test comparing' stamp: 'FC 11/30/2020 18:29:29' prior: 50749501!
testLessThan

	| month1 month2 |
	
	month1 := NonSpecificThirtyOneDaysGregorianMonth named: 'xxx' number: 1.
	month2 := NonSpecificThirtyOneDaysGregorianMonth named: 'yyy' number:  3.

	self assert: month1 < month2.
	self deny: month2 < month1.! !

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:29'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:29'!
PASSED!
!NonSpecificThirtyOneDaysGregorianMonthTest methodsFor: 'test comparing' stamp: 'FC 11/30/2020 18:29:32' prior: 50926920!
testLessThan

	| month1 month2 |
	
	month1 := NonSpecificThirtyOneDaysGregorianMonth named: 'xxx' number: 1.
	month2 := NonSpecificThirtyOneDaysGregorianMonth named: 'yyy' number:  3.

	self assert: month1 < month2.
	self deny: month2 < month1.! !

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:32'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #test29OfFebruaryToEveryDayOfMonth stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testAsSmalltalkDate stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testAt stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtMidnight stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtNoon stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtTimeOfDay stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testCreation stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testDay stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testDayNumber stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testDayOfMonth stamp: 'FC 11/30/2020 18:29:38'!
PASSED!

!testRun: #FixedGregorianDateTest #testDaysFrom stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testDaysTo stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testEqual stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testHash stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testImmutableValue stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesDate stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesDateTime stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesMonthOfYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsApril stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsAugust stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsDecember stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFebruary stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFirstDayOfYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFriday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJanuary stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJuly stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJune stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsLastDayOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsLastDayOfYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMarch stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMonday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsNovember stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsOctober stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSaturday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSeptember stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSunday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsThursday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsTuesday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsWednesday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testLessThan stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testMonthOfYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNext stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextDayOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextInNumberOfDays stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextInWeeks stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromBaseDate stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromBeginningOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysToEndOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysToEndOfYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testPrevious stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousDayOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousInNumberOfDays stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousInWeeks stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testPrintString stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testTheBeginningAndTheEndOfTime stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testTo stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToBy stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToByDo stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToByReverse stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryBeginningDifferentDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryBeginningSameDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayBeginningDifferentDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayBeginningSameDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayNumber stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayNumbers stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayOfMonth stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testTomorrow stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testVisitorAccessing stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testYear stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #FixedGregorianDateTest #testYesterday stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testAccessing stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testAdd stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testComparing stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testFirstTimeOfDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testHash stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testLastTimeOfDay stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testLessThan stamp: 'FC 11/30/2020 18:29:39'!
PASSED!

!testRun: #GregorianDateTimeTest #testNow stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testPrintString stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testReverse stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testSameDateAs stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testSameTimeOfDayAs stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testSpecialDateTimes stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testSubtract stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeFrom stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeFromMidnight stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeTo stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeToEndOfDay stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testTo stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testToBy stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testToByDo stamp: 'FC 11/30/2020 18:29:40'!
PASSED!

!testRun: #GregorianDateTimeTest #testToByMinutesDo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDateTimeTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDateTimeTest #testWithDay stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDateTimeTest #testWithDayOfMonth stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testComma stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testComparing stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testCreation stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDateOfYear stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDaysFrom stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDaysTo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDivisionSymbolCanBeUseToCreateADate stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testHash stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsFirstDayOfYear stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsLastDayOfMonth stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsLastDayOfYear stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNext stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNextANumberOfDays stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysFromBeginningOfMonth stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysToEndOfMonth stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysToEndOfYear stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPreviousANumberOfDays stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testTo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToBy stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToByDo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToEveryDayNumber stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToEveryDayNumbers stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToReverse stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testCommonDaysMeasure stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testDayCreation stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testDayPositionedInWeek stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testDays stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testDaysFrom stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testDaysTo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testEqual stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testGlobalVariables stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testInvalidNameCreation stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsFriday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsMonday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsSaturday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsSunday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsThursday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsTuesday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testIsWednesday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testName stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testNext stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testNextInANumberOfDays stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testNumberOfDaysSinceSunday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testPrevious stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testPreviousInANumberOfDays stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testPrintString stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testSinceSunday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testTo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testToBy stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testToDo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianDayTest #testToday stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCardinalDay stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCreation stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCurrent stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testDates stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testEqual stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testFirstDate stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testFirstDay stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testHash stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesDate stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesDateTime stamp: 'FC 11/30/2020 18:29:41'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesMonthOfYear stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesYear stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDate stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDay stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLessThan stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testMonthsFrom stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testMonthsTo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testName stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNext stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNextANumberOfMonths stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNextMonthDefinedAs stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNumberOfDays stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPrevious stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPreviousANumberOfMonths stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPreviousMonthDefinedAs stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPrintString stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testTo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToBy stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToByDo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToByYearsDo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToReverse stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testApril stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testAugust stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testComma stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testCommonMonthsMeasure stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testCurrent stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testDayOfMonthCreation stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testDecember stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testDivisionSymbolCanBeUseToCreateADayOfMonth stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testFebruary stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testFirstDayOfMonth stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testGlobalVariables stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIdentity stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsApril stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsAugust stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsDecember stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsFebruary stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsJanuary stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsJuly stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsJune stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsMarch stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsMay stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsNovember stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsOctober stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testIsSeptember stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testJanuary stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testJuly stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testJune stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testLastDayOfMonth stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testMarch stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testMay stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testMonthCreation stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsFrom stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsTo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testNamed stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testNextInANumberOfMonths stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testNovember stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testNumberOfMonthsPerYear stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testOctober stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testOf stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testOfYear stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testPreviousInANumberOfMonths stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testSeptember stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testTo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testToBy stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testToByDo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianMonthTest #testToReverse stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testAccessing stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testAsInterval stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testCanCreateATimespanAfterATimeMeasure stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testCanCreateATimespanBeforeATimeMeasure stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testEqual stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testFromInterval stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testHash stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testPrintString stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianTimespanTest #testTo stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianYearTest #testCurrent stamp: 'FC 11/30/2020 18:29:42'!
PASSED!

!testRun: #GregorianYearTest #testDates stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testDaysInFebruary stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testDistanceTo stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testEqual stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testFirstDate stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testFirstDay stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testFirstMonth stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testHash stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testIncludesDate stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testIncludesDateTime stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testIncludesMonthOfYear stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testIncludesYear stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testInvalidNextANumberOfYears stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testInvalidPreviousANumberOfYears stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testInvalidYear stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testIsLeap stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testLastDate stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testLastDay stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testLastMonth stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testLessThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testMonths stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testMonthsOfYearsAccessing stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testNext stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testNextANumberOfYears stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testNextLeapYear stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testNumberOfDays stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testNumberOfDaysFromBaseDate stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testPrevious stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testPreviousANumberOfYears stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testPreviousLeapYear stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testPrintString stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testTo stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testToBy stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testToByDo stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testToByReverse stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testToNegativeBy stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testYearsFrom stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testYearsTo stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #GregorianYearTest #testZeroYears stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNext stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrevious stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #MoreThanOnePointInTimeIntervalStrategyTest #testIsValidIntervalFromToBy stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testDayOfMonthCreation stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testEqual stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testHash stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLastDayNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLessThan stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLessThanFebruary stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testName stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumber stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testPrintString stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyOneDaysGregorianMonthTest #testThirtieth stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #ThirtyOneDaysGregorianMonthTest #testThirtyfirst stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #TimeOfDayTest #testAdd stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #TimeOfDayTest #testCanCreateAsWrittenInEnglish stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #TimeOfDayTest #testCanNotCreateTimeOfDayWithSemiColonWhenReceiverHasSeconds stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #TimeOfDayTest #testComparing stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #TimeOfDayTest #testCreation stamp: 'FC 11/30/2020 18:29:43'!
PASSED!

!testRun: #TimeOfDayTest #testCreationHour stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testCreationMilliseconds stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testCreationMinute stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testCreationSecond stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testFirstTimeOfDay stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testGreaterThan stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testHash stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testInvalidCreation stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testLastTimeOfDay stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testLessThan stamp: 'FC 11/30/2020 18:29:44'!
PASSED!

!testRun: #TimeOfDayTest #testNow stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testOneMillisecond stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testOneSecond stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testPrintString stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testReverse stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testSubtract stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testTimeFrom stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testTimeFromMidnight stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testTimeTo stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testTimeToEndOfDay stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testTo stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testToBy stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testToByDo stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testToNegativeByDo stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testTwentyFourHours stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeOfDayTest #testZeroHours stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testAllUnits stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testDay stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testHour stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testMillisecond stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testMinute stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testMonth stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testSecond stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testWeek stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

!testRun: #TimeUnitsTest #testYear stamp: 'FC 11/30/2020 18:29:45'!
PASSED!

a := GregorianDateTime now.!

a := GregorianDateTime now.!

a + GregorianDateTime now.!

a + 10 minutes.!

a next: 2.!

a next: 2 days.!

a next: 30 * minute.!

a next: 30 * minute.!

a next: 30 * minute.!

a next: 30 * minute.!

a next: 30 * minute.!

a.!

a..!

a.!

a.!

a next: 30 * minute.!
!TimeSimulator methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:34:10'!
passMinutes: minutes.
	currentDateTime := currentDateTime next: minutes * minute.! !

!methodRemoval: TimeSimulator #passTime: stamp: 'FC 11/30/2020 18:34:18'!
passTime: anInterval.
	currentDateTime := currentDateTime + anInterval.!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:34:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:34:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:34:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:34:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:34:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:34:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:34:42'!
PASSED!

Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 18:37:29'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 18:37:34'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:37:34' prior: 50924960!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDateTime registeringOn: salesBook.
	
	^cashier checkOut.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:37:34' prior: 50924899!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	salesBook := aSalesBook.
	currentDateTime := aDate.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:38:35' prior: 50925099!
test01InterfaceCreatesEmptyCart
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface forCatalog: (testObjectsFactory defaultCatalog) withUsers: (testObjectsFactory defaultUsers) through: self on: testObjectsFactory today registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:38:35'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:38:35'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:39:06' prior: 50928271!
test01InterfaceCreatesEmptyCart
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: testObjectsFactory today 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:39:35' prior: 50928360!
test01InterfaceCreatesEmptyCart
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:39:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:39:41'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:41:07' prior: 50925129!
test02CanNotCreateCartWithInvalidPassword
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'validUser' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidPasswordMessage.
	
 	
! !

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:41:10'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:41:10'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:41:16' prior: 50925160!
test03CanNotCreateCartWithInvalidUsername
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	self should: [tusLibros createCartForUser: 'a' withPassword: 'a'] raise: Error withMessageText: TusLibrosInterface invalidUserMessage.
	
 	
! !

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:41:16'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:41:16'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:41:16'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:41:16'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:41:16'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:41:17'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:41:17'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:41:17'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:41:22' prior: 50925191!
test04InterfaceListsOneItem
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	self assert: (tusLibros listCartForId: cartId) includes: testObjectsFactory itemSellByTheStore .! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:41:26' prior: 50925251!
test06CanNotListInvalidCart
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	self should: [tusLibros listCartForId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:41:30' prior: 50925279!
test07CanNotAddToInvalidCart
	
	|tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	
	self should: [tusLibros addToCart: 1 of: testObjectsFactory itemNotSellByTheStore forId: 1] raise: Error withMessageText: TusLibrosInterface cartNotFoundMessage.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:41:35' prior: 50925311!
test08CheckOutReturnsTotal
	
	|cartId tusLibros total |
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	self assert: total equals: testObjectsFactory itemSellByTheStorePrice.! !

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:41:35'!
ERROR!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/30/2020 18:41:54' prior: 50928245!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDateTime now registeringOn: salesBook.
	
	^cashier checkOut.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:41:55'!
PASSED!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 18:44:02'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 18:44:01' prior: 50924052!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	carts add: cartId->(Cart acceptingItemsOf: catalog).
	cartTimes add: cartId->currentDateTime now.
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:44:14' prior: 50928257!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	cartTimes := Dictionary new.
	salesBook := aSalesBook.
	currentDateTime := aDate.! !

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:44:43'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:44:45'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:44:45'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:45:21'!
test09
	
	|cartId tusLibros|
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:45:43' prior: 50928701!
test09
	
	|cartId tusLibro aTimeSimulators|
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:45:56' prior: 50928718!
test09
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 18:46:47' prior: 50928737!
test09
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 31.
	
	self should: [tusLibros listCartForId: cartId] raise: Error withMessageText: TusLibrosInterface sessionExpiredMessage.! !

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 18:46:51'!
ERROR!

DateAndTime now.!

DateAndTime now + 30*minute.!

DateAndTime now + (30*minute).!

DateAndTime now + DateAndTime now !

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!

DateAndTime now + 15 minutes.!
!TimeSimulator methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:52:45' prior: 50928185!
passMinutes: aTimeInMinutes.
	currentDateTime := currentDateTime next: aTimeInMinutes minutes.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:52:46'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 18:52:46'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 18:52:46'!
ERROR!
!TimeSimulator methodsFor: 'initialization' stamp: 'FC 11/30/2020 18:52:55' prior: 50928794!
passMinutes: aTimeInMinutes.
	currentDateTime := currentDateTime + aTimeInMinutes minutes.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 18:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 18:52:56'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 18:52:56'!
ERROR!
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/30/2020 18:53:03'!
sessionExpiredMessage
	self shouldBeImplemented.! !
!TusLibrosInterface class methodsFor: 'error' stamp: 'FC 11/30/2020 18:53:12' prior: 50928865!
sessionExpiredMessage
	^'Session Expired'.! !

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 18:53:13'!
FAILURE!

DateAndTime now distanceTo: DateAndTime now.!

DateAndTime now - DateAndTime now.!

DateAndTime now minute !

DateAndTime now minute !

DateAndTime now + (Duration minutes: 30)!

DateAndTime now - DateAndTime now.!

DateAndTime now - DateAndTime now class!

(DateAndTime now - DateAndTime now) class!

(DateAndTime now - DateAndTime now) > 30 minutes.!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:03:03' prior: 50924203!
getCartAt: aCartId
	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	^ carts at: aCartId! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:04:20' prior: 50928888!
getCartAt: aCartId
	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((cartTime - currentDateTime now) > 30 minutes) ifTrue:[ self error: self class sessionExpiredMessage].
	^ carts at: aCartId! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:04:22'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:04:22'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:04:22'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:04:40'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:04:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:04:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:04:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:04:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:04:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:04:41'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:04:41'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:04:41'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:05:14'!
FAILURE!

currentDateTime now!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:07:32' prior: 50928896!
getCartAt: aCartId
	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > 30 minutes) ifTrue:[ self error: self class sessionExpiredMessage].
	^ carts at: aCartId! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:07:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:07:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:07:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:07:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:07:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:07:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:07:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:07:33'!
PASSED!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:07:44'!
expirationTime

	^ 30 minutes! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:07:44' prior: 50928969!
getCartAt: aCartId
	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage].
	^ carts at: aCartId! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:08:07' prior: 50929010!
getCartAt: aCartId
	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage].
	^ carts at: aCartId! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:08:14'!
validateExpiration: aCartId

	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage]! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:08:14' prior: 50929022!
getCartAt: aCartId
	self validateExpiration: aCartId.
	^ carts at: aCartId! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:08:30'!
validateCart: aCartId

	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage]! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:08:30' prior: 50929044!
getCartAt: aCartId
	self validateCart: aCartId.
	^ carts at: aCartId! !

!methodRemoval: TusLibrosInterface #validateExpiration: stamp: 'FC 11/30/2020 19:08:30'!
validateExpiration: aCartId

	| cartTime |
	cartTime := cartTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage]!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:09:13'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartsAccessTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:09:13' prior: 50928644!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	carts add: cartId->(Cart acceptingItemsOf: catalog).
	cartsAccessTimes add: cartId->currentDateTime now.
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:09:13' prior: 50928656!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	cartsAccessTimes := Dictionary new.
	salesBook := aSalesBook.
	currentDateTime := aDate.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:09:13' prior: 50929049!
validateCart: aCartId

	| cartTime |
	cartTime := cartsAccessTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage]! !

Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:09:44'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:09:51'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartAccessTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:10:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:10:00'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:11:26'!
test10
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 28.
	
	tusLibros listCartForId: cartId.
	
	aTimeSimulator passMinutes: 3.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !

!testRun: #TusLibrosInterfaceTest #test10 stamp: 'FC 11/30/2020 19:11:27'!
ERROR!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:12:12' prior: 50929060!
getCartAt: aCartId
	
	self validateCart: aCartId.
	cartAccessTimes at: aCartId put: 	currentDateTime now.
	^ carts at: aCartId! !

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:12:19'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime updateCartTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:12:19' prior: 50929202!
getCartAt: aCartId
	
	self validateCart: aCartId.
	updateCartTime at: aCartId put: 	currentDateTime now.
	^ carts at: aCartId! !

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:12:45'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartAccessTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:12:45' prior: 50929220!
getCartAt: aCartId
	
	self validateCart: aCartId.
	cartAccessTimes at: aCartId put: 	currentDateTime now.
	^ carts at: aCartId! !

Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime updateCartTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:12:51'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime updateCartTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 19:13:00'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId carts salesBook currentDateTime cartAccessTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:14:05'!
updateCartAccessTime: aCartId

	^ cartAccessTimes at: aCartId put: 	currentDateTime now! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:14:05' prior: 50929238!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateCartAccessTime: aCartId.
	^ carts at: aCartId! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:14:06'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:14:06'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:14:06'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:14:06'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:14:06'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:14:06'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:14:06'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:14:06'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10 stamp: 'FC 11/30/2020 19:14:07'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:14:11'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:14:20'!
ERROR!

cartAccessTimes at: aCartId !

cartAccessTimes!
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 11/30/2020 19:15:12' prior: 50929099!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	carts := Dictionary new.
	cartAccessTimes := Dictionary new.
	salesBook := aSalesBook.
	currentDateTime := aDate.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:15:13'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:15:13'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:15:13'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:15:13'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:15:13'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:15:13'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:15:13'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:15:13'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10 stamp: 'FC 11/30/2020 19:15:13'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:15:16'!
FAILURE!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 19:15:38' prior: 50929114!
validateCart: aCartId

	| cartTime |
	cartTime := cartAccessTimes at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	((currentDateTime now - cartTime  ) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage]! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:15:39'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:15:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:15:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:15:39'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:15:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:15:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:15:39'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:15:39'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test10 stamp: 'FC 11/30/2020 19:15:39'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:15:43'!
ERROR!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 19:16:23' prior: 50929087!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	carts add: cartId->(Cart acceptingItemsOf: catalog).
	self updateCartAccessTime: cartId.
	
	^cartId.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:16:23'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10 stamp: 'FC 11/30/2020 19:16:23'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:37:14'!
test09CanNotListExpiredCart
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 31.
	
	self should: [tusLibros listCartForId: cartId] raise: Error withMessageText: TusLibrosInterface sessionExpiredMessage.! !

!methodRemoval: TusLibrosInterfaceTest #test09 stamp: 'FC 11/30/2020 19:37:14'!
test09
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 31.
	
	self should: [tusLibros listCartForId: cartId] raise: Error withMessageText: TusLibrosInterface sessionExpiredMessage.!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:37:49'!
test10ExpirationTimeRefreshesAfterUse
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 28.
	
	tusLibros listCartForId: cartId.
	
	aTimeSimulator passMinutes: 3.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.! !

!methodRemoval: TusLibrosInterfaceTest #test10 stamp: 'FC 11/30/2020 19:37:49'!
test10
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 28.
	
	tusLibros listCartForId: cartId.
	
	aTimeSimulator passMinutes: 3.
	
	self assert: (tusLibros listCartForId: cartId) isEmpty.!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:37:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotListExpiredCart stamp: 'FC 11/30/2020 19:37:55'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 19:37:55'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 19:38:07'!
test09CanNotOperateWithExpiredCart
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 31.
	
	self should: [tusLibros listCartForId: cartId] raise: Error withMessageText: TusLibrosInterface sessionExpiredMessage.! !

!methodRemoval: TusLibrosInterfaceTest #test09CanNotListExpiredCart stamp: 'FC 11/30/2020 19:38:07'!
test09CanNotListExpiredCart
	
	|cartId tusLibros aTimeSimulator |
	
	aTimeSimulator := TimeSimulator startingAt: testObjectsFactory today.
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (aTimeSimulator) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	aTimeSimulator passMinutes: 31.
	
	self should: [tusLibros listCartForId: cartId] raise: Error withMessageText: TusLibrosInterface sessionExpiredMessage.!

Object subclass: #Session
	instanceVariableNames: 'cartId lastAccessTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Session category: 'TusLibros' stamp: 'FC 11/30/2020 20:22:36'!
Object subclass: #Session
	instanceVariableNames: 'cartId lastAccessTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Session class methodsFor: 'no messages' stamp: 'FC 11/30/2020 20:23:42'!
for: aCartId createdAt: aDateTime.
	^self new initializeFor: aCartId createdAt: aDateTime.! !
!Session methodsFor: 'no messages' stamp: 'FC 11/30/2020 20:25:03'!
initializeFor: aCartId createdAt: aDateTime
	cartId := aCartId 
	! !

!classDefinition: #Session category: 'TusLibros' stamp: 'FC 11/30/2020 20:25:12'!
Object subclass: #Session
	instanceVariableNames: 'cart lastAccessTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Session methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:25:12' prior: 50929638!
initializeFor: aCartId createdAt: aDateTime
	cart := aCartId 
	! !
!Session methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:25:18' prior: 50929651!
initializeFor: aCart createdAt: aDateTime
	cart := aCart 
	! !
!Session methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:25:31' prior: 50929656!
initializeFor: aCart createdAt: aDateTime
	cart := aCart. 
	lastAccessTime := aDateTime! !
!Session class methodsFor: 'instance creation' stamp: 'FC 11/30/2020 20:25:39' prior: 50929632!
for: aCart createdAt: aDateTime.
	^self new initializeFor: aCart createdAt: aDateTime.! !
!Session methodsFor: 'accessing' stamp: 'FC 11/30/2020 20:26:54'!
cart
	^cart.! !

----SNAPSHOT----(30 November 2020 20:27:20) CuisUniversity-4383.image priorSource: 18989575!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 11/30/2020 20:29:32'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId activeSessions salesBook currentDateTime cartAccessTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:29:32' prior: 50929413!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->(Cart acceptingItemsOf: catalog).
	self updateCartAccessTime: cartId.
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:29:32' prior: 50929322!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	activeSessions := Dictionary new.
	cartAccessTimes := Dictionary new.
	salesBook := aSalesBook.
	currentDateTime := aDate.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:29:32' prior: 50929278!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateCartAccessTime: aCartId.
	^ activeSessions at: aCartId! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 20:31:15'!
newCart

	^ Cart acceptingItemsOf: catalog! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 20:31:15' prior: 50929689!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->(self newCart).
	self updateCartAccessTime: cartId.
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 20:31:21' prior: 50929727!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->self newCart.
	self updateCartAccessTime: cartId.
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 20:32:04' prior: 50929738!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->(Session for: self newCart createdAt: 1 now).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 11/30/2020 20:32:16' prior: 50929749!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->(Session for: self newCart createdAt: currentDateTime now).
	
	^cartId.! !
!TusLibrosInterface methodsFor: 'accessing - private' stamp: 'FC 11/30/2020 20:32:44' prior: 50929716!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateCartAccessTime: aCartId.
	^ activeSessions at: aCartId cart! !
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 20:33:12'!
updateSessionAccessTime: aCartId

	^ cartAccessTimes at: aCartId put: 	currentDateTime now! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 11/30/2020 20:33:12' prior: 50929772!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateSessionAccessTime: aCartId.
	^ activeSessions at: aCartId cart! !

!methodRemoval: TusLibrosInterface #updateCartAccessTime: stamp: 'FC 11/30/2020 20:33:12'!
updateCartAccessTime: aCartId

	^ cartAccessTimes at: aCartId put: 	currentDateTime now!
!TusLibrosInterface methodsFor: 'validation' stamp: 'FC 11/30/2020 20:35:00' prior: 50929369!
validateCart: aCartId

	| session |
	session := activeSessions at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	(session isExpiredAt: currentDateTime now) ifTrue: [self error: self class sessionExpiredMessage ].
! !
!Session methodsFor: 'accessing' stamp: 'FC 11/30/2020 20:35:44'!
isExpiredAt: aDateTime
	((aDateTime now - lastAccessTime) > self expirationTime) ifTrue:[ self error: self class sessionExpiredMessage]! !
!TusLibrosInterface class methodsFor: 'constants' stamp: 'FC 11/30/2020 20:35:57'!
expirationTime

	^ 30 minutes! !

!methodRemoval: TusLibrosInterface #expirationTime stamp: 'FC 11/30/2020 20:35:57'!
expirationTime

	^ 30 minutes!
!Session methodsFor: 'accessing' stamp: 'FC 11/30/2020 20:37:03'!
expirationTime
	^ 30 minutes.! !
!Session methodsFor: 'accessing' stamp: 'FC 11/30/2020 20:37:12' prior: 50929809!
isExpiredAt: aDateTime
	^((aDateTime now - lastAccessTime) > self expirationTime)! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:37:18'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:37:18'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:37:18'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:37:18'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:37:18'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:37:18'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:37:18'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:37:18'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:37:18'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:37:21'!
ERROR!
!Session methodsFor: 'accessing' stamp: 'FC 11/30/2020 20:37:54' prior: 50929827!
isExpiredAt: aDateTime
	^((aDateTime - lastAccessTime) > self expirationTime)! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:37:57'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:37:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:37:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:37:57'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:37:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:37:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:37:57'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:37:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:37:57'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:38:00'!
ERROR!
!TusLibrosInterface methodsFor: 'accessing - private' stamp: 'FC 11/30/2020 20:38:18' prior: 50929786!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateSessionAccessTime: aCartId.
	^ (activeSessions at: aCartId) cart! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:38:19'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:38:19'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:38:19'!
ERROR!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 20:39:09' prior: 50929779!
updateSessionAccessTime: aCartId

	^(activeSessions at: aCartId) accesedAt: currentDateTime now.! !
!Session methodsFor: 'accessing' stamp: 'FC 11/30/2020 20:39:28'!
accessedAt: aDateTime
	lastAccessTime := aDateTime.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:39:30'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:39:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:39:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:39:30'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:39:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:39:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:39:30'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:39:30'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:39:30'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:39:33'!
ERROR!
!TusLibrosInterface methodsFor: 'adding' stamp: 'FC 11/30/2020 20:39:52' prior: 50929950!
updateSessionAccessTime: aCartId

	^(activeSessions at: aCartId) accessedAt: currentDateTime now.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:39:53'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:39:53'!
PASSED!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/30/2020 20:40:32' prior: 50928599!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier total |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDateTime now registeringOn: salesBook.
	
	total := cashier checkOut.
	
	self removeSession: aCartId.
	^total.! !
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 11/30/2020 20:41:02'!
removeSession: aCartId
	activeSessions remove: aCartId.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:41:04'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:41:04'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:41:04'!
ERROR!
!TusLibrosInterface methodsFor: 'validation' stamp: 'FC 11/30/2020 20:41:53' prior: 50929799!
validateCart: aCartId

	| session |
	session := activeSessions at: aCartId ifAbsent: [self error: self class cartNotFoundMessage].
	(session isExpiredAt: currentDateTime now) ifTrue: [
		self removeSession: aCartId.
		self error: self class sessionExpiredMessage ].
! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:41:54'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:41:54'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:41:54'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:41:57'!
ERROR!
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 11/30/2020 20:43:41' prior: 50930046!
removeSession: aCartId
	activeSessions removeKey: aCartId.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 11/30/2020 20:43:42'!
PASSED!

----SNAPSHOT----(30 November 2020 20:43:48) CuisUniversity-4383.image priorSource: 19136783!

----QUIT----(30 November 2020 20:43:51) CuisUniversity-4383.image priorSource: 19152575!

----STARTUP---- (2 December 2020 16:11:15) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:11:21'!
PASSED!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'FC 12/2/2020 16:12:46'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration ownerName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'FC 12/2/2020 16:12:48'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration ownerName cardNumber'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:12:44'!
initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	ownerName := aName.
	cardNumber := aCardNumber.
	expiration := aMonthOfYear.! !
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:13:03' prior: 50930224!
initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	ownerName = aName.
	cardNumber = aCardNumber.
	expiration := aMonthOfYear.! !
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:13:10' prior: 50930232!
initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	ownerName := aName.
	cardNumber := aCardNumber.
	expiration := aMonthOfYear.! !

!methodRemoval: CreditCard #initializeWithOwner:Number:ExpirationDate: stamp: 'FC 12/2/2020 16:13:45'!
initializeWithOwner: aName Number: aCardNumber ExpirationDate: aMonthOfYear
	ownerName := aName.
	cardNumber := aCardNumber.
	expiration := aMonthOfYear.!
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:14:28'!
withOwner: aName initializeExpiringOn: aMonth 
	
	expiration := aMonth ! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:14:28' prior: 50923229!
expiringOn: aMonth 
	
	^self new withOwner: aName initializeExpiringOn: aMonth! !

!methodRemoval: CreditCard #initializeExpiringOn: stamp: 'FC 12/2/2020 16:14:28'!
initializeExpiringOn: aMonth 
	
	expiration := aMonth !
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:14:42' prior: 50930256!
withOwner: aName initializeExpiringOn: aMonth 
	
	expiration := aMonth 
	! !
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:14:53' prior: 50930272!
withOwner: aName initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	! !
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:15:21'!
withOwner: aName aCCNumber: aCCNumber initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:15:21' prior: 50930262!
expiringOn: aMonth 
	
	^self new withOwner: aName aCCNumber: aCCNumber initializeExpiringOn: aMonth! !

!methodRemoval: CreditCard #withOwner:initializeExpiringOn: stamp: 'FC 12/2/2020 16:15:21'!
withOwner: aName initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	!
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:15:30' prior: 50930284!
withOwner: aName aCCNumber: aCCNumber initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	cardNumber := aCCNumber.
	! !
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:16:37'!
withOwner: aName expiringOn: aMonth 
	
	^self new withOwner: aName aCCNumber: aCCNumber initializeExpiringOn: aMonth! !
!StoreTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:16:37' prior: 50923303!
notExpiredCreditCard
	
	^CreditCard withOwner: 'Juan' expiringOn: (Month month: today monthIndex year: today yearNumber + 1)! !
!StoreTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:16:37' prior: 50923310!
expiredCreditCard
	
	^CreditCard withOwner: 'Juan' expiringOn: (Month month: today monthIndex year: today yearNumber - 1)! !

!methodRemoval: CreditCard class #expiringOn: stamp: 'FC 12/2/2020 16:16:37'!
expiringOn: aMonth 
	
	^self new withOwner: aName aCCNumber: aCCNumber initializeExpiringOn: aMonth!
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:17:15'!
withOwner: aName withCCNumber: aCCNumber initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	cardNumber := aCCNumber.
	! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:17:15' prior: 50930311!
withOwner: aName expiringOn: aMonth 
	
	^self new withOwner: aName withCCNumber: aCCNumber initializeExpiringOn: aMonth! !

!methodRemoval: CreditCard #withOwner:aCCNumber:initializeExpiringOn: stamp: 'FC 12/2/2020 16:17:15'!
withOwner: aName aCCNumber: aCCNumber initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	cardNumber := aCCNumber.
	!
!CreditCard methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:17:40'!
initializeWithOwner: aName withCCNumber: aCCNumber expiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	cardNumber := aCCNumber.
	! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:17:40' prior: 50930347!
withOwner: aName expiringOn: aMonth 
	
	^self new initializeWithOwner: aName withCCNumber: aCCNumber expiringOn: aMonth! !

!methodRemoval: CreditCard #withOwner:withCCNumber:initializeExpiringOn: stamp: 'FC 12/2/2020 16:17:40'!
withOwner: aName withCCNumber: aCCNumber initializeExpiringOn: aMonth 
	
	expiration := aMonth.
	ownerName := aName.
	cardNumber := aCCNumber.
	!
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:18:23'!
withOwner: aName withCCNumber: aCCNumber expiringOn: aMonth 
	
	^self new initializeWithOwner: aName withCCNumber: aCCNumber expiringOn: aMonth! !
!StoreTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:18:23' prior: 50930319!
notExpiredCreditCard
	
	^CreditCard withOwner: 'Juan' withCCNumber: '4555123412346666' expiringOn: (Month month: today monthIndex year: today yearNumber + 1)! !
!StoreTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:18:23' prior: 50930327!
expiredCreditCard
	
	^CreditCard withOwner: 'Juan' withCCNumber: '4555123412346666' expiringOn: (Month month: today monthIndex year: today yearNumber - 1)! !

!methodRemoval: CreditCard class #withOwner:expiringOn: stamp: 'FC 12/2/2020 16:18:23'!
withOwner: aName expiringOn: aMonth 
	
	^self new initializeWithOwner: aName withCCNumber: aCCNumber expiringOn: aMonth!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:18:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:18:33'!
PASSED!
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:18:53' prior: 50930384!
withOwner: aName withCCNumber: aCCNumber expiringOn: aMonth 
	self validateOwnerName: aName.
	self validateCardNumber: aCCNumber.
	^self new initializeWithOwner: aName withCCNumber: aCCNumber expiringOn: aMonth! !
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:19:12'!
validateOwnerName: aName

	^ aName size = 0 ifTrue: [self error: self emptyNameMessage]! !
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:19:19'!
validateCardNumber: aCardNumber

	^ aCardNumber size < 16 ifTrue: [self error: self invalidCardNumberMessage ]! !
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:19:25'!
invalidCardNumberMessage
	^'Card number is invalid'.! !
!CreditCard class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:19:29'!
emptyNameMessage
	^'Name can not be empty'.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:19:32'!
PASSED!

Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId activeSessions salesBook currentDateTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #TusLibrosInterface category: 'TusLibros' stamp: 'FC 12/2/2020 16:20:03'!
Object subclass: #TusLibrosInterface
	instanceVariableNames: 'catalog validUsers merchantProcessor lastId activeSessions salesBook currentDateTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:20:05'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:20:05'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:28:45'!
test11
	
	|cartId tusLibros total purchases |
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	purchases := tusLibros listPurchases for: 'validUser' withPassword: 'asasas'.
	
	self assert: purchases total equals: total.
	self assert: purchases list includes: testObjectsFactory itemSellByTheStore.! !
!TusLibrosInterfaceTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:28:58' prior: 50930557!
test11
	
	|cartId tusLibros total purchases |
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	purchases := tusLibros listPurchasesFor: 'validUser' withPassword: 'asasas'.
	
	self assert: purchases total equals: total.
	self assert: purchases list includes: testObjectsFactory itemSellByTheStore.! !
!Session class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:32:22'!
for: aCart createdAt: aDateTime withBuyer: aBuyer .
	^self new initializeFor: aCart createdAt: aDateTime.! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:32:22' prior: 50929760!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->(Session for: self newCart createdAt: currentDateTime now withBuyer: user).
	
	^cartId.! !

!methodRemoval: Session class #for:createdAt: stamp: 'FC 12/2/2020 16:32:22'!
for: aCart createdAt: aDateTime.
	^self new initializeFor: aCart createdAt: aDateTime.!
!TusLibrosInterface methodsFor: 'cart' stamp: 'FC 12/2/2020 16:32:35' prior: 50930619!
createCartForUser: aUser withPassword: aPassword 
	
	| cartId |
	self authenticateUser: aUser withPassword: aPassword.
	
	cartId := self getNewId.

	activeSessions add: cartId->(Session for: self newCart createdAt: currentDateTime now withBuyer: aUser).
	
	^cartId.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:32:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:32:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:32:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:32:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:32:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:32:39'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:32:40'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:32:40'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:32:40'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:32:40'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:32:40'!
ERROR!
!Session methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:33:23'!
initializeFor: aCart createdAt: aDateTime withBuyer: aBuyer 
	cart := aCart. 
	lastAccessTime := aDateTime! !
!Session class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:33:23' prior: 50930612!
for: aCart createdAt: aDateTime withBuyer: aBuyer .
	^self new initializeFor: aCart createdAt: aDateTime withBuyer: aBuyer.! !

!methodRemoval: Session #initializeFor:createdAt: stamp: 'FC 12/2/2020 16:33:23'!
initializeFor: aCart createdAt: aDateTime
	cart := aCart. 
	lastAccessTime := aDateTime!

!classDefinition: #Session category: 'TusLibros' stamp: 'FC 12/2/2020 16:33:34'!
Object subclass: #Session
	instanceVariableNames: 'cart lastAccessTime buyer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Session methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:33:29' prior: 50930683!
initializeFor: aCart createdAt: aDateTime withBuyer: aBuyer 
	cart := aCart. 
	lastAccessTime := aDateTime.
	buyer := aBuyer.! !
!Session methodsFor: 'accessing' stamp: 'FC 12/2/2020 16:33:55'!
buyer
	^buyer! !
!Cashier class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:35:38'!
toCheckout: aCart charging: aCreditCard throught: aMerchantProcessor on: aDate registeringOn: aSalesBook withBuyer: aBuyer 
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard on: aDate.
	
	^self new initializeToCheckout: aCart charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50923127!
test05CashierChargesCreditCardUsingMerchantProcessor

	| cart cashier salesBook total creditCard debitedAmout debitedCreditCard  |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	creditCard := testObjectsFactory notExpiredCreditCard.
	salesBook := OrderedCollection new.
 
	cashier:= Cashier 
		toCheckout: cart 
		charging: creditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook withBuyer: aUser.
		
	debitBehavior := [ :anAmount :aCreditCard | 
		debitedAmout := anAmount.
		debitedCreditCard := aCreditCard ].
	total := cashier checkOut.
					
	self assert: debitedCreditCard = creditCard.
	self assert: debitedAmout = total.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50923101!
test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit

	| cart cashier salesBook creditCard |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	creditCard := testObjectsFactory notExpiredCreditCard.
	salesBook := OrderedCollection new.
 	debitBehavior := [ :anAmount :aCreditCard | self error: Cashier creditCardHasNoCreditErrorMessage].
	
	cashier:= Cashier 
		toCheckout: cart 
		charging: creditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook withBuyer: aUser.
		
	self 
		should: [cashier checkOut ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardHasNoCreditErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50923062!
test03CanNotCheckoutWithAnExpiredCreditCart

	| cart salesBook |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
	
	self
		should: [ Cashier 
				toCheckout: cart 
				charging: testObjectsFactory expiredCreditCard 
				throught: self
				on: testObjectsFactory today
				registeringOn: salesBook withBuyer: aUser ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assert: anError messageText = Cashier canNotChargeAnExpiredCreditCardErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50923151!
test01CanNotCheckoutAnEmptyCart

	| salesBook |
	
	salesBook := OrderedCollection new.
	self 
		should: [ Cashier 
			toCheckout: testObjectsFactory createCart 
			charging: testObjectsFactory notExpiredCreditCard 
			throught: self
			on: testObjectsFactory today
			registeringOn:  salesBook withBuyer: aUser ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmptyErrorMessage.
			self assert: salesBook isEmpty ]! !
!TusLibrosInterface methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50930033!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier total |
	cart := self getCartAt: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDateTime now registeringOn: salesBook withBuyer: aUser.
	
	total := cashier checkOut.
	
	self removeSession: aCartId.
	^total.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50923169!
test02CalculatedTotalIsCorrect

	| cart cashier |
	
	cart := testObjectsFactory createCart.
	cart add: 2 of: testObjectsFactory itemSellByTheStore.
	
	cashier :=  Cashier
		toCheckout: cart 
		charging: testObjectsFactory notExpiredCreditCard 
		throught: self
		on: testObjectsFactory today 
		registeringOn: OrderedCollection new withBuyer: aUser.
		
	self assert: cashier checkOut = (testObjectsFactory itemSellByTheStorePrice * 2)! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:35:38' prior: 50923083!
test04CheckoutRegistersASale

	| cart cashier salesBook total |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
 
	cashier:= Cashier 
		toCheckout: cart 
		charging: testObjectsFactory notExpiredCreditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook withBuyer: aUser.
		
	total := cashier checkOut.
					
	self assert: salesBook size = 1.
	self assert: salesBook first total = total.! !

!methodRemoval: Cashier class #toCheckout:charging:throught:on:registeringOn: stamp: 'FC 12/2/2020 16:35:39'!
toCheckout: aCart charging: aCreditCard throught: aMerchantProcessor on: aDate registeringOn: aSalesBook
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard on: aDate.
	
	^self new initializeToCheckout: aCart charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 16:35:44'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 16:35:44'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 16:35:44'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 16:35:44'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 16:35:44'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 16:35:44'!
PASSED!
!StoreTestObjectsFactory methodsFor: 'authentication' stamp: 'FC 12/2/2020 16:36:24'!
defaultUser
	
	^'validUser'
! !
!CashierTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:36:44' prior: 50930809!
test01CanNotCheckoutAnEmptyCart

	| salesBook |
	
	salesBook := OrderedCollection new.
	self 
		should: [ Cashier 
			toCheckout: testObjectsFactory createCart 
			charging: testObjectsFactory notExpiredCreditCard 
			throught: self
			on: testObjectsFactory today
			registeringOn:  salesBook withBuyer: testObjectsFactory defaultUser]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmptyErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:36:51' prior: 50930842!
test02CalculatedTotalIsCorrect

	| cart cashier |
	
	cart := testObjectsFactory createCart.
	cart add: 2 of: testObjectsFactory itemSellByTheStore.
	
	cashier :=  Cashier
		toCheckout: cart 
		charging: testObjectsFactory notExpiredCreditCard 
		throught: self
		on: testObjectsFactory today 
		registeringOn: OrderedCollection new withBuyer: testObjectsFactory defaultUser.
		
	self assert: cashier checkOut = (testObjectsFactory itemSellByTheStorePrice * 2)! !
!CashierTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:36:55' prior: 50930787!
test03CanNotCheckoutWithAnExpiredCreditCart

	| cart salesBook |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
	
	self
		should: [ Cashier 
				toCheckout: cart 
				charging: testObjectsFactory expiredCreditCard 
				throught: self
				on: testObjectsFactory today
				registeringOn: salesBook withBuyer: testObjectsFactory defaultUser ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assert: anError messageText = Cashier canNotChargeAnExpiredCreditCardErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:36:59' prior: 50930859!
test04CheckoutRegistersASale

	| cart cashier salesBook total |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
 
	cashier:= Cashier 
		toCheckout: cart 
		charging: testObjectsFactory notExpiredCreditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook withBuyer: testObjectsFactory defaultUser.
		
	total := cashier checkOut.
					
	self assert: salesBook size = 1.
	self assert: salesBook first total = total.! !
!CashierTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:37:06' prior: 50930734!
test05CashierChargesCreditCardUsingMerchantProcessor

	| cart cashier salesBook total creditCard debitedAmout debitedCreditCard  |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	creditCard := testObjectsFactory notExpiredCreditCard.
	salesBook := OrderedCollection new.
 
	cashier:= Cashier 
		toCheckout: cart 
		charging: creditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook withBuyer: testObjectsFactory defaultUser.
		
	debitBehavior := [ :anAmount :aCreditCard | 
		debitedAmout := anAmount.
		debitedCreditCard := aCreditCard ].
	total := cashier checkOut.
					
	self assert: debitedCreditCard = creditCard.
	self assert: debitedAmout = total.! !

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 16:37:07'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 16:37:07'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 16:37:07'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 16:37:07'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 16:37:07'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 16:37:07'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 16:37:07'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:37:15' prior: 50930760!
test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit

	| cart cashier salesBook creditCard |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	creditCard := testObjectsFactory notExpiredCreditCard.
	salesBook := OrderedCollection new.
 	debitBehavior := [ :anAmount :aCreditCard | self error: Cashier creditCardHasNoCreditErrorMessage].
	
	cashier:= Cashier 
		toCheckout: cart 
		charging: creditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook withBuyer: testObjectsFactory defaultUser.
		
	self 
		should: [cashier checkOut ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardHasNoCreditErrorMessage.
			self assert: salesBook isEmpty ]! !

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 16:37:17'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 16:37:17'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 16:37:17'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 16:37:17'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 16:37:17'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 16:37:17'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 16:37:17'!
PASSED!
!Cashier methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:38:49'!
initializeToCheckout: aCart charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook withBuyer: aBuyer 
	
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.
	salesBook := aSalesBook! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:38:49' prior: 50930720!
toCheckout: aCart charging: aCreditCard throught: aMerchantProcessor on: aDate registeringOn: aSalesBook withBuyer: aBuyer 
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard on: aDate.
	
	^self new initializeToCheckout: aCart charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook withBuyer: aBuyer! !

!methodRemoval: Cashier #initializeToCheckout:charging:throught:registeringOn: stamp: 'FC 12/2/2020 16:38:49'!
initializeToCheckout: aCart charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook
	
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.
	salesBook := aSalesBook!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'FC 12/2/2020 16:38:59'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard total buyer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:38:57' prior: 50931092!
initializeToCheckout: aCart charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook withBuyer: aBuyer 
	
	cart := aCart.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.
	salesBook := aSalesBook.
	buyer := aBuyer! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 16:39:00'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 16:39:00'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 16:39:00'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 16:39:00'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 16:39:00'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 16:39:00'!
PASSED!
!Sale class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:39:39'!
of: aTotal withBuyer: aBuyer 

	"should assert total is not negative or 0!!"
	^self new initializeTotal: aTotal ! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:39:39' prior: 50922971!
createSale

	^ Sale of: total withBuyer: buyer
! !

!methodRemoval: Sale class #of: stamp: 'FC 12/2/2020 16:39:39'!
of: aTotal

	"should assert total is not negative or 0!!"
	^self new initializeTotal: aTotal !
!Sale class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:39:51' prior: 50931166!
of: aTotal withBuyer: aBuyer 

	"should assert total is not negative or 0!!"
	^self new initializeTotal: aTotal withBuyer: aBuyer.! !

!classDefinition: #Sale category: 'TusLibros' stamp: 'FC 12/2/2020 16:40:07'!
Object subclass: #Sale
	instanceVariableNames: 'total buyer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Sale methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:40:06'!
initializeTotal: aTotal withBuyer: aBuyer

	total := aTotal. 
	buyer := aBuyer! !

!methodRemoval: Sale #initializeTotal: stamp: 'FC 12/2/2020 16:40:09'!
initializeTotal: aTotal

	total := aTotal !
!Sale class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:41:51'!
of: aTotal withBuyer: aBuyer buying: items  

	"should assert total is not negative or 0!!"
	^self new initializeTotal: aTotal withBuyer: aBuyer.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:41:51' prior: 50931173!
createSale

	^ Sale of: total withBuyer: buyer buying: cart items
! !

!methodRemoval: Sale class #of:withBuyer: stamp: 'FC 12/2/2020 16:41:51'!
of: aTotal withBuyer: aBuyer 

	"should assert total is not negative or 0!!"
	^self new initializeTotal: aTotal withBuyer: aBuyer.!
!Sale class methodsFor: 'instance creation' stamp: 'FC 12/2/2020 16:41:57' prior: 50931205!
of: aTotal withBuyer: aBuyer buying: items  

	"should assert total is not negative or 0!!"
	^self new initializeTotal: aTotal withBuyer: aBuyer buying: items.! !

!classDefinition: #Sale category: 'TusLibros' stamp: 'FC 12/2/2020 16:42:28'!
Object subclass: #Sale
	instanceVariableNames: 'total buyer soldItems'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Sale methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:42:26'!
initializeTotal: aTotal withBuyer: aBuyer buying: items

	total := aTotal. 
	buyer := aBuyer.
	soldItems := items.! !

!methodRemoval: Sale #initializeTotal:withBuyer: stamp: 'FC 12/2/2020 16:42:30'!
initializeTotal: aTotal withBuyer: aBuyer

	total := aTotal. 
	buyer := aBuyer!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:42:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:42:33'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:42:33'!
ERROR!
!TusLibrosInterface methodsFor: 'initialization' stamp: 'FC 12/2/2020 16:42:46' prior: 50929701!
initializeForCatalog: aCatalog withUsers: registeredUsers through: aMerchantProcessor on: aDate registeringOn: aSalesBook  

	catalog := aCatalog.
	validUsers := registeredUsers.
	merchantProcessor := aMerchantProcessor.
	lastId  := 0.
	activeSessions := Dictionary new.
	salesBook := aSalesBook.
	currentDateTime := aDate.! !
!Sale methodsFor: 'total' stamp: 'FC 12/2/2020 16:43:44'!
soldItems
	
	^ soldItems! !
!Sale methodsFor: 'total' stamp: 'FC 12/2/2020 16:43:54'!
buyer
	
	^ buyer! !
!Sale methodsFor: 'total' stamp: 'FC 12/2/2020 16:43:55' prior: 50931349!
buyer
	^ buyer! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:44:51'!
listPurchasesFor: aUser withPassword: aPassword


	! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:45:09' prior: 50931356!
listPurchasesFor: aUser withPassword: aPassword
	self authenticateUser: aUser withPassword: aPassword.
	
	! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:45:50' prior: 50931362!
listPurchasesFor: aUser withPassword: aPassword
	| userSales |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:46:46' prior: 50931369!
listPurchasesFor: aUser withPassword: aPassword
	| userSales total |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].
	
	total := userSales sum: [ :aSale | aSale total ] ifEmpty: [0].! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:48:10' prior: 50931379!
listPurchasesFor: aUser withPassword: aPassword
	| userSales total itemsBought |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].
	
	total := userSales sum: [ :aSale | aSale total ] ifEmpty: [0].
	
	itemsBought := userSales inject: #()  into: [ :totalSales :aSale  | totalSales , aSale ]
	 ! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:48:35' prior: 50931391!
listPurchasesFor: aUser withPassword: aPassword
	| userSales total itemsBought |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].
	
	total := userSales sum: [ :aSale | aSale total ] ifEmpty: [0].
	
	itemsBought := userSales inject: #()  into: [ :totalSales :aSale  | totalSales , aSale ]
	
	 ! !

Object subclass: #SalesSummary
	instanceVariableNames: 'total items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #SalesSummary category: 'TusLibros' stamp: 'FC 12/2/2020 16:48:58'!
Object subclass: #SalesSummary
	instanceVariableNames: 'total items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!SalesSummary class methodsFor: 'no messages' stamp: 'FC 12/2/2020 16:50:22'!
for: aListOfItems withTotal: aTotal.
	^self new initializeFor: aListOfItems withSelectorsLimitedTo: aTotal.! !
!SalesSummary class methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:50:25' prior: 50931432!
for: aListOfItems withTotal: aTotal.
	^self new initializeFor: aListOfItems withTotal: aTotal.! !
!SalesSummary methodsFor: 'no messages' stamp: 'FC 12/2/2020 16:50:42'!
initializeFor: aListOfItems withTotal: aTotal.
	items := aListOfItems.
	total := aTotal.! !
!SalesSummary methodsFor: 'as yet unclassified' stamp: 'FC 12/2/2020 16:50:54'!
total
	^total.! !
!SalesSummary methodsFor: 'accessing' stamp: 'FC 12/2/2020 16:51:49'!
items
	^items.! !
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:52:55' prior: 50931406!
listPurchasesFor: aUser withPassword: aPassword
	| userSales total itemsBought |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].
	
	total := userSales sum: [ :aSale | aSale total ] ifEmpty: [0].
	
	itemsBought := userSales inject: #()  into: [ :totalSales :aSale  | totalSales , aSale ].
	
	 ^SalesSummary for: itemsBought withTotal: total.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:52:56'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:52:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:52:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:52:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:52:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:52:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:52:57'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:52:57'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:52:57'!
FAILURE!

salesBook!

self at: 1!

self at: 1 buyer!

(self at: 1) buyer!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:54:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:54:24'!
FAILURE!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:54:24'!
FAILURE!
!TusLibrosInterface methodsFor: 'checkOut' stamp: 'FC 12/2/2020 16:55:52' prior: 50930828!
checkOutCartId: aCartId payingWith: aCreditCard 
	
	| cart cashier total buyer |
	cart := self getCartAt: aCartId.
	buyer := self getBuyerFor: aCartId.
	cashier := Cashier toCheckout: cart  charging: aCreditCard  throught: merchantProcessor  on: currentDateTime now registeringOn: salesBook withBuyer: buyer.
	
	total := cashier checkOut.
	
	self removeSession: aCartId.
	^total.! !
!TusLibrosInterface methodsFor: 'accessing - private' stamp: 'FC 12/2/2020 16:56:08' prior: 50929908!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateSessionAccessTime: aCartId.
	^ (activeSessions at: aCartId) buyer! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:56:09'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:56:09'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:56:09'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:56:09'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:56:09'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:56:09'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:56:09'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:56:09'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:56:09'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:56:09'!
ERROR!
!TusLibrosInterface methodsFor: 'accessing - private' stamp: 'FC 12/2/2020 16:56:16' prior: 50931565!
getCartAt: aCartId
	
	self validateCart: aCartId.
	self updateSessionAccessTime: aCartId.
	^ (activeSessions at: aCartId) cart! !
!TusLibrosInterface methodsFor: 'accessing - private' stamp: 'FC 12/2/2020 16:56:23'!
getBuyerFor: aCartId
	
	self validateCart: aCartId.
	self updateSessionAccessTime: aCartId.
	^ (activeSessions at: aCartId) buyer! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:56:24'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:56:24'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:56:24'!
ERROR!
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:57:00' prior: 50931458!
listPurchasesFor: aUser withPassword: aPassword
	| userSales total itemsBought |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].
	
	total := userSales sum: [ :aSale | aSale total ] ifEmpty: [0].
	
	itemsBought := userSales inject: #()  into: [ :totalSales :aSale  | totalSales , aSale items ].
	
	 ^SalesSummary for: itemsBought withTotal: total.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:57:00'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:57:01'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:57:01'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:57:01'!
ERROR!
!TusLibrosInterface methodsFor: 'session handling - private' stamp: 'FC 12/2/2020 16:57:13' prior: 50931657!
listPurchasesFor: aUser withPassword: aPassword
	| userSales total itemsBought |
	self authenticateUser: aUser withPassword: aPassword.
	
	userSales := salesBook select: [ :aSale | aSale buyer = aUser ].
	
	total := userSales sum: [ :aSale | aSale total ] ifEmpty: [0].
	
	itemsBought := userSales inject: #()  into: [ :totalSales :aSale  | totalSales , aSale soldItems ].
	
	 ^SalesSummary for: itemsBought withTotal: total.! !

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:57:14'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:57:14'!
ERROR!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:57:14'!
ERROR!
!TusLibrosInterfaceTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:57:28' prior: 50930585!
test11
	
	|cartId tusLibros total purchases |
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	purchases := tusLibros listPurchasesFor: 'validUser' withPassword: 'asasas'.
	
	self assert: purchases total equals: total.
	self assert: purchases items includes: testObjectsFactory itemSellByTheStore.! !

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 16:57:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:57:29'!
PASSED!
!TusLibrosInterfaceTest methodsFor: 'tests' stamp: 'FC 12/2/2020 16:58:31'!
test11listPurchasesListsPurchasesCorrectly
	
	|cartId tusLibros total purchases |
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	purchases := tusLibros listPurchasesFor: 'validUser' withPassword: 'asasas'.
	
	self assert: purchases total equals: total.
	self assert: purchases items includes: testObjectsFactory itemSellByTheStore.! !

!methodRemoval: TusLibrosInterfaceTest #test11 stamp: 'FC 12/2/2020 16:58:33'!
test11
	
	|cartId tusLibros total purchases |
	
	tusLibros := TusLibrosInterface 
				forCatalog: (testObjectsFactory defaultCatalog) 
				withUsers: (testObjectsFactory defaultUsers) 
				through: self 
				on: (TimeSimulator startingAt: testObjectsFactory today) 
				registeringOn: OrderedCollection new.
	
	cartId := tusLibros createCartForUser: 'validUser' withPassword: 'asasas'.
	
	tusLibros addToCart: 1 of: (testObjectsFactory itemSellByTheStore) forId: cartId.
	
	total := tusLibros checkOutCartId: cartId payingWith: testObjectsFactory notExpiredCreditCard.
	
	purchases := tusLibros listPurchasesFor: 'validUser' withPassword: 'asasas'.
	
	self assert: purchases total equals: total.
	self assert: purchases items includes: testObjectsFactory itemSellByTheStore.!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 17:01:28'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 17:01:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 17:01:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 17:01:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 17:01:29'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11listPurchasesListsPurchasesCorrectly stamp: 'FC 12/2/2020 17:01:29'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11listPurchasesListsPurchasesCorrectly stamp: 'FC 12/2/2020 17:01:31'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'FC 12/2/2020 17:01:32'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test01InterfaceCreatesEmptyCart stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test02CanNotCreateCartWithInvalidPassword stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test03CanNotCreateCartWithInvalidUsername stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test04InterfaceListsOneItem stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test06CanNotListInvalidCart stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test07CanNotAddToInvalidCart stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test08CheckOutReturnsTotal stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test09CanNotOperateWithExpiredCart stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test10ExpirationTimeRefreshesAfterUse stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

!testRun: #TusLibrosInterfaceTest #test11listPurchasesListsPurchasesCorrectly stamp: 'FC 12/2/2020 17:01:33'!
PASSED!

----QUIT----(2 December 2020 17:01:48) CuisUniversity-4383.image priorSource: 19152669!