

----STARTUP---- (15 October 2020 17:20:07) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


----End fileIn of C:\Users\Felip\Downloads\ISW1-2020-2C-Parcial-Enunciado.st----!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:21:20'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 17:21:34'!
PASSED!

----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\Solucion\Stack-Solution-1b.st----!

!classRemoval: #OONotEmptyAndNotFullStackState stamp: 'FC 10/15/2020 17:24:23'!
OOStackState subclass: #OONotEmptyAndNotFullStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOFullStackState stamp: 'FC 10/15/2020 17:24:23'!
OOStackState subclass: #OOFullStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOEmptyStackState stamp: 'FC 10/15/2020 17:24:23'!
OOStackState subclass: #OOEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOStackState stamp: 'FC 10/15/2020 17:24:24'!
Object subclass: #OOStackState
	instanceVariableNames: 'stack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOUnlimitedStack stamp: 'FC 10/15/2020 17:24:24'!
OOStack subclass: #OOUnlimitedStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOLimitedStack stamp: 'FC 10/15/2020 17:24:24'!
OOStack subclass: #OOLimitedStack
	instanceVariableNames: 'limit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOStack stamp: 'FC 10/15/2020 17:24:25'!
Object subclass: #OOStack
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOUnlimitedStackTest stamp: 'FC 10/15/2020 17:24:25'!
OOStackTest subclass: #OOUnlimitedStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOLimitedStackTest stamp: 'FC 10/15/2020 17:24:25'!
OOStackTest subclass: #OOLimitedStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

!classRemoval: #OOStackTest stamp: 'FC 10/15/2020 17:24:25'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1b'!

----End fileIn of C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\Solucion\Stack-Solution-1a.st----!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:30:35'!
asasas
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:31:41'!
doForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !

!methodRemoval: Backpack #asasas stamp: 'FC 10/15/2020 17:31:43'!
asasas
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:33:43' prior: 50896289!
doForAllBackpackContents: aClosure
	
	| index |

	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		aClosure value.
		index := index + 1.	
	].! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:34:00' prior: 50896310!
doForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 17:34:00'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 17:34:00'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:35:20' prior: 50894678!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:35:27' prior: 50894666!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:37:44' prior: 50896320!
doForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + aClosure value: portableObject.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:37:59'!
totalWeightOrig
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:38:33' prior: 50896458!
totalWeightOrig
	
	self doForAllBackpackContents: [ :portableObject | portableObject weight]! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:39:00'!
totalWeightOriginal
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:39:06' prior: 50896424!
totalWeight
	
	self doForAllBackpackContents: [ :portableObject | portableObject weight]! !

!methodRemoval: Backpack #totalWeightOrig stamp: 'FC 10/15/2020 17:39:09'!
totalWeightOrig
	
	self doForAllBackpackContents: [ :portableObject | portableObject weight]!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:39:15'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:39:15'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:39:15'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:39:15'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:39:15'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:39:15'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:39:15'!
FAILURE!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:39:15'!
FAILURE!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:39:15'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:39:15'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:39:16'!
FAILURE!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:39:16'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:39:16'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:39:16'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:39:16'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:39:35' prior: 50896486!
totalWeight
	
	^self doForAllBackpackContents: [ :portableObject | portableObject weight]! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:39:40'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:39:40'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:39:40'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:39:40'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:39:40'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:39:40'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:40:14' prior: 50896552!
totalWeight
	
	^self doForAllBackpackContents: [ :portableObject | portableObject weight]! !

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:41:40'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:41:43'!
ERROR!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:41:43'!
ERROR!

[:a | a] value: 1!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:42:54' prior: 50896447!
doForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + (aClosure value: portableObject).
		index := index + 1.	
	].

	^ total.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:42:57'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:43:02'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:43:02'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:43:19'!
totalPointsOriginal
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:44:46' prior: 50896435!
totalPoints
		
	^self doForAllBackpackContents:  [ :portableObject | portableObject ]! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:45:16' prior: 50896763!
totalPoints
		
	^self doForAllBackpackContents:  [ :portableObject | portableObject doesItAddPoints ifTrue:  []]! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:45:48' prior: 50896769!
totalPoints
		
	^self doForAllBackpackContents:  [ :portableObject | portableObject doesItAddPoints ifTrue:  [ portableObject points ]]! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:46:04'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:46:04'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:46:04'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:46:04'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:46:13' prior: 50896776!
totalPoints
		
	^self doForAllBackpackContents:  [ :portableObject | portableObject doesItAddPoints ifTrue:  [ portableObject points] ifFalse: [0]]! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 17:46:17'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 17:46:17'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:46:41'!
sumForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + (aClosure value: portableObject).
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'as yet unclassified' stamp: 'FC 10/15/2020 17:46:41' prior: 50896613!
totalWeight
	
	^self sumForAllBackpackContents: [ :portableObject | portableObject weight]! !
!Backpack methodsFor: 'as yet unclassified' stamp: 'FC 10/15/2020 17:46:41' prior: 50896838!
totalPoints
		
	^self sumForAllBackpackContents:  [ :portableObject | portableObject doesItAddPoints ifTrue:  [ portableObject points] ifFalse: [0]]! !

!methodRemoval: Backpack #doForAllBackpackContents: stamp: 'FC 10/15/2020 17:46:41'!
doForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + (aClosure value: portableObject).
		index := index + 1.	
	].

	^ total.!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 17:58:27' prior: 50896918!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ]
	! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:00:47' prior: 50896937!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:portableObject :total | total + portableObject points ]! !
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:00:49' prior: 50896944!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:portableObject :total | total + portableObject points ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:00:56'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:00:56'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:00:56'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:00:57'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:00:57'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:00:57'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:00:57'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:01:06' prior: 50896954!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:portableObject :total | total + (portableObject points) ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:01:09'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:01:09'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:01:09'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:01:09'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:01:09'!
ERROR!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:01:13'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:02:16' prior: 50897018!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:portableObject :total | total points + (portableObject) ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:02:19'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:02:19'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:02:39' prior: 50897086!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:portableObject :total | total points + (portableObject) ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:02:39'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:02:39'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:02:39'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:02:39'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:02:40'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:02:40'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:03:02' prior: 50897151!
totalPoints
	| selectedItems |	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:total :portableObject | total + portableObject points ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:03:05'!
PASSED!

!methodRemoval: Backpack #sumForAllBackpackContents: stamp: 'FC 10/15/2020 18:03:17'!
sumForAllBackpackContents: aClosure
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + (aClosure value: portableObject).
		index := index + 1.	
	].

	^ total.!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:04:16' prior: 50896912!
totalWeight
	
	^container inject: 0 into: [:total :portableObject | total + portableObject weight ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:04:31'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:04:31'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 18:05:24' prior: 50897347!
totalPoints
	| selectedItems |	
	
	selectedItems := container select: [:portableObject | portableObject doesItAddPoints ].
	^selectedItems	 inject: 0 into: [:total :portableObject | total + portableObject points ].! !
!Backpack methodsFor: 'adding' stamp: 'FC 10/15/2020 18:09:34' prior: 50894704!
add: aPortableObject
	
	aPortableObject addToBackpack: self.
	
	"""
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	
	"""! !
!Backpack methodsFor: 'adding' stamp: 'FC 10/15/2020 18:11:07'!
addNoPointsObject: aNoPointsPortableObject
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	container add: aNoPointsPortableObject.
	! !
!Backpack methodsFor: 'adding' stamp: 'FC 10/15/2020 18:11:45'!
addPointsObject: aPointsPortableObject
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	container add: aPointsPortableObject.! !
!Backpack methodsFor: 'adding' stamp: 'FC 10/15/2020 18:13:16' prior: 50897494!
add: aPortableObject
	
	aPortableObject addTo: self.
	
	"""
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	
	"""! !
!NoPointsPortableObject methodsFor: 'adding' stamp: 'FC 10/15/2020 18:13:48' overrides: 50895086!
addTo: aBackpack
	aBackpack addNoPointsObject: self.! !
!PointsPortableObject methodsFor: 'adding' stamp: 'FC 10/15/2020 18:14:02' overrides: 50895086!
addTo: aBackpack
	aBackpack addPointsObject: self.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:14:13'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:14:13'!
PASSED!
!Backpack methodsFor: 'adding' stamp: 'FC 10/15/2020 18:14:26' prior: 50897526!
add: aPortableObject
	
	aPortableObject addTo: self.! !
!Door methodsFor: 'testing' stamp: 'FC 10/15/2020 18:21:38' prior: 50894950!
isOpen

	^ self state isOpen.
! !

DoorState subclass: #OpenDoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #OpenDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #OpenDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'FC 10/15/2020 18:22:19'!
DoorState subclass: #OpenDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'FC 10/15/2020 18:22:22'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #ClosedKeyDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #ClosedKeyDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'FC 10/15/2020 18:22:25'!
DoorState subclass: #ClosedKeyDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRenamed: #ClosedKeyDoorState as: #KeyClosedDoorState stamp: 'FC 10/15/2020 18:22:43'!
Smalltalk renameClassNamed: #ClosedKeyDoorState as: #KeyClosedDoorState!
!OpenDoorState methodsFor: 'nil' stamp: 'FC 10/15/2020 18:28:07' overrides: 50894833!
isOpen
	^true.! !
!KeyClosedDoorState methodsFor: 'no messages' stamp: 'FC 10/15/2020 18:28:36' overrides: 50894833!
isOpen
	^false.! !
!ClosedDoorState methodsFor: 'no messages' stamp: 'FC 10/15/2020 18:30:09' overrides: 50894833!
isOpen
	^false.! !
!Door class methodsFor: 'instance creation' stamp: 'FC 10/15/2020 18:33:29' prior: 50895021!
closed

	| door |
	
	door := Door new.
	door initializeWith: (ClosedDoorState for: door).
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FC 10/15/2020 18:34:33' prior: 50895027!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: (KeyClosedDoorState for: door) using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FC 10/15/2020 18:34:56' prior: 50895033!
opened

	| door |
	
	door := Door new.
	door initializeWith: (OpenDoorState for: door).
	
	^ door.! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:35:40' prior: 50894964 overrides: 50894917!
toBeClosedBy: aPlayableCharacter
	self state.
	"""
	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	"""! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:36:14' prior: 50897699 overrides: 50894917!
toBeClosedBy: aPlayableCharacter
	self state open.
	
	"""
	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	"""! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:36:19' prior: 50897712 overrides: 50894917!
toBeClosedBy: aPlayableCharacter
	self state close.
	
	"""
	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	"""! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:37:54'!
closeWhenOpen
	 state := ClosedDoorState for: self.
	
	"""
	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	"""! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:38:13'!
closeWhenClosed
	 self error: Door alreadyClosedErrorDescription.
	
	"""
	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	"""! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:38:16' prior: 50897749!
closeWhenClosed
	 self error: Door alreadyClosedErrorDescription.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:38:20' prior: 50897737!
closeWhenOpen
	 state := ClosedDoorState for: self.
! !
!ClosedDoorState methodsFor: 'testing' stamp: 'FC 10/15/2020 18:38:50' overrides: 50894821!
close
	door closeWhenOpen.! !
!KeyClosedDoorState methodsFor: 'nil' stamp: 'FC 10/15/2020 18:39:06' overrides: 50894821!
close
	door closeWhenClosed.! !
!ClosedDoorState methodsFor: 'testing' stamp: 'FC 10/15/2020 18:39:20' prior: 50897771 overrides: 50894821!
close
	door closeWhenClosed.! !
!OpenDoorState methodsFor: 'nil' stamp: 'FC 10/15/2020 18:39:27' overrides: 50894821!
close
	door closeWhenOpen.! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:41:57' prior: 50897725 overrides: 50894917!
toBeClosedBy: aPlayableCharacter
	self state close.! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:42:29' prior: 50894976 overrides: 50894922!
toBeOpenedBy: aPlayableCharacter
	self state open.
	
"
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].
"! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:43:17'!
openWhenOpened
	self error: Door alreadyOpenedErrorDescription.
	! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:44:03'!
openWhenClosed
	state := OpenDoorState for: self.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:44:28'!
openWhenKeyClosed
	self error: Door closedWithKeyErrorDescription.
! !
!OpenDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:44:56' overrides: 50894825!
open
	door openWhenOpened.! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:45:05' overrides: 50894825!
open
	door openWhenKeyClosed.! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:45:20' overrides: 50894825!
open
	door openWhenClosed.! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:46:04' prior: 50897795 overrides: 50894922!
toBeOpenedBy: aPlayableCharacter
	self state open.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:46:52' prior: 50894988 overrides: 50894927!
toBeOpenedBy: aPlayableCharacter using: aKey
	self state openUsing: aKey.

"
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]
"! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:48:06'!
OpenUsingWhenClosed: aKey
	self error: Door noNeedForAKeyErrorDescription
! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:48:58'!
OpenUsingWhenKeyClosed: aKey
	(key == aKey) ifTrue: [ ^ state := OpenDoorState for: self ].
	self error: Door notCorrectKeyErrorDescription. 
! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:49:46' prior: 50897844 overrides: 50894927!
toBeOpenedBy: aPlayableCharacter using: aKey
	self state openUsing: aKey.! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:50:33' overrides: 50894829!
openUsing: aKey
	door OpenUsingWhenKeyClosed: aKey.! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:50:38' prior: 50897879 overrides: 50894829!
openUsing: aKey
	door openUsingWhenKeyClosed: aKey.! !
!Door methodsFor: 'private reactions' stamp: 'FC 10/15/2020 18:50:51'!
openUsingWhenClosed: aKey
	self error: Door noNeedForAKeyErrorDescription
! !

!methodRemoval: Door #OpenUsingWhenClosed: stamp: 'FC 10/15/2020 18:50:51'!
OpenUsingWhenClosed: aKey
	self error: Door noNeedForAKeyErrorDescription
!
!Door methodsFor: 'private reactions' stamp: 'FC 10/15/2020 18:51:01'!
openUsingWhenKeyClosed: aKey
	(key == aKey) ifTrue: [ ^ state := OpenDoorState for: self ].
	self error: Door notCorrectKeyErrorDescription. 
! !

!methodRemoval: Door #OpenUsingWhenKeyClosed: stamp: 'FC 10/15/2020 18:51:01'!
OpenUsingWhenKeyClosed: aKey
	(key == aKey) ifTrue: [ ^ state := OpenDoorState for: self ].
	self error: Door notCorrectKeyErrorDescription. 
!
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:51:27' overrides: 50894829!
openUsing: aKey
	door openUsingWhenKeyClosed: aKey.! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:51:33' prior: 50897885 overrides: 50894829!
openUsing: aKey
	door openUsingWhenClosed: aKey.! !
!OpenDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:51:47' overrides: 50894829!
openUsing: aKey
	door openWhenOpened.! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:52:24' prior: 50895002 overrides: 50894933!
toBeUsedBy: aPlayableCharacter
	self state use.
"
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
"! !
!OpenDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:52:59'!
use
	self close.! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:53:10'!
use
	self open.! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:53:33'!
use
	self open.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:53:39'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:53:39'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:53:39'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:53:39'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:53:39'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:53:39'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:53:42'!
ERROR!
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:54:03' prior: 50897873 overrides: 50894927!
toBeOpenedBy: aPlayableCharacter using: aKey
	state openUsing: aKey.! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:54:07' prior: 50897930 overrides: 50894933!
toBeUsedBy: aPlayableCharacter
	state use.
"
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
"! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:54:12' prior: 50897838 overrides: 50894922!
toBeOpenedBy: aPlayableCharacter
	state open.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 18:54:17' prior: 50897789 overrides: 50894917!
toBeClosedBy: aPlayableCharacter
	state close.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:54:22'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:54:26'!
ERROR!
!Door methodsFor: 'testing' stamp: 'FC 10/15/2020 18:54:49' prior: 50897612!
isOpen

	^ state isOpen.
! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:54:54'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:54:58'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:54:59'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:54:59'!
PASSED!
!DoorState methodsFor: 'door actions' stamp: 'FC 10/15/2020 18:55:11'!
use
	self subclassResponsibility.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:56:30'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:56:36'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:56:47'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 18:56:55'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 18:56:55'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:01:17'!
shouldNotAdd: aPortableObject IfWeightExceededOn: aBackpack

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:02:04' prior: 50894254!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self shouldNotAdd: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1)  IfWeightExceededOn: aBackpack .
! !

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:02:07'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:03:18' prior: 50894268!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	self shouldNotAdd: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5)  IfWeightExceededOn: aBackpack .
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:03:22'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:03:22'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:05:52'!
shouldAddPortableObjects: portableObjects On: aBackpack IfWeightEquals: aWeight 
	
	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:10:02' prior: 50898518!
shouldAddPortableObjects: portableObjects On: aBackpack IfWeightEquals: aWeight 
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		portableObjectsPoints = portableObjectsPoints  + portableObject doesItAddPoints ifTrue: [portableObject points] ifFalse: [ 0 ].
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !

portableObjects := #((PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5) (NoPointsPortableObject named: 'help-wanted sign' weighing: 1))!

portableObjects!

portableObjects!

portableObjects!

portableObjects := #((PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5) (NoPointsPortableObject named: 'help-wanted sign' weighing: 1)).!

portableObjects!

portableObjects := #(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5 NoPointsPortableObject named: 'help-wanted sign' weighing: 1).!

portableObjects!

portableObjects size!

portableObjects := #((PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5) (NoPointsPortableObject named: 'help-wanted sign' weighing: 1)).!

portableObjects := #((PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5) (NoPointsPortableObject named: 'help-wanted sign' weighing: 1)).!

portableObjects size!

portableObjects at: 1!

(portableObjects at: 1) at:1!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:14:40' prior: 50894282!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack portableObjects |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	portableObjects := OrderedCollection new.
		
	portableObjects add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	portableObjects add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self shouldAddPortableObjects: portableObjects  On:  aBackpack.! !
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:14:49'!
shouldAddPortableObjects: portableObjects On: aBackpack
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		portableObjectsPoints = portableObjectsPoints  + portableObject doesItAddPoints ifTrue: [portableObject points] ifFalse: [ 0 ].
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !

!methodRemoval: BackpackTest #shouldAddPortableObjects:On:IfWeightEquals: stamp: 'FC 10/15/2020 19:14:52'!
shouldAddPortableObjects: portableObjects On: aBackpack IfWeightEquals: aWeight 
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		portableObjectsPoints = portableObjectsPoints  + portableObject doesItAddPoints ifTrue: [portableObject points] ifFalse: [ 0 ].
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:15:09'!
ERROR!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:15:09'!
ERROR!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:15:33' prior: 50898608!
shouldAddPortableObjects: portableObjects On: aBackpack
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		portableObjectsPoints = portableObjectsPoints  + (portableObject doesItAddPoints ifTrue: [portableObject points] ifFalse: [ 0 ]).
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:15:37'!
ERROR!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:15:37'!
ERROR!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:16:18' prior: 50898664!
shouldAddPortableObjects: portableObjects On: aBackpack
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		portableObject doesItAddPoints ifTrue:  [portableObjectsPoints = portableObjectsPoints  +portableObject points].
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:16:20'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:16:20'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:16:21'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:16:21'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:16:21'!
ERROR!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:17:13' prior: 50898695!
shouldAddPortableObjects: portableObjects On: aBackpack
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		portableObject doesItAddPoints ifTrue:  [portableObjectsPoints = portableObjectsPoints  + (portableObject points)].
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:17:15'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:17:15'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:17:15'!
ERROR!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:18:19' prior: 50898777!
shouldAddPortableObjects: portableObjects On: aBackpack
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		(portableObject doesItAddPoints) ifTrue:  [portableObjectsPoints = portableObjectsPoints  + (portableObject points)].
		portableObjectsWeight = portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:18:29' prior: 50898859!
shouldAddPortableObjects: portableObjects On: aBackpack
	
	| portableObjectsPoints portableObjectsWeight |
	
	portableObjectsPoints := 0.
	portableObjectsWeight  := 0.
	
	portableObjects do: [ :portableObject | 
		(portableObject doesItAddPoints) ifTrue:  [portableObjectsPoints := portableObjectsPoints  + (portableObject points)].
		portableObjectsWeight := portableObjectsWeight  + portableObject weight.
		aBackpack add: portableObject.
	].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: portableObjectsWeight.
	self assert: aBackpack totalPoints equals: portableObjectsPoints.
! !

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:18:34'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'FC 10/15/2020 19:19:21' prior: 50894299!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack portableObjects |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	portableObjects := OrderedCollection new.

	portableObjects add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	portableObjects add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	portableObjects add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self shouldAddPortableObjects: portableObjects On: aBackpack.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:19:27'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 19:19:30'!
PASSED!

----SNAPSHOT----(15 October 2020 19:20:31) CuisUniversity-4383.image priorSource: 18002684!

!methodRemoval: Backpack #totalPointsOriginal stamp: 'FC 10/15/2020 19:26:29'!
totalPointsOriginal
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.!

!methodRemoval: Backpack #totalWeightOriginal stamp: 'FC 10/15/2020 19:26:31'!
totalWeightOriginal
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= self size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.!
!Door methodsFor: 'playable character reactions' stamp: 'FC 10/15/2020 19:26:51' prior: 50898001 overrides: 50894933!
toBeUsedBy: aPlayableCharacter
	state use.! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 19:27:03'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:27:08'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:27:08'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 19:28:16' prior: 50897423!
totalWeight
	
	^container sum:  [:portableObject | portableObject weight].
	"
	End of block expected ->container inject: 0 into: [:total :portableObject | total + portableObject weight ].
	"! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:28:20'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:28:20'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:28:21'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:28:21'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:28:21'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:28:21'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:28:21'!
FAILURE!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:28:21'!
FAILURE!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:28:21'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:28:21'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:28:21'!
ERROR!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:28:21'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:28:21'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:28:21'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:28:21'!
ERROR!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:29:32'!
FAILURE!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:29:32'!
FAILURE!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:29:32'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:29:32'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:29:32'!
ERROR!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:29:32'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:29:32'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:29:32'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:29:32'!
ERROR!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:29:34'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:29:49'!
ERROR!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:29:55'!
FAILURE!
!Backpack methodsFor: 'accessing' stamp: 'FC 10/15/2020 19:31:13' prior: 50899145!
totalWeight

	^container inject: 0 into: [:total :portableObject | total + portableObject weight ].
! !

----SNAPSHOT----(15 October 2020 19:31:21) CuisUniversity-4383.image priorSource: 18155861!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'FC 10/15/2020 19:32:16'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'FC 10/15/2020 19:32:17'!
PASSED!

----STARTUP---- (22 October 2020 17:16:47) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!


!classRemoval: #OONotEmptyStackState stamp: 'FC 10/22/2020 17:16:54'!
OOStackState subclass: #OONotEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1a'!

!classRemoval: #OOEmptyStackState stamp: 'FC 10/22/2020 17:16:54'!
OOStackState subclass: #OOEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1a'!

!classRemoval: #OOStackState stamp: 'FC 10/22/2020 17:16:55'!
Object subclass: #OOStackState
	instanceVariableNames: 'stack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1a'!

!classRemoval: #OOStack stamp: 'FC 10/22/2020 17:16:55'!
Object subclass: #OOStack
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1a'!

!classRemoval: #OOStackTest stamp: 'FC 10/22/2020 17:16:55'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Solution-1a'!

Object subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!

!classDefinition: #Rot13Test category: 'Rot13' stamp: 'FC 10/22/2020 17:18:24'!
Object subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!

TestCase subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!

!classDefinition: #Rot13Test category: 'Rot13' stamp: 'FC 10/22/2020 17:22:13'!
TestCase subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!
!Rot13Test methodsFor: 'nil' stamp: 'FC 10/22/2020 17:22:37'!
test01
	self assert: '' equals: '' asRot13.! !

!testRun: #Rot13Test #test01 stamp: 'FC 10/22/2020 17:22:42'!
ERROR!

!testRun: #Rot13Test #test01 stamp: 'FC 10/22/2020 17:22:42'!
ERROR!
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 17:22:52'!
asRot13
	self shouldBeImplemented.! !
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 17:23:00' prior: 50899440!
asRot13
	^''! !

!testRun: #Rot13Test #test01 stamp: 'FC 10/22/2020 17:23:02'!
PASSED!

!testRun: #Rot13Test #test01 stamp: 'FC 10/22/2020 17:23:06'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 17:28:50'!
test02
	self assert: 'n' equals: 'a' asRot13.! !
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 17:29:24' prior: 50899444!
asRot13
	self isEmpty ifTrue: [^self] ifFalse: [^'n'].! !

!testRun: #Rot13Test #test02 stamp: 'FC 10/22/2020 17:29:29'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 17:35:21'!
test03
	self assert: 'm' equals: 'b' asRot13.! !
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 17:39:27' prior: 50899456!
asRot13
	self isEmpty ifTrue: [^self].
	
	self = 'a' ifTrue: [^'n'].
	
	^'m'! !
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 17:39:34' prior: 50899467!
asRot13
	self isEmpty ifTrue: [^self].
	
	self = 'a' ifTrue: [^'n'].
	
	^'o'! !
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 17:39:41' prior: 50899463!
test03
	self assert: 'o' equals: 'b' asRot13.! !

!testRun: #Rot13Test #test03 stamp: 'FC 10/22/2020 17:39:49'!
PASSED!

	'o' asciiValue.!

	'o' ascii !

	'p' asUtf8 !

	'p' asUtf8 !

	$p asciiValue !

	$a asciiValue !

	$a asciiValue !

	$a asciiValue - 97!

	($a asciiValue - 97) + 13 mod: 26.!

	($z asciiValue - 97) + 13 mod: 26.!

	($n asciiValue - 97) + 13 mod: 26.!

	(($n asciiValue - 97) + 13 mod: 26) + 97.!
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 17:51:29' prior: 50899472!
asRot13
	self isEmpty ifTrue: [^self].
	
	(Character asciiValue: ((self first asciiValue - 97) + 13 mod: 26) + 97) asString.! !

!testRun: #Rot13Test #test01 stamp: 'FC 10/22/2020 17:51:34'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'FC 10/22/2020 17:51:34'!
FAILURE!

!testRun: #Rot13Test #test03 stamp: 'FC 10/22/2020 17:51:34'!
FAILURE!

!testRun: #Rot13Test #test02 stamp: 'FC 10/22/2020 17:51:38'!
FAILURE!

!testRun: #Rot13Test #test02 stamp: 'FC 10/22/2020 17:51:48'!
FAILURE!
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 18:07:55' prior: 50899494!
asRot13
	self isEmpty ifTrue: [^self].
	
	self < 'n' ifTrue: [
		^Character  asciiValue: (self first asciiValue +13 ) asString.			
	]
			ifFalse: [
		^Character  asciiValue: (self first asciiValue -13 ) asString.			
				]
	! !

!testRun: #Rot13Test #test03 stamp: 'FC 10/22/2020 18:08:00'!
ERROR!

!testRun: #Rot13Test #test03 stamp: 'FC 10/22/2020 18:08:00'!
ERROR!
!String methodsFor: '*Rot13' stamp: 'FC 10/22/2020 18:08:26' prior: 50899512!
asRot13
	self isEmpty ifTrue: [^self].
	
	self < 'n' ifTrue: [
		^(Character  asciiValue: self first asciiValue +13 ) asString.			
	]
			ifFalse: [
		^(Character  asciiValue: self first asciiValue - 13 ) asString.			
				]
	! !

!testRun: #Rot13Test #test03 stamp: 'FC 10/22/2020 18:08:29'!
PASSED!

!testRun: #Rot13Test #test01 stamp: 'FC 10/22/2020 18:08:32'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'FC 10/22/2020 18:08:32'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'FC 10/22/2020 18:08:32'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 18:09:10'!
test06
	self assert: 'ubyn' equals: 'hola' asRot13.! !

!testRun: #Rot13Test #test06 stamp: 'FC 10/22/2020 18:09:16'!
FAILURE!

!testRun: #Rot13Test #test06 stamp: 'FC 10/22/2020 18:09:17'!
FAILURE!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 18:09:30'!
test04
	self assert: 'a' equals: 'n' asRot13.! !

!testRun: #Rot13Test #test04 stamp: 'FC 10/22/2020 18:09:34'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 18:09:45'!
test05
	self assert: 'b' equals: 'o' asRot13.! !
!FinderMorph methodsFor: 'GUI building' stamp: 'FC 10/22/2020 19:27:41' prior: 50875559!
toolbarButtonFor: aCatalog

	^ (PluggableButtonMorph
		model: (CatalogButton for: aCatalog model: model)
		stateGetter: #isSelected
		action: #value
		label: aCatalog name)
		color: (Theme current buttonColorFrom: self windowColor); 
		yourself! !
!FinderMorph methodsFor: 'GUI building' stamp: 'FC 10/22/2020 19:28:28' prior: 50899566!
toolbarButtonFor: aCatalog

	^ (PluggableButtonMorph
		model: (CatalogButton for: aCatalog model: model)
		stateGetter: #isSelected
		action: #value
		label: aCatalog name)
		color: (Theme current buttonColorFrom: Theme current background ); 
		yourself! !
Custom list morph for showing finder results that disables keyboard focus.!
I am responsible for capturing the query to be performed.

Performance
=========

To avoid notifying changes every time a key is pressed, I keep track of the date and time of the last keystroke (see #processKeyStroke).
I use that information in my #stepAt: method to check whether I should notify #query has changed or not, using my #timeToWaitBeforeNotifyingChanges instance variable.

Hacks
====
To implement shortcuts, I use SearchBoxEditor (see #initializeSearchBoxEditor and comments in SearchBoxEditor class).


!
I am a catalog that contains all tools available in the World > Open... menu.

To avoid hardcoding them, I look for implementors of #worldMenuForOpenGroup and evaluate them to retrieve each menu item (see #initializeTools).!
I represent a catalog button's model.

The way catatalog buttons work in FinderWindow is similar to radio buttons: only
one can be active at a time, and once one is selected the previous catalog button
is deselected.

To react to selected catalog change events, I subscribe to my finder to determine whether 
I am the selected catalog or not (see #isSelected).

When I am clicked, I set myself as the selected catalog (see #value).!
My purpose is wrapping instances of TextEditor to override keyboard shortcuts.

If I cannot handle a keyboard event, I forward it to my wrapped text editor.

Any message I do not override is forwarded to my wrapped editor as well.

I also forward event to the results list, so it can be browsed from the editor (see)

Note
===
I exist as a hack, only to allow overriding keyboard handlers.

The way I am installed, and replace, an InnerTextMorph's editor is by assigning 
its #editor instance variable using reflection (see #installOn:mode: in my class).

Currently, TextEditor's keyboard shortcut mappings are shared among all instances and 
cannot be modified/overriden for a particular instance (see Editor>>#shortcuts).!

----SNAPSHOT----(22 October 2020 19:34:34) CuisUniversity-4383.image priorSource: 18164135!
Custom list morph for showing finder results that disables keyboard focus.!
I am responsible for capturing the query to be performed.

Performance
=========

To avoid notifying changes every time a key is pressed, I keep track of the date and time of the last keystroke (see #processKeyStroke).
I use that information in my #stepAt: method to check whether I should notify #query has changed or not, using my #timeToWaitBeforeNotifyingChanges instance variable.

Hacks
====
To implement shortcuts, I use SearchBoxEditor (see #initializeSearchBoxEditor and comments in SearchBoxEditor class).


!
I am a catalog that contains all tools available in the World > Open... menu.

To avoid hardcoding them, I look for implementors of #worldMenuForOpenGroup and evaluate them to retrieve each menu item (see #initializeTools).!
I represent a catalog button's model.

The way catatalog buttons work in FinderWindow is similar to radio buttons: only
one can be active at a time, and once one is selected the previous catalog button
is deselected.

To react to selected catalog change events, I subscribe to my finder to determine whether 
I am the selected catalog or not (see #isSelected).

When I am clicked, I set myself as the selected catalog (see #value).!
My purpose is wrapping instances of TextEditor to override keyboard shortcuts.

If I cannot handle a keyboard event, I forward it to my wrapped text editor.

Any message I do not override is forwarded to my wrapped editor as well.

I also forward event to the results list, so it can be browsed from the editor (see)

Note
===
I exist as a hack, only to allow overriding keyboard handlers.

The way I am installed, and replace, an InnerTextMorph's editor is by assigning 
its #editor instance variable using reflection (see #installOn:mode: in my class).

Currently, TextEditor's keyboard shortcut mappings are shared among all instances and 
cannot be modified/overriden for a particular instance (see Editor>>#shortcuts).!
Custom list morph for showing finder results that disables keyboard focus.!
I am responsible for capturing the query to be performed.

Performance
=========

To avoid notifying changes every time a key is pressed, I keep track of the date and time of the last keystroke (see #processKeyStroke).
I use that information in my #stepAt: method to check whether I should notify #query has changed or not, using my #timeToWaitBeforeNotifyingChanges instance variable.

Hacks
====
To implement shortcuts, I use SearchBoxEditor (see #initializeSearchBoxEditor and comments in SearchBoxEditor class).


!
I am a catalog that contains all tools available in the World > Open... menu.

To avoid hardcoding them, I look for implementors of #worldMenuForOpenGroup and evaluate them to retrieve each menu item (see #initializeTools).!
I represent a catalog button's model.

The way catatalog buttons work in FinderWindow is similar to radio buttons: only
one can be active at a time, and once one is selected the previous catalog button
is deselected.

To react to selected catalog change events, I subscribe to my finder to determine whether 
I am the selected catalog or not (see #isSelected).

When I am clicked, I set myself as the selected catalog (see #value).!
My purpose is wrapping instances of TextEditor to override keyboard shortcuts.

If I cannot handle a keyboard event, I forward it to my wrapped text editor.

Any message I do not override is forwarded to my wrapped editor as well.

I also forward event to the results list, so it can be browsed from the editor (see)

Note
===
I exist as a hack, only to allow overriding keyboard handlers.

The way I am installed, and replace, an InnerTextMorph's editor is by assigning 
its #editor instance variable using reflection (see #installOn:mode: in my class).

Currently, TextEditor's keyboard shortcut mappings are shared among all instances and 
cannot be modified/overriden for a particular instance (see Editor>>#shortcuts).!
Custom list morph for showing finder results that disables keyboard focus.!
I am responsible for capturing the query to be performed.

Performance
=========

To avoid notifying changes every time a key is pressed, I keep track of the date and time of the last keystroke (see #processKeyStroke).
I use that information in my #stepAt: method to check whether I should notify #query has changed or not, using my #timeToWaitBeforeNotifyingChanges instance variable.

Hacks
====
To implement shortcuts, I use SearchBoxEditor (see #initializeSearchBoxEditor and comments in SearchBoxEditor class).


!
I am a catalog that contains all tools available in the World > Open... menu.

To avoid hardcoding them, I look for implementors of #worldMenuForOpenGroup and evaluate them to retrieve each menu item (see #initializeTools).!
I represent a catalog button's model.

The way catatalog buttons work in FinderWindow is similar to radio buttons: only
one can be active at a time, and once one is selected the previous catalog button
is deselected.

To react to selected catalog change events, I subscribe to my finder to determine whether 
I am the selected catalog or not (see #isSelected).

When I am clicked, I set myself as the selected catalog (see #value).!
My purpose is wrapping instances of TextEditor to override keyboard shortcuts.

If I cannot handle a keyboard event, I forward it to my wrapped text editor.

Any message I do not override is forwarded to my wrapped editor as well.

I also forward event to the results list, so it can be browsed from the editor (see)

Note
===
I exist as a hack, only to allow overriding keyboard handlers.

The way I am installed, and replace, an InnerTextMorph's editor is by assigning 
its #editor instance variable using reflection (see #installOn:mode: in my class).

Currently, TextEditor's keyboard shortcut mappings are shared among all instances and 
cannot be modified/overriden for a particular instance (see Editor>>#shortcuts).!

TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLifeTest category: 'GameOfLife' stamp: 'FC 10/22/2020 20:05:59'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLife category: 'GameOfLife' stamp: 'FC 10/22/2020 20:13:50'!
Object subclass: #GameOfLife
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLifeTest methodsFor: 'nil' stamp: 'FC 10/22/2020 20:13:43'!
test01
	| aBoard |
	aBoard := 
	GameOfLife new.! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 20:13:55' prior: 50899608!
test01
	| aBoard |
	aBoard := 	GameOfLife new.! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'FC 10/22/2020 20:14:39' prior: 50899613!
test01
	| aBoard |
	aBoard := 	GameOfLife new.
	
	self assert: aBoard isEmpty.! !

!testRun: #GameOfLifeTest #test01 stamp: 'FC 10/22/2020 20:14:44'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'FC 10/22/2020 20:14:44'!
ERROR!
!GameOfLife methodsFor: 'a' stamp: 'FC 10/22/2020 20:14:51'!
isEmpty
	self shouldBeImplemented.! !
!GameOfLife methodsFor: 'a' stamp: 'FC 10/22/2020 20:14:55' prior: 50899628!
isEmpty
	^true! !

!testRun: #GameOfLifeTest #test01 stamp: 'FC 10/22/2020 20:14:58'!
PASSED!

!testRun: #GameOfLifeTest #test01 stamp: 'FC 10/22/2020 20:15:00'!
PASSED!

!testRun: #GameOfLifeTest #test01 stamp: 'FC 10/22/2020 20:15:00'!
PASSED!

----SNAPSHOT----(22 October 2020 23:25:59) CuisUniversity-4383.image priorSource: 18173984!
!FinderMorph methodsFor: 'GUI building' stamp: 'FC 10/23/2020 11:34:35' prior: 50875535!
buildResults

	results := (FinderResultsListMorph 
		model: model
		listGetter: #results
		indexGetter: #selectedResultIndex
		indexSetter: #selectedResultIndex:)
		color: Theme current textEditor;
		autoDeselect: false;
		setProperty: #click:localPosition:
		toValue: [ :aMouseEvent :localEventPosition | self browseResultAt: localEventPosition ]! !
!FinderMorph methodsFor: 'GUI building' stamp: 'FC 10/23/2020 11:34:44' prior: 50899646!
buildResults

	results := (FinderResultsListMorph 
		model: model
		listGetter: #results
		indexGetter: #selectedResultIndex
		indexSetter: #selectedResultIndex:)
		color: Theme current textPane;
		autoDeselect: false;
		setProperty: #click:localPosition:
		toValue: [ :aMouseEvent :localEventPosition | self browseResultAt: localEventPosition ]! !

----STARTUP---- (25 October 2020 17:09:23) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!

!FinderMorph methodsFor: 'GUI building' stamp: 'FC 10/23/2020 11:34:35' prior: 50875535!
buildResults

	results := (FinderResultsListMorph 
		model: model
		listGetter: #results
		indexGetter: #selectedResultIndex
		indexSetter: #selectedResultIndex:)
		color: Theme current textEditor;
		autoDeselect: false;
		setProperty: #click:localPosition:
		toValue: [ :aMouseEvent :localEventPosition | self browseResultAt: localEventPosition ]! !
!FinderMorph methodsFor: 'GUI building' stamp: 'FC 10/23/2020 11:34:44' prior: 50899678!
buildResults

	results := (FinderResultsListMorph 
		model: model
		listGetter: #results
		indexGetter: #selectedResultIndex
		indexSetter: #selectedResultIndex:)
		color: Theme current textPane;
		autoDeselect: false;
		setProperty: #click:localPosition:
		toValue: [ :aMouseEvent :localEventPosition | self browseResultAt: localEventPosition ]! !

TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:10:23'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:13:07'!
Object subclass: #MarsRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'no messages' stamp: 'FC 10/25/2020 17:13:20'!
test01
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #N.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:13:34'!
ERROR!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:13:34'!
ERROR!
!MarsRover class methodsFor: 'instance creation' stamp: 'FC 10/25/2020 17:13:40'!
withPosition: aPoint facing: aSymbol 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithPosition: aPoint facing: aSymbol ! !
!MarsRover class methodsFor: 'instance creation' stamp: 'FC 10/25/2020 17:14:14' prior: 50899737!
withPosition: aCoordinate facing: aCardinalPoint 

	^self new initializeWithPosition: aCoordinate facing: aCardinalPoint ! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:14:15'!
ERROR!

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:14:25'!
Object subclass: #MarsRover
	instanceVariableNames: 'coordinate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:14:25'!
Object subclass: #MarsRover
	instanceVariableNames: 'coordinate cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRover methodsFor: 'initialize' stamp: 'FC 10/25/2020 17:14:25'!
initializeWithPosition: aCoordinate facing: aCardinalPoint 
	self shouldBeImplemented.
	coordinate := aCoordinate.
	cardinalPoint := aCardinalPoint.! !
!MarsRover methodsFor: 'initialize' stamp: 'FC 10/25/2020 17:14:35' prior: 50899770!
initializeWithPosition: aCoordinate facing: aCardinalPoint 
	coordinate := aCoordinate.
	cardinalPoint := aCardinalPoint.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:14:42'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:14:50'!
makeMovements: aString 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:14:57' prior: 50899787!
makeMovements: aString 
	! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:14:59'!
ERROR!
!MarsRover methodsFor: 'acessing' stamp: 'FC 10/25/2020 17:15:10'!
currentPosition
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'acessing' stamp: 'FC 10/25/2020 17:15:23' prior: 50899798!
currentPosition
 	^1@1.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:15:25'!
ERROR!
!MarsRover methodsFor: 'acessing' stamp: 'FC 10/25/2020 17:15:33'!
currentDirection
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'acessing' stamp: 'FC 10/25/2020 17:15:52' prior: 50899809!
currentDirection
	^#N.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:15:55'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:16:02'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:16:45'!
test02
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: #N.! !

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:16:48'!
FAILURE!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:16:48'!
FAILURE!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:16:57'!
FAILURE!

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:17:39'!
Object subclass: #MarsRover
	instanceVariableNames: 'coordinate cardinalPoint position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:17:32' prior: 50899792!
makeMovements: aString
	position := 0@1. 
	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:17:58' prior: 50899847!
makeMovements: aString
	coordinate := 0@1. 
	! !

Object subclass: #MarsRover
	instanceVariableNames: 'coordinate cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:18:02'!
Object subclass: #MarsRover
	instanceVariableNames: 'coordinate cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:18:11'!
FAILURE!
!MarsRover methodsFor: 'acessing' stamp: 'FC 10/25/2020 17:18:20' prior: 50899803!
currentPosition
 	^coordinate.! !

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:18:50'!
Object subclass: #MarsRover
	instanceVariableNames: 'position cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:18:50' prior: 50899778!
initializeWithPosition: aCoordinate facing: aCardinalPoint 
	position := aCoordinate.
	cardinalPoint := aCardinalPoint.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:18:50' prior: 50899852!
makeMovements: aString
	position := 0@1. 
	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:18:50' prior: 50899871!
currentPosition
 	^position.! !

!classDefinition: #MarsRover category: 'MarsRover' stamp: 'FC 10/25/2020 17:19:00'!
Object subclass: #MarsRover
	instanceVariableNames: 'position direction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:19:00' prior: 50899883!
initializeWithPosition: aCoordinate facing: aCardinalPoint 
	position := aCoordinate.
	direction := aCardinalPoint.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:19:40' prior: 50899890!
makeMovements: aString
	aString size > 0 ifTrue: [
		position := 0@1. 
	]	
! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:19:46'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:19:46'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:20:21' prior: 50899823!
test02
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #E.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:20:26'!
test03
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #E.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:16:45' prior: 50899925!
test02
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: #N.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:22:08' prior: 50899914!
makeMovements: aString
	
	aString = 'f' ifTrue: [
		position := 0@1 
	].

	aString = 'r' ifTrue	: [
		
	]
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:22:16' prior: 50899954!
makeMovements: aString
	
	aString = 'f' ifTrue: [
		position := 0@1 
	].

	aString = 'r' ifTrue	: [
		
	]
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:22:30' prior: 50899961!
makeMovements: aString
	
	aString = 'f' ifTrue: [
		position := 0@1 
	].

	aString = 'r' ifTrue	: [
		direction := #E
	]
! !

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:22:34'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:22:34'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:22:45' prior: 50899968!
makeMovements: aString
	
	aString = 'f' ifTrue: [
		position := 0@1 
	].

	(aString = 'r') ifTrue	: [
		direction := #E
	]
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:22:52' prior: 50899980!
makeMovements: aString
	
	(aString = 'f') ifTrue: [
		position := 0@1 
	].

	(aString = 'r') ifTrue	: [
		direction := #E
	]
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:23:06' prior: 50899987!
makeMovements: aString
	
	(aString = 'f') ifTrue: [
		position := 0@1 
	].

	(aString = 'r') ifTrue	: [
		direction := #E
	].
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:23:15' prior: 50899994!
makeMovements: aString
	
	(aString = 'f') ifTrue: [
		position := 0@1.
	].

	(aString = 'r') ifTrue	: [
		direction := #E.
	].
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:24:30' prior: 50900001!
makeMovements: aString
	
	aString = 'f' ifTrue: [
		position := 0@1.
		].
	
	aString = 'r' ifTrue: [
		direction := #E.
		]! !

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:24:33'!
FAILURE!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:24:33'!
FAILURE!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:24:43'!
PASSED!
!MarsRover methodsFor: 'accessing' stamp: 'FC 10/25/2020 17:24:54' prior: 50899814!
currentDirection
	^direction.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:24:57'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:24:57'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:24:57'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:29:06' prior: 50900009!
makeMovements: aCommandSequence
	
	(aCommandSequence = 'f' or: [aCommandSequence = 'b'])
	 ifTrue: [
		self moveBasedOnDirection: aCommandSequence
		].
	
	(aCommandSequence = 'r' or: [aCommandSequence = 'l'])
	ifTrue: [
		self rotate: aCommandSequence.
		]! !

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:29:16'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:29:16'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:29:23'!
rotate: aString 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:29:40' prior: 50900050!
rotate: aCommand 
	^#E.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:29:52' prior: 50900055!
rotate: aCommand 
	direction := #E.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:30:09'!
moveBasedOnDirection: aCommand 
	position := 0@1.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:30:12'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:30:12'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:30:12'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:31:07'!
test04
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: 'b'.
	
	self assert: rover currentPosition equals: 2@1.
	self assert: rover currentDirection equals: #N.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:35:09' prior: 50900063!
moveBasedOnDirection: aCommand 
	
	|directionToMove|
	
	directionToMove := self facingPoint.
	
	aCommand = 'f' ifTrue: [ position := position + directionToMove ]
				  ifFalse:[ position := position  - directionToMove ] ! !
!MarsRover methodsFor: 'accessing' stamp: 'FC 10/25/2020 17:36:36'!
facingPoint
 	
	position = #N ifTrue: [^-1@0].
	position = #E ifTrue: [^0@1].
	position = #S ifTrue: [^1@0].
	position = #W ifTrue:[^0@-1].! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:36:41'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:36:41'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:36:41'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 17:36:41'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:36:44'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:37:26'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:37:27'!
ERROR!
!MarsRover methodsFor: 'accessing' stamp: 'FC 10/25/2020 17:38:18' prior: 50900095!
facingPoint
 	
	direction = #N ifTrue: [^-1@0].
	direction = #E ifTrue: [^0@1].
	direction = #S ifTrue: [^1@0].
	direction = #W ifTrue:[^0@-1].! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:38:22'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:38:22'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:38:22'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 17:38:22'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:38:48'!
test05
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: #N.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #W.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:39:40' prior: 50900059!
rotate: aCommand
	aCommand = 'l' ifTrue: [ direction := #W ] ifFalse: 
	[	direction := #E. ]! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:39:45'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:39:45'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:39:45'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 17:39:45'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 17:39:45'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:40:27' prior: 50900146!
rotate: aCommand

	aCommand = 'l' ifTrue: [ direction := #W ] ifFalse: 
	[	direction := #E. ]! !

Object subclass: #CardinalPoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #CardinalPoint category: 'MarsRover' stamp: 'FC 10/25/2020 17:40:40'!
Object subclass: #CardinalPoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!CardinalPoint methodsFor: 'nil' stamp: 'FC 10/25/2020 17:41:35'!
facingPoint
	self subclassResponsibility.! !
!CardinalPoint methodsFor: 'nil' stamp: 'FC 10/25/2020 17:41:51'!
leftRotate
	self subclassResponsibility ! !
!CardinalPoint methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:41:57'!
rightRotate
	self subclassResponsibility ! !

CardinalPoint subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #North category: 'MarsRover' stamp: 'FC 10/25/2020 17:42:11'!
CardinalPoint subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

CardinalPoint subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #East category: 'MarsRover' stamp: 'FC 10/25/2020 17:42:13'!
CardinalPoint subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

CardinalPoint subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #South category: 'MarsRover' stamp: 'FC 10/25/2020 17:42:15'!
CardinalPoint subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

CardinalPoint subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #West category: 'MarsRover' stamp: 'FC 10/25/2020 17:42:18'!
CardinalPoint subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!East methodsFor: 'no messages' stamp: 'FC 10/25/2020 17:42:52' overrides: 50900180!
facingPoint
	^'a'! !
!East methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:43:14' prior: 50900235 overrides: 50900180!
facingPoint
	^0@1! !
!North methodsFor: 'nil' stamp: 'FC 10/25/2020 17:43:28' overrides: 50900180!
facingPoint
	^-1@0.! !
!South methodsFor: 'no messages' stamp: 'FC 10/25/2020 17:43:45' overrides: 50900180!
facingPoint
	^1@0.! !
!West methodsFor: 'no messages' stamp: 'FC 10/25/2020 17:43:58' overrides: 50900180!
facingPoint
	^0@-1.! !
!North methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:44:27' overrides: 50900184!
leftRotate
	^East.! !
!North methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:44:34' overrides: 50900188!
rightRotate
	^West.! !
!South methodsFor: 'nil' stamp: 'FC 10/25/2020 17:44:50' overrides: 50900184!
leftRotate
	^West.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:44:55' overrides: 50900188!
rightRotate
	^East.! !
!West methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:45:12' overrides: 50900184!
leftRotate
	^North.! !
!West methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:45:33' prior: 50900272 overrides: 50900184!
leftRotate
	^North.! !
!West methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:45:39' prior: 50900277 overrides: 50900184!
leftRotate
	^South.! !
!West methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:45:45' overrides: 50900188!
rightRotate
	^North.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:45:52' prior: 50900268 overrides: 50900188!
rightRotate
	^West.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:46:06' prior: 50900291 overrides: 50900188!
rightRotate
	^East.! !
!North methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:47:03' prior: 50900256 overrides: 50900184!
leftRotate
	^West.! !
!North methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:47:07' prior: 50900260 overrides: 50900188!
rightRotate
	^East.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:47:19' prior: 50900296 overrides: 50900188!
rightRotate
	^West.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:47:24' prior: 50900264 overrides: 50900184!
leftRotate
	^East.! !
!East methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:47:42' overrides: 50900184!
leftRotate
	^North.! !
!East methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:47:49' overrides: 50900188!
rightRotate
	^South.! !

!methodRemoval: MarsRover #facingPoint stamp: 'FC 10/25/2020 17:48:02'!
facingPoint
 	
	direction = #N ifTrue: [^-1@0].
	direction = #E ifTrue: [^0@1].
	direction = #S ifTrue: [^1@0].
	direction = #W ifTrue:[^0@-1].!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:48:37' prior: 50900085!
moveBasedOnDirection: aCommand 
	
	|directionToMove|
	
	directionToMove := self direction facingPoint.
	
	aCommand = 'f' ifTrue: [ position := position + directionToMove ]
				  ifFalse:[ position := position  - directionToMove ] ! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:48:48' prior: 50899723!
test01
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: North new.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #N.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:48:51'!
FAILURE!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:48:51'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:49:26' prior: 50900346!
test01
	
	| rover north|
	
	north := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:49:30'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:49:50' prior: 50899944!
test02
	
	| rover north|
	
	north := North new.
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: #N.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:49:53' prior: 50900374!
test02
	
	| rover north|
	
	north := North new.
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:50:02' prior: 50899934!
test03
	
	| rover north|
	
	north := North new.
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #E.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:50:10' prior: 50900396!
test03
	
	| rover north east|
	
	north := North new.
	east := East new.
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: #E.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:50:17' prior: 50900407!
test03
	
	| rover north east|
	
	north := North new.
	east := East new.
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.! !

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:56:36'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:56:37'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north2 east2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:56:38'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north2 east2 south2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:56:39'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north2 east2 south2 west2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:56:35'!
setup
	north2 := North new.
	east2 := East new.
	south2 := South new.
	west2 := West new.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:56:48' prior: 50900361!
test01
	
	| rover |
	
	north2 := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north2.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:56:57' prior: 50900385!
test02
	
	| rover north|
	
	north := North new.
	rover := MarsRover withPosition: 1@1 facing: north2.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:03' prior: 50900477!
test02
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north2.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:13' prior: 50900419!
test03
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north2.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east2.! !

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:57:32'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north east2 south2 west2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:32' prior: 50900460!
setup
	north := North new.
	east2 := East new.
	south2 := South new.
	west2 := West new.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:32' prior: 50900498!
test03
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:32' prior: 50900466!
test01
	
	| rover |
	
	north := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:32' prior: 50900488!
test02
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.! !

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:57:38'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north east south2 west2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:38' prior: 50900516!
setup
	north := North new.
	east := East new.
	south2 := South new.
	west2 := West new.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:38' prior: 50900522!
test03
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.! !

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:57:42'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north east south west2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:42' prior: 50900561!
setup
	north := North new.
	east := East new.
	south := South new.
	west2 := West new.! !

!classDefinition: #MarsRoverTest category: 'MarsRover' stamp: 'FC 10/25/2020 17:57:46'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'north east south west'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:57:46' prior: 50900585!
setup
	north := North new.
	east := East new.
	south := South new.
	west := West new.! !
!West methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:00' prior: 50900282 overrides: 50900184!
leftRotate
	^South new.! !
!West methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:04' prior: 50900286 overrides: 50900188!
rightRotate
	^North new.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:10' prior: 50900311 overrides: 50900188!
rightRotate
	^West new.! !
!South methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:13' prior: 50900316 overrides: 50900184!
leftRotate
	^East new.! !
!North methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:19' prior: 50900301 overrides: 50900184!
leftRotate
	^West new.! !
!North methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:23' prior: 50900306 overrides: 50900188!
rightRotate
	^East new.! !
!East methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:28' prior: 50900320 overrides: 50900184!
leftRotate
	^North new.! !
!East methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:58:31' prior: 50900324 overrides: 50900188!
rightRotate
	^South new.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:59:25' prior: 50900075!
test04
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'b'.
	
	self assert: rover currentPosition equals: 2@1.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 17:59:34' prior: 50900136!
test05
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: west.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 17:59:38'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 17:59:38'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 17:59:38'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 17:59:38'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 17:59:38'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:00:06' prior: 50900164!
rotate: aCommand

	aCommand = 'l' ifTrue: [ direction := #W ] ifFalse: 
	[	direction := #E. ]! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:00:06'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:00:06'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:00:06'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:00:06'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:00:06'!
FAILURE!

!methodRemoval: MarsRover #rotate: stamp: 'FC 10/25/2020 18:00:31'!
rotate: aCommand

	aCommand = 'l' ifTrue: [ direction := #W ] ifFalse: 
	[	direction := #E. ]!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:02:13' prior: 50900034!
makeMovements: aCommandSequence
	
	(aCommandSequence = 'f' or: [aCommandSequence = 'b'])
	 ifTrue: [
		self moveBasedOnDirection: aCommandSequence
		].
	
	aCommandSequence = 'r' 
	ifTrue: [
		direction := direction rightRotate.
		].
	
	aCommandSequence = 'l'
	ifTrue: [
		direction := direction leftRotate.
		]
	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:02:17'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:02:17'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:02:17'!
ERROR!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:02:17'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:02:17'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:02:22'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:02:26'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:02:46' prior: 50900335!
moveBasedOnDirection: aCommand 
	
	|directionToMove|
	
	directionToMove := direction facingPoint.
	
	aCommand = 'f' ifTrue: [ position := position + directionToMove ]
				  ifFalse:[ position := position  - directionToMove ] ! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:02:48'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:02:48'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:02:48'!
ERROR!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:02:48'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:02:48'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:02:52'!
ERROR!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:03:19'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:03:26'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:03:26'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:03:35'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:03:46'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:03:51'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:04:00'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:04:00'!
ERROR!

North new.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:05:11' overrides: 16927572!
setUp
	north := North new.
	east := East new.
	south := South new.
	west := West new.! !

!methodRemoval: MarsRoverTest #setup stamp: 'FC 10/25/2020 18:05:13'!
setup
	north := North new.
	east := East new.
	south := South new.
	west := West new.!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:05:15'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:05:15'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:05:15'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:05:15'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:05:15'!
FAILURE!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:05:17'!
FAILURE!

East new = East new.!

East new == East new.!
!CardinalPoint methodsFor: 'nil' stamp: 'FC 10/25/2020 18:07:07' overrides: 16881029!
= anObject
	self class = anObject class.! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:07:12'!
ERROR!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:07:12'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:07:12'!
ERROR!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:07:12'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:07:12'!
ERROR!

East new = East new.!
!CardinalPoint methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:07:43' prior: 50900801 overrides: 16881029!
= anObject
	^self class = anObject class.! !

East new = East new.!

East new = West new.!

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:07:54'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:07:54'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:07:54'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:07:54'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:07:54'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:09:36'!
test07
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'bbbrff'.
	
	self assert: rover currentPosition equals: 4@3.
	self assert: rover currentDirection equals: east.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:09:47'!
test06
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'bbbrff'.
	
	self assert: rover currentPosition equals: 4@3.
	self assert: rover currentDirection equals: east.! !

!methodRemoval: MarsRoverTest #test07 stamp: 'FC 10/25/2020 18:09:49'!
test07
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'bbbrff'.
	
	self assert: rover currentPosition equals: 4@3.
	self assert: rover currentDirection equals: east.!

!testRun: #MarsRoverTest #test06 stamp: 'FC 10/25/2020 18:10:03'!
FAILURE!

!testRun: #MarsRoverTest #test06 stamp: 'FC 10/25/2020 18:10:03'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:11:27' prior: 50900700!
makeMovements: aCommandSequence
	
	aCommandSequence do: [ :aCommand |
	
	(aCommand = $f or: [ aCommand = $b ])
	 ifTrue: [
		self moveBasedOnDirection: aCommand
		].
	
	aCommand = $r 
	ifTrue: [
		direction := direction rightRotate.
		].
	
	aCommand = $l
	ifTrue: [
		direction := direction leftRotate.
		]
	
	]! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:11:41' prior: 50900730!
moveBasedOnDirection: aCommand 
	
	|directionToMove|
	
	directionToMove := direction facingPoint.
	
	aCommand = $f ifTrue: [ position := position + directionToMove ]
				  ifFalse:[ position := position  - directionToMove ] ! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:11:43'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:11:43'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:11:43'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:11:43'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:11:44'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'FC 10/25/2020 18:11:44'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:13:18' prior: 50900870!
makeMovements: aCommandSequence
	
	aCommandSequence do: [ :aCommand |
	
	(aCommand = $f or: [ aCommand = $b ])
	 ifTrue: [
		self moveBasedOnDirection: aCommand
		].
	
	aCommand = $r 
	ifTrue: [
		direction := direction rightRotate.
		].
	
	aCommand = $l
	ifTrue: [
		direction := direction leftRotate.
		].
	
	]! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:14:37'!
makeMove: aCommand	

	(aCommand = $f or: [ aCommand = $b ])
	 ifTrue: [
		self moveBasedOnDirection: aCommand
		].
	
	aCommand = $r 
	ifTrue: [
		direction := direction rightRotate.
		].
	
	aCommand = $l
	ifTrue: [
		direction := direction leftRotate.
		].! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:14:48'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:14:48'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:14:48'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:14:48'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:14:48'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'FC 10/25/2020 18:14:48'!
PASSED!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:15:21'!
isMovement: aCommand

	^ aCommand = $f or: [ aCommand = $b ]! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:15:21' prior: 50900921!
makeMove: aCommand	

	(self isMovement: aCommand)
	 ifTrue: [
		self moveBasedOnDirection: aCommand
		].
	
	aCommand = $r 
	ifTrue: [
		direction := direction rightRotate.
		].
	
	aCommand = $l
	ifTrue: [
		direction := direction leftRotate.
		].! !

!testRun: #MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:16:52'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:16:52'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:16:52'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:16:52'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:16:52'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'FC 10/25/2020 18:16:52'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:17:13'!
test01RoverWithNoCommandsStaysTheSame
	
	| rover |
	
	north := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:17:36'!
test01RoverWithNoCommandsRemainsTheSame
	
	| rover |
	
	north := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !

!methodRemoval: MarsRoverTest #test01RoverWithNoCommandsStaysTheSame stamp: 'FC 10/25/2020 18:17:36'!
test01RoverWithNoCommandsStaysTheSame
	
	| rover |
	
	north := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:17:46'!
test02RoverMovesForward
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.! !

!methodRemoval: MarsRoverTest #test02 stamp: 'FC 10/25/2020 18:17:49'!
test02
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.!

!methodRemoval: MarsRoverTest #test01 stamp: 'FC 10/25/2020 18:17:51'!
test01
	
	| rover |
	
	north := North new.
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: ''.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:18:08'!
test03RoverRotatesRight
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.! !

!methodRemoval: MarsRoverTest #test03 stamp: 'FC 10/25/2020 18:18:08'!
test03
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:18:23'!
test04MovesBackwards
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'b'.
	
	self assert: rover currentPosition equals: 2@1.
	self assert: rover currentDirection equals: north.! !

!methodRemoval: MarsRoverTest #test04 stamp: 'FC 10/25/2020 18:18:23'!
test04
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'b'.
	
	self assert: rover currentPosition equals: 2@1.
	self assert: rover currentDirection equals: north.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:18:33'!
test05RoverRotatesLeft
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: west.! !

!methodRemoval: MarsRoverTest #test05 stamp: 'FC 10/25/2020 18:18:33'!
test05
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: west.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:19:01'!
test06RoverUnderstandsMoreThanOneCommand
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'bbbrff'.
	
	self assert: rover currentPosition equals: 4@3.
	self assert: rover currentDirection equals: east.! !

!methodRemoval: MarsRoverTest #test06 stamp: 'FC 10/25/2020 18:19:01'!
test06
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'bbbrff'.
	
	self assert: rover currentPosition equals: 4@3.
	self assert: rover currentDirection equals: east.!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:20:31'!
test07RoverStopsAfterInvalidCommand
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	self should: [ rover makeMovements: 'bbbcrff' ]  raise: Error.
	
	self assert: rover currentPosition equals: 4@1.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:20:48' prior: 50901114!
test07RoverStopsAfterInvalidCommand
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	
	self should: [ rover makeMovements: 'bbbcrff' ]  raise: Error.
	
	self assert: rover currentPosition equals: 4@1.
	self assert: rover currentDirection equals: north.! !

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:20:51'!
FAILURE!

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:20:51'!
FAILURE!
!MarsRover class methodsFor: 'instance creation' stamp: 'FC 10/25/2020 18:21:17'!
invalidCommandMessage
	^'Comando invlido'.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:23:08'!
isValidCommand: aCommand

	^ 'fbrl' includes: aCommand.! !

	'fbrl' includes: $a.!

	'fbrl' includes: $f.!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:23:28' prior: 50901148!
isValidCommand: aCommand

	^ 'fbrl' includes: aCommand.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:24:07'!
validCommands

	^ 'fbrl'! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:24:07' prior: 50901155!
isValidCommand: aCommand

	^ self validCommands includes: aCommand.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:25:11' prior: 50900951!
makeMove: aCommand	
	(self isValidCommand: aCommand) ifTrue: [
		(self isMovement: aCommand)
		 ifTrue: [
			self moveBasedOnDirection: aCommand
			].
		
		aCommand = $r 
		ifTrue: [
			direction := direction rightRotate.
			].
		
		aCommand = $l
		ifTrue: [
			direction := direction leftRotate.
			].
	]
	ifFalse: [
		self error: self class invalidCommandMessage.
		]! !

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/25/2020 18:25:17'!
PASSED!

!testRun: #MarsRoverTest #test02RoverMovesForward stamp: 'FC 10/25/2020 18:25:17'!
PASSED!

!testRun: #MarsRoverTest #test03RoverRotatesRight stamp: 'FC 10/25/2020 18:25:17'!
PASSED!

!testRun: #MarsRoverTest #test04MovesBackwards stamp: 'FC 10/25/2020 18:25:17'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRotatesLeft stamp: 'FC 10/25/2020 18:25:17'!
PASSED!

!testRun: #MarsRoverTest #test06RoverUnderstandsMoreThanOneCommand stamp: 'FC 10/25/2020 18:25:17'!
PASSED!

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:25:17'!
FAILURE!

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:25:17'!
FAILURE!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'FC 10/25/2020 18:26:24' prior: 50900908!
makeMovements: aCommandSequence
	
	aCommandSequence do: [ :aCommand |
		self makeMove: aCommand.
	]! !

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!testRun: #MarsRoverTest #test02RoverMovesForward stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!testRun: #MarsRoverTest #test03RoverRotatesRight stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!testRun: #MarsRoverTest #test04MovesBackwards stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRotatesLeft stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!testRun: #MarsRoverTest #test06RoverUnderstandsMoreThanOneCommand stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:26:30'!
PASSED!

!methodRemoval: MarsRover #validCommands stamp: 'FC 10/25/2020 18:32:35'!
validCommands

	^ 'fbrl'!
!MarsRover class methodsFor: 'error' stamp: 'FC 10/25/2020 18:32:58'!
validCommands

	^ 'fbrl'! !
!MarsRover methodsFor: 'testing - private' stamp: 'FC 10/25/2020 18:33:44' prior: 50901164!
isValidCommand: aCommand

	^ self class validCommands includes: aCommand.! !

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test02RoverMovesForward stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test03RoverRotatesRight stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test04MovesBackwards stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRotatesLeft stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test06RoverUnderstandsMoreThanOneCommand stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:33:47'!
PASSED!

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/25/2020 18:34:49'!
PASSED!

!testRun: #MarsRoverTest #test02RoverMovesForward stamp: 'FC 10/25/2020 18:34:49'!
PASSED!

!testRun: #MarsRoverTest #test03RoverRotatesRight stamp: 'FC 10/25/2020 18:34:50'!
PASSED!

!testRun: #MarsRoverTest #test04MovesBackwards stamp: 'FC 10/25/2020 18:34:50'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRotatesLeft stamp: 'FC 10/25/2020 18:34:50'!
PASSED!

!testRun: #MarsRoverTest #test06RoverUnderstandsMoreThanOneCommand stamp: 'FC 10/25/2020 18:34:50'!
PASSED!

!testRun: #MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/25/2020 18:34:50'!
PASSED!

----SNAPSHOT----(25 October 2020 18:34:56) CuisUniversity-4383.image priorSource: 18175733!

----SNAPSHOT----(25 October 2020 18:34:59) CuisUniversity-4383.image priorSource: 18228518!

----STARTUP---- (26 October 2020 15:37:04) as C:\Users\Felip\Desktop\Dev\Inge 1\ST\windows64\CuisUniversity-4383.image!

!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:39:29'!
test02RoverMovesForwardWhenFacingNorth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.! !

!methodRemoval: MarsRoverTest #test02RoverMovesForward stamp: 'FC 10/26/2020 15:39:29'!
test02RoverMovesForward
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:44:06'!
test03RoverMovesAndRotatesWhenFacingNorth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.! !
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:44:34'!
test02RoverRotatesLeftWhenFacingNorth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: west.! !

!methodRemoval: MarsRoverTest #test02RoverMovesForwardWhenFacingNorth stamp: 'FC 10/26/2020 15:44:39'!
test02RoverMovesForwardWhenFacingNorth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	
	rover makeMovements: 'f'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: north.!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:44:58' prior: 50901321!
test03RoverMovesAndRotatesWhenFacingNorth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 0@1.
	self assert: rover currentDirection equals: east.! !

!testRun: #MarsRoverTest #test03RoverMovesAndRotatesWhenFacingNorth stamp: 'FC 10/26/2020 15:45:11'!
PASSED!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:45:39'!
test04RoverRotatesLeftWhenFacingEast
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: east.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:45:42'!
FAILURE!

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:45:42'!
FAILURE!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:45:50' prior: 50901366!
test04RoverRotatesLeftWhenFacingEast
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: east.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: south.! !

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:45:54'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:45:58'!
PASSED!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:47:09'!
test05RoverMovesAndRotatesWhenFacingEast
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: east.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 1@2.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:47:19' prior: 50901383!
test04RoverRotatesLeftWhenFacingEast
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: east.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !

!testRun: #MarsRoverTest #test05RoverMovesAndRotatesWhenFacingEast stamp: 'FC 10/26/2020 15:47:24'!
FAILURE!

!testRun: #MarsRoverTest #test05RoverMovesAndRotatesWhenFacingEast stamp: 'FC 10/26/2020 15:47:24'!
FAILURE!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:47:30' prior: 50901400!
test05RoverMovesAndRotatesWhenFacingEast
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: east.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 1@2.
	self assert: rover currentDirection equals: south.! !

!testRun: #MarsRoverTest #test05RoverMovesAndRotatesWhenFacingEast stamp: 'FC 10/26/2020 15:47:32'!
PASSED!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:48:19'!
test06RoverRotatesLeftWhenFacingSouth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: south.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: west.! !

!testRun: #MarsRoverTest #test06RoverRotatesLeftWhenFacingSouth stamp: 'FC 10/26/2020 15:48:22'!
FAILURE!

!testRun: #MarsRoverTest #test06RoverRotatesLeftWhenFacingSouth stamp: 'FC 10/26/2020 15:48:22'!
FAILURE!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:48:26' prior: 50901442!
test06RoverRotatesLeftWhenFacingSouth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: south.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: East.! !
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:48:34' prior: 50901459!
test06RoverRotatesLeftWhenFacingSouth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: south.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.! !
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:49:10'!
test07RoverMovesAndRotatesWhenFacingSouth
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: south.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 2@1.
	self assert: rover currentDirection equals: west.! !

!testRun: #MarsRoverTest #test07RoverMovesAndRotatesWhenFacingSouth stamp: 'FC 10/26/2020 15:49:13'!
PASSED!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:49:35'!
test08RoverRotatesLeftWhenFacingWest
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: west.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:49:38' prior: 50901494!
test08RoverRotatesLeftWhenFacingWest
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: west.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: south.! !

!testRun: #MarsRoverTest #test08RoverRotatesLeftWhenFacingWest stamp: 'FC 10/26/2020 15:49:41'!
PASSED!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:50:04'!
test07RoverMovesAndRotatesWhenFacingWest
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: west.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 1@0.
	self assert: rover currentDirection equals: north.! !
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:50:07'!
test09RoverMovesAndRotatesWhenFacingWest
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: west.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 1@0.
	self assert: rover currentDirection equals: north.! !

!testRun: #MarsRoverTest #test09RoverMovesAndRotatesWhenFacingWest stamp: 'FC 10/26/2020 15:50:09'!
PASSED!
!MarsRoverTest methodsFor: 'tests' stamp: 'FC 10/26/2020 15:50:17'!
test10RoverStopsAfterInvalidCommand
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	
	self should: [ rover makeMovements: 'bbbcrff' ]  raise: Error.
	
	self assert: rover currentPosition equals: 4@1.
	self assert: rover currentDirection equals: north.! !

!methodRemoval: MarsRoverTest #test04MovesBackwards stamp: 'FC 10/26/2020 15:50:20'!
test04MovesBackwards
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'b'.
	
	self assert: rover currentPosition equals: 2@1.
	self assert: rover currentDirection equals: north.!

!methodRemoval: MarsRoverTest #test03RoverRotatesRight stamp: 'FC 10/26/2020 15:50:21'!
test03RoverRotatesRight
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'r'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: east.!

!methodRemoval: MarsRoverTest #test05RoverRotatesLeft stamp: 'FC 10/26/2020 15:50:22'!
test05RoverRotatesLeft
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'l'.
	
	self assert: rover currentPosition equals: 1@1.
	self assert: rover currentDirection equals: west.!

!methodRemoval: MarsRoverTest #test07RoverStopsAfterInvalidCommand stamp: 'FC 10/26/2020 15:50:25'!
test07RoverStopsAfterInvalidCommand
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	
	self should: [ rover makeMovements: 'bbbcrff' ]  raise: Error.
	
	self assert: rover currentPosition equals: 4@1.
	self assert: rover currentDirection equals: north.!

!methodRemoval: MarsRoverTest #test06RoverUnderstandsMoreThanOneCommand stamp: 'FC 10/26/2020 15:50:29'!
test06RoverUnderstandsMoreThanOneCommand
	
	| rover |
	rover := MarsRover withPosition: 1@1 facing: north.
	rover makeMovements: 'bbbrff'.
	
	self assert: rover currentPosition equals: 4@3.
	self assert: rover currentDirection equals: east.!

!methodRemoval: MarsRoverTest #test07RoverMovesAndRotatesWhenFacingWest stamp: 'FC 10/26/2020 15:50:34'!
test07RoverMovesAndRotatesWhenFacingWest
	
	| rover |
	
	rover := MarsRover withPosition: 1@1 facing: west.
	rover makeMovements: 'ffbr'.
	
	self assert: rover currentPosition equals: 1@0.
	self assert: rover currentDirection equals: north.!

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test02RoverRotatesLeftWhenFacingNorth stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test03RoverMovesAndRotatesWhenFacingNorth stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test05RoverMovesAndRotatesWhenFacingEast stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRotatesLeftWhenFacingSouth stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test07RoverMovesAndRotatesWhenFacingSouth stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRotatesLeftWhenFacingWest stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test09RoverMovesAndRotatesWhenFacingWest stamp: 'FC 10/26/2020 15:50:42'!
PASSED!

!testRun: #MarsRoverTest #test10RoverStopsAfterInvalidCommand stamp: 'FC 10/26/2020 15:50:42'!
PASSED!
!MarsRover methodsFor: 'operations - private' stamp: 'FC 10/26/2020 15:52:23' prior: 50901170!
makeMove: aCommand	
	(self isValidCommand: aCommand) ifTrue: [
		(self isMovement: aCommand)
		 ifTrue: [
			self moveBasedOnDirection: aCommand
			].
		
		aCommand = $r 
		ifTrue: [
			direction := direction rightRotate.
			].
		
		aCommand = $l
		ifTrue: [
			direction := direction leftRotate.
			].
	]
	ifFalse: [
		self error: self class invalidCommandMessage.
		]! !
!MarsRover methodsFor: 'operations - private' stamp: 'FC 10/26/2020 15:52:48'!
errorInvalidCommand

	^ self error: self class invalidCommandMessage! !
!MarsRover methodsFor: 'operations - private' stamp: 'FC 10/26/2020 15:52:48' prior: 50901650!
makeMove: aCommand	
	(self isValidCommand: aCommand) ifTrue: [
		(self isMovement: aCommand)
		 ifTrue: [
			self moveBasedOnDirection: aCommand
			].
		
		aCommand = $r 
		ifTrue: [
			direction := direction rightRotate.
			].
		
		aCommand = $l
		ifTrue: [
			direction := direction leftRotate.
			].
	]
	ifFalse: [
		self errorInvalidCommand.
		]! !

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test02RoverRotatesLeftWhenFacingNorth stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test03RoverMovesAndRotatesWhenFacingNorth stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test05RoverMovesAndRotatesWhenFacingEast stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRotatesLeftWhenFacingSouth stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test07RoverMovesAndRotatesWhenFacingSouth stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRotatesLeftWhenFacingWest stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test09RoverMovesAndRotatesWhenFacingWest stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test10RoverStopsAfterInvalidCommand stamp: 'FC 10/26/2020 15:53:01'!
PASSED!

!testRun: #MarsRoverTest #test01RoverWithNoCommandsRemainsTheSame stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test02RoverRotatesLeftWhenFacingNorth stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test03RoverMovesAndRotatesWhenFacingNorth stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRotatesLeftWhenFacingEast stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test05RoverMovesAndRotatesWhenFacingEast stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRotatesLeftWhenFacingSouth stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test07RoverMovesAndRotatesWhenFacingSouth stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRotatesLeftWhenFacingWest stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test09RoverMovesAndRotatesWhenFacingWest stamp: 'FC 10/26/2020 15:53:08'!
PASSED!

!testRun: #MarsRoverTest #test10RoverStopsAfterInvalidCommand stamp: 'FC 10/26/2020 15:53:08'!
PASSED!